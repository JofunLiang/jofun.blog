{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/QQ20190830144040.png","path":"images/QQ20190830144040.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830144301.png","path":"images/QQ20190830144301.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830144717.png","path":"images/QQ20190830144717.png","modified":0,"renderable":0},{"_id":"source/images/u=3435190451,3701028142&fm=15&gp=0.jpg","path":"images/u=3435190451,3701028142&fm=15&gp=0.jpg","modified":0,"renderable":0},{"_id":"source/images/u=794894107,1623881092&fm=15&gp=0.jpg","path":"images/u=794894107,1623881092&fm=15&gp=0.jpg","modified":0,"renderable":0},{"_id":"source/images/QQ20190830144448.png","path":"images/QQ20190830144448.png","modified":0,"renderable":0},{"_id":"themes/next/source/baidu_verify_bYTYCq8pM9.html","path":"baidu_verify_bYTYCq8pM9.html","modified":0,"renderable":1},{"_id":"themes/next/source/google1cfd61ddc1799b36.html","path":"google1cfd61ddc1799b36.html","modified":0,"renderable":1},{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"source/images/QQ20190830143736.png","path":"images/QQ20190830143736.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830143418.png","path":"images/QQ20190830143418.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830145048.png","path":"images/QQ20190830145048.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830145325.png","path":"images/QQ20190830145325.png","modified":0,"renderable":0},{"_id":"source/images/debugger_closure.png","path":"images/debugger_closure.png","modified":0,"renderable":0},{"_id":"source/images/u=3791572623,1286246317&fm=26&gp=0.jpg","path":"images/u=3791572623,1286246317&fm=26&gp=0.jpg","modified":0,"renderable":0},{"_id":"source/images/QQ20190830144811.png","path":"images/QQ20190830144811.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830145418.png","path":"images/QQ20190830145418.png","modified":0,"renderable":0},{"_id":"source/images/QQ20190830145211.png","path":"images/QQ20190830145211.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/comment_avatar.png","path":"uploads/comment_avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1564109089120},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1564109089120},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1564109089120},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1564109089120},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1564109089120},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1564109089120},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1564109089120},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1564109089120},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1564109089120},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1564109089120},{"_id":"themes/next/_config.yml","hash":"64ffb3e4ce7e43b148190059529eeb8d999e2203","modified":1564109089120},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1564109089120},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1564109089120},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1564109089120},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1564109089229},{"_id":"source/images/QQ20190830144040.png","hash":"555aec58a124469a73244b7337c5010b6865a29f","modified":1567147238330},{"_id":"source/images/QQ20190830144301.png","hash":"cdae20ccbfb1db3cedce22d43c986bc250d725c7","modified":1567147379338},{"_id":"source/images/QQ20190830144717.png","hash":"0434606083c3a4c4674d17e76a11e7f0ac1f7001","modified":1567147634026},{"_id":"source/images/u=3435190451,3701028142&fm=15&gp=0.jpg","hash":"9386a613721dcf39d4ea56338c87fdcc8145b648","modified":1567158765223},{"_id":"source/images/u=794894107,1623881092&fm=15&gp=0.jpg","hash":"c6accf467bcee58494cfa6aa83ab7bcd101eb6da","modified":1567159995026},{"_id":"source/categories/index.md","hash":"efe265d370553fd839bc5e3b6153dd8b8b4a77c4","modified":1564382727794},{"_id":"source/tags/index.md","hash":"010927e375020c965ba3f5f856574bb0570827fe","modified":1564382727795},{"_id":"source/_posts/2018-03-04-设计模式之单例模式.md","hash":"e0b7414cc0198d987c94d02efb9d5200adbac515","modified":1564382727781},{"_id":"source/images/QQ20190830144448.png","hash":"9fa45a0ed3f57d87d0a3b163a7f88649bbd1557f","modified":1567147482402},{"_id":"source/_posts/2018-03-06-设计模式之代理模式.md","hash":"30ba27bb74b31eae97db42df856f728a4d7d608c","modified":1564382727785},{"_id":"source/_posts/2018-03-08-详解JavaScript对象继承方式.md","hash":"7e880fa5940e1a4ea5463b0ea85643911ef9b01f","modified":1566383036572},{"_id":"source/_posts/2018-03-07-设计模式之工厂模式.md","hash":"68a1dcecd76266b6433164af47f3831f0a9885a4","modified":1566383036569},{"_id":"source/_posts/2018-04-12-详解javascript中this的工作原理.md","hash":"bf79e68fa05e01330299ecff33fdcbb20da80632","modified":1566383036578},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1564109089120},{"_id":"source/_posts/2018-03-05-设计模式之策略模式.md","hash":"794785c00984c715f62a041e81a0a9418b380438","modified":1564382727783},{"_id":"source/_posts/2018-04-29-设计模式之依赖注入.md","hash":"c5a4ca3a811930624abc3338767f837678fe214e","modified":1566383036581},{"_id":"source/_posts/2018-04-08-javaScript识别网址并转为链接.md","hash":"daf78fe46b3676995b6ba2bc5551ba32681b19ba","modified":1564110061793},{"_id":"source/_posts/2018-09-13-Vue组件样式scoped的实现原理以及scoped穿透的用法.md","hash":"91ab6707f0a20b007e1259c66e140fd11d6f6e0b","modified":1564109832879},{"_id":"source/_posts/2018-07-03-初次接触CSS变量.md","hash":"f4dc7e201b4a03e24fdec1e6b71b607f551efbee","modified":1564109994968},{"_id":"source/_posts/2018-04-06-理解递归及其应用.md","hash":"c23e13a9c6a33ec94fbc64fb6009b3844c3f99f0","modified":1566383036575},{"_id":"source/_posts/2018-10-28-比较var、let、const的区别.md","hash":"3a9bc3b947c399a50b651d96205100c1eda5770e","modified":1564109755945},{"_id":"source/_posts/2018-11-25-前端JavaScript开发日常技巧.md","hash":"c2252ea0c7407c6bf476a72a3555354d62005264","modified":1564109687678},{"_id":"source/_posts/2018-04-23-设置placeholder样式及隐藏IE浏览器input元素的删除和查看密码图标.md","hash":"7c4d5bc190abe2a9928c51643fb0e9de993442ea","modified":1564109088979},{"_id":"source/_posts/2019-07-21-使用SVG symbols建立图标系统完整指南.md","hash":"3f762f2e688b5379c01abf1f711ae00b308aa7b8","modified":1564109088979},{"_id":"source/_posts/2019-03-11-使用 Webpack 与 Babel 配置 ES6 开发环境.md","hash":"6e49b2a872c590622c71bc5ab55aa677d57e0c20","modified":1564109088979},{"_id":"source/_posts/2019-04-28-gulp + gulp-better-rollup + rollup 构建 ES6 开发环境.md","hash":"f4f040afd3a544d86dadf05b0a78b3fc0c5281d3","modified":1564109088979},{"_id":"source/_posts/2019-06-05-使用custom elements创建自定义元素.md","hash":"40956047e7c1203d2b26e27a8092f66d630795cd","modified":1564109088979},{"_id":"source/_posts/2019-03-05-使用HTML5原生对话框元素，轻松创建模态框组件.md","hash":"1205cdad676502e29f2be98b7f7ab656077a8342","modified":1564109088979},{"_id":"source/_posts/2019-07-22-JavaScript管道语法提案.md","hash":"0e739fb2c30798361569545ae85bcdf78bc3b1a4","modified":1564109500429},{"_id":"source/_posts/2019-07-09-CSS隐藏元素滚动条.md","hash":"a1e8367af13612571dabbe41441024f827ea08a2","modified":1564109088979},{"_id":"source/_posts/2019-07-24-简析JSX语法.md","hash":"5a7843c6e7926a02eda59671174690a216e09490","modified":1564382727786},{"_id":"source/_posts/2019-03-01-前端静态资源自动化处理版本号防缓存.md","hash":"843d1a2386ac6846475568ed5ce4c5a35f1d9667","modified":1564109088979},{"_id":"source/_posts/2019-08-21-理解高阶函数与闭包.md","hash":"46dac405eaf9bed16e573a2f180ece62d03398d7","modified":1566443007092},{"_id":"source/_posts/2019-07-30-浅谈if...else...的优化方法.md","hash":"83829b28fa85f0c560836046b2766ac1b06bb330","modified":1564382742570},{"_id":"source/_posts/2019-08-27-CSS计数器及其应用.md","hash":"56a1a68df4b1e345f9e371cef25fdb1a08d1165c","modified":1567135463574},{"_id":"source/_posts/2019-10-12-编写更好的代码的5个技巧.md","hash":"e868e3596b7e6f96f870030be4f6fab94fc42508","modified":1571801267094},{"_id":"source/_posts/2019-11-16-Vue CLI 3配置svg-sprite-loader与svgo-loader.md","hash":"2f40d51e5988e36bda4a366fc6b081a1d4e417b0","modified":1573892252405},{"_id":"source/_posts/2019-08-30-使用Vue Styleguidist编写组件文档.md","hash":"09d2521f5e67beb7407067b8e138238f9cb10ec7","modified":1567149628624},{"_id":"source/_posts/2019-08-28-数据结构与开发应用之栈.md","hash":"8b5bca3b9d8b2c3e5765fff52d8f4ed0db266172","modified":1567129948377},{"_id":"source/about/index.md","hash":"73a857ff569bacef1846b81d9cd72e5f6c7431c3","modified":1564382727792},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1564109089229},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1564109089229},{"_id":"source/_posts/2019-08-31-数据结构与开发应用之队列.md","hash":"2596680a64cdf768856ba1b9917e48c706164a74","modified":1567160955087},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1564109089151},{"_id":"source/_posts/2019-08-26-深入理解new运算符.md","hash":"b9c8f7c9283a70816dcc70771c6b2c86fdb62f13","modified":1567129948376},{"_id":"source/_posts/2019-07-25-使用Jest进行单元测试.md","hash":"4ccd96fed135a095c5121118365baa6bcedda729","modified":1564136922353},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1564109089229},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1564109089229},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1564109089229},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1564109089229},{"_id":"themes/next/layout/post.swig","hash":"5fee23bb89cb0daffa5198d725516916fd07700b","modified":1564109089229},{"_id":"themes/next/source/baidu_verify_bYTYCq8pM9.html","hash":"2a7baf9729c10f5ee0a56f6695207911da1c0c78","modified":1564109089244},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1564109089229},{"_id":"themes/next/source/google1cfd61ddc1799b36.html","hash":"96ac779e2a77ad67c0424fe14c94c7ae1d5d8dc7","modified":1564109089385},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1564109089229},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1564109089120},{"_id":"themes/next/source/404.html","hash":"9eb955271b03c72a4bb23a06b60e4ecb4070a880","modified":1564109089244},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1564109089135},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1564109089135},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1564109089135},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1564109089135},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1564109089135},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1564109089135},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1564109089135},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1564109089135},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1564109089135},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1564109089135},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1564109089135},{"_id":"source/images/QQ20190830143736.png","hash":"4aa2571877dd39e8e10681db4e7ac2927f73dd82","modified":1567147040381},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1564109089135},{"_id":"source/images/QQ20190830143418.png","hash":"0bd06d305c9d1f0a85c1c107253cc6a59b2e0261","modified":1567146855264},{"_id":"source/images/QQ20190830145048.png","hash":"c8eb8a28e062cef46e7e62bfc32736b8ea4eb7a7","modified":1567147845889},{"_id":"source/images/QQ20190830145325.png","hash":"17b96100adf06393118efca2e099197b2c68927c","modified":1567148003146},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1564109089582},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1564109089135},{"_id":"themes/next/languages/zh-Hans.yml","hash":"9317dae068981f4a169b67f70d46e1ffa6596825","modified":1564109089135},{"_id":"source/images/debugger_closure.png","hash":"217ef716c804b8f320fe98dfd12b0427420640a6","modified":1566443007095},{"_id":"source/images/u=3791572623,1286246317&fm=26&gp=0.jpg","hash":"70bbd95e0dd8705b115d5cc7f1860ecde22b14e3","modified":1567160088380},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089385},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1564109089135},{"_id":"source/images/QQ20190830144811.png","hash":"1249a8751158489fba49ea34ce1f525a6d0b1359","modified":1567147689368},{"_id":"source/images/QQ20190830145418.png","hash":"e71b9bc57b984b0f1613c4096a5ef4bcdcd43be6","modified":1567148055989},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1564109089229},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1564109089229},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1564109089244},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1564109089244},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1564109089244},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1564109089244},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1564109089244},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1564109089244},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1564109089244},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1564109089151},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1564109089151},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1564109089583},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1564109089584},{"_id":"source/images/QQ20190830145211.png","hash":"61066a35c2987ceb9331ef43c145dbb04a98ee3d","modified":1567147928068},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1564109089151},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1564109089151},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1564109089151},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1564109089151},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1564109089151},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1564109089151},{"_id":"themes/next/layout/_partials/footer.swig","hash":"93cd29728420a777ac5858f3cdb4339fa25cb9d9","modified":1564109089151},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1564109089166},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1564109089166},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1564109089166},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1564109089182},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1564109089182},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1564109089151},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1564109089166},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"3fd9e767b296e38f18e75f8a5394a3335dad0119","modified":1564109089151},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1564109089182},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1564109089213},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1564109089213},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1564109089213},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1564109089213},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1564109089213},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1564109089213},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1564109089213},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1564109089400},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1564109089385},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1564109089400},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1564109089400},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1564109089400},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1564109089400},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1564109089400},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1564109089400},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"a6609f7bec59ed1ab0c73f2ff7de1bd78aa7a167","modified":1564109089400},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564109089400},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"0a2cb46582e7678ce998015edb9db858d1fe9406","modified":1564109089400},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564109089416},{"_id":"themes/next/source/images/logo.svg","hash":"1471843910888d5351cf63e2b7962335487b9652","modified":1564109089416},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1564109089400},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1564109089416},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"3c665ea25ccafaf55f70f171a8c72f4812042733","modified":1564109089400},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1564109089416},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1564109089416},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1564109089400},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089182},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089182},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089338},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089338},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089354},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089385},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564109089385},{"_id":"themes/next/source/images/alipay.jpg","hash":"8ca57178829e486fc7f04885f203ed87f21a05fc","modified":1564109089400},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1564109089166},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1564109089166},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1564109089166},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1564109089166},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1564109089166},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1564109089166},{"_id":"themes/next/source/uploads/comment_avatar.png","hash":"84c9e6ff52defa4621ec5aacce4987053d230df4","modified":1564109089581},{"_id":"themes/next/source/uploads/avatar.jpg","hash":"46acbbdb7117a286ff2017d987515dc574987df3","modified":1564109089579},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1564109089182},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1564109089182},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1564109089182},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1564109089182},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1564109089166},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1564109089182},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1564109089166},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1564109089198},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1564109089166},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1564109089182},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1564109089182},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1564109089198},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1564109089213},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1564109089213},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1564109089198},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1564109089213},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1564109089213},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1564109089229},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1564109089198},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1564109089338},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1564109089354},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1564109089229},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1564109089213},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1564109089385},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1564109089385},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1564109089385},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1564109089338},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1564109089354},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1564109089416},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1564109089416},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1564109089416},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1564109089416},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1564109089416},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1564109089385},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1564109089432},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1564109089432},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1564109089416},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1564109089432},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1564109089432},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1564109089432},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1564109089478},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1564109089463},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1564109089447},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1564109089502},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1564109089496},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1564109089503},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1564109089494},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1564109089505},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1564109089506},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1564109089501},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1564109089495},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1564109089533},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1564109089529},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1564109089535},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1564109089538},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1564109089536},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1564109089540},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1564109089543},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1564109089544},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1564109089531},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1564109089542},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1564109089545},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1564109089546},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1564109089547},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1564109089463},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1564109089550},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1564109089549},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1564109089548},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1564109089554},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1564109089539},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1564109089555},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1564109089557},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1564109089552},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1564109089553},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1564109089525},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1564109089559},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1564109089551},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1564109089570},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1564109089530},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1564109089560},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1564109089576},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"58a7d5c629577c857188bb1201e40700545fa4cb","modified":1564109089416},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1564109089575},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1564109089571},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1564109089527},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1564109089578},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1564109089213},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1564109089213},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1564109089244},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1564109089244},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1564109089244},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1564109089276},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1564109089338},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1564109089338},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1564109089338},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1564109089338},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1564109089354},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1564109089338},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1564109089354},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1564109089338},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1564109089338},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1564109089354},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1564109089354},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1564109089354},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1564109089385},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1564109089385},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1564109089385},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1564109089354},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1564109089354},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1564109089385},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1564109089432},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1564109089354},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1564109089463},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1564109089463},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1564109089447},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1564109089447},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1564109089447},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1564109089463},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1564109089478},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1564109089463},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1564109089463},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1564109089478},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1564109089499},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1564109089509},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1564109089478},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1564109089498},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1564109089511},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1564109089478},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1564109089567},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1564109089510},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1564109089569},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1564109089447},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1564109089522},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1564109089574},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1564109089276},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1564109089291},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1564109089260},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1564109089307},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1564109089322},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1564109089338},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1564109089322},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1564109089369},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1564109089369},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1564109089432},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1564109089432},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1564109089524},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1564109089432},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1564109089447},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1564109089478},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1564109089478},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1564109089478},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1564109089478},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1564109089516},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1564109089514},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1564109089521},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1564109089478},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1564109089478},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1564109089432},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1564109089463},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1564109089564},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1564109089519},{"_id":"source/_posts/2019-11-20-Vue前端项目性能优化建议.md","hash":"637db320016fe2272b6e7c344bb811f2a2fc392f","modified":1574235372973}],"Category":[{"name":"设计模式","_id":"ck31ar48u0003acqxp323vlse"},{"name":"JavaScript","_id":"ck31ar49t000cacqxrmaadmwa"},{"name":"Vue","_id":"ck31ar4a5000vacqx06vmts97"},{"name":"CSS","_id":"ck31ar4a90015acqxcp8o526p"},{"name":"SVG","_id":"ck31ar4ac001cacqxre4t07v3"},{"name":"前端构建工具","_id":"ck31ar4ap001iacqx5k5j34tl"},{"name":"HTML","_id":"ck31ar4ax001wacqxsb06s43o"},{"name":"React","_id":"ck31ar4b00022acqxj9txptsu"},{"name":"数据结构","_id":"ck31ar4b10028acqxrcbktah4"},{"name":"单元测试","_id":"ck31ar4fh004facqxz0eczlko"},{"name":"算法","_id":"ck31ar4fn004nacqxvbb650oz"},{"name":"Web组件标准","_id":"ck31ar4fp004racqxoe68fryy"},{"name":"重构","_id":"ck31ar4fp004vacqxam4hv4pj"}],"Data":[],"Page":[{"title":"分类","date":"2018-07-10T06:32:34.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-07-10 14:32:34\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-07-29T06:45:27.794Z","path":"categories/index.html","layout":"page","_id":"ck31ar48p0000acqxhkksvjxj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2014-12-22 12:39:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-07-29T06:45:27.795Z","path":"tags/index.html","layout":"page","_id":"ck31ar48t0002acqxe5eznaux","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2018-07-11T07:27:44.000Z","comments":0,"tags":["about","关于"],"_content":"{% cq %}\n性别：男\n年龄：28\n目前就职于广州，从事Web前端开发\n{% endcq %}","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-07-11 15:27:44\ncomments: false\ntags:\n    - about\n    - 关于\n---\n{% cq %}\n性别：男\n年龄：28\n目前就职于广州，从事Web前端开发\n{% endcq %}","updated":"2019-07-29T06:45:27.792Z","path":"about/index.html","layout":"page","_id":"ck31ar49p0008acqx72r3c6mj","content":"<blockquote class=\"blockquote-center\"><p>性别：男<br>年龄：28<br>目前就职于广州，从事Web前端开发</p>\n</blockquote>","site":{"data":{}},"excerpt":"","more":"<blockquote class=\"blockquote-center\"><p>性别：男<br>年龄：28<br>目前就职于广州，从事Web前端开发</p>\n</blockquote>"}],"Post":[{"title":"设计模式之单例模式","date":"2018-03-03T16:00:00.000Z","toc":false,"comments":0,"_content":"\n单例模式是最简单也是最常用的模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n<!--more-->\n\n单例模式的特点：\n* 单例类只能有一个实例\n* 单例类必须自己创建自己的唯一实例\n* 单例类必须给所有其他对象提供这一实例\n\n主要解决：**一个全局使用的类频繁地创建与销毁**。\n\n怎么方便理解和记忆这种模式呢？\n\n用一句话来记忆它就是：**只有一个实例，有一个访问它的全局访问点，不能与new关键字一起使用**。\n\n在JavaScript中一个对象字面量可以认为是一个最简单的单例类，以为它符合单例类的特点：只有一个实例，有一个全局访问点。如：\n```js\nvar Singleton = {\n  attribute: true,\n  method: function () {\n    //do something\n  }\n};\n\nSingleton.name = false;\n```\n上面示例的单例对象可以被修改，你可以随意添加属性和方法到对象中，又或者用delete运算符删除现有的成员。这实质上是违背了面向对象设计的一个原则：**类可以被扩展，但不应该被修改**。传统意义上的单例模式的定义是：**单例类仅有一个实例，并提供一个访问它的全局访问点。上面的对象字面量不是一个实例化的类，所以严格来说，它不属于单例类**。javascript不是一门传统的语言，所以不必一定要按传统的定义来限定它，我们将单例模式的定义更广义化：**单例类是一组相关的属性和方法的集合，如果它能被实例化，那么它只能被实例化一次**。这样对象字面量就符合单例模式的定义了。\n\n## 拥有私有成员的单例类\n\n现在一个对象字面量就是JavaScript中最简单的单例类，那怎么实现单例类的**私有成员**呢？私有成员是对象内部独有的、其他对象无法访问的成员。在JavaScript中实现私有成员的方法是使用**闭包**，闭包是**高阶函数**的一种应用。闭包实现单例类如下：\n```js\nvar Singleton = (function(){\n  var name = 'singleton';\n         \n  return {\n    attribute: true,\n    getName: function () {\n      return name\n    }\n  }           \n})();\n            \nSingleton.getName();  //singleton\n```\n这样就实现了name成员的私有化，即在Singleton外无法直接访问和修改name，只能通过Singleton的getName方法访问name。\n\n## 使用构造函数实现单例类\n\n在JavaScript中没有类，但可以使用构造函数模拟类的行为，下面使用构造函数实现单例类：\n```js\nfunction Singleton (name) {\n  if (!Singleton.instance) {\n    this.name = name\n    Singleton.instance = this\n  }\n  return Singleton.instance\n}\n```\n或者，使用闭包把instance封装起来：\n```js\nvar Singleton = (function () {\n  var instance;\n  \n  var Singleton = function (name) {\n    if (!instance) {\n      this.name = name;\n      instance = this;\n    }\n    return instance;\n  }\n  return Singleton;\n})();\n```\n对该对象进行两次实例化，观察两次实例化结果是否指向同一个对象:\n```js\nvar a = new Singleton('a')\nvar b = new Singleton('b')\nconsole.log(a === b); // true\n```\n结果是：true。说明a、b之间是引用关系。\n\n在这段代码中，Singleton构造函数实际上负责了两件事情：第一是创建对象，第二是保证只有一个对象。很明显，这违背了“单一职责原则”，这是一种不好的做法。\n\n## 用代理实现单例模式\n\n通过引入代理，把创建对象和保证只有一个对象两个职责分离：\n```js\nvar Singleton = function (name) {\n  this.name = name\n}\n\n// 代理\nvar ProxySingleton = (function () {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Singleton(name);\n    }\n    return instance;\n  }\n})()\n```\n创建两个实例，测试单例类：\n```js\nvar a = new ProxySingleton('a')\nvar b = new ProxySingleton('b')\nconsole.log(a === b) // true\n```\n通过引入代理，实现了单例模式，并且职责清晰。但是现在还是有问题，引入代理后，多了一个全局变量（ProxySingleton），这样也不好。\n\n在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，这是高阶函数的另一种应用。通过向立即执行函数传参，消除多余的全局变量：\n```js\nvar Singleton = (function (Constructor) {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Constructor(name);\n    }\n    return instance;\n  }\n})(function Singleton (name) {\n  this.name = name\n})\n```\n\n## ES6实现单例模式\n\nES6中创建对象时引入了class和constructor用来创建对象。用ES6实现单例模式：\n```js\nclass Singleton {\n  constructor (name) {\n    if (!Singleton.instance) {\n      this.name = name\n      Singleton.instance = this\n    }\n    return Singleton.instance\n  }\n}\n```\n或者用代理：\n```js\nvar Singleton = (function (Constructor) {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Constructor(name);\n    }\n    return instance;\n  }\n})(class Singleton {\n  constructor(name) {\n    this.name = name\n  }\n})\n```\nES6的class只不过是一个语法糖，与ES5的构造函数实现单例类没什么区别。\n\n## 惰性单例\n\n惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实\n际开发中非常有用。\n\n接下来我们使用惰性单例实现弹框，在用户点击登录按钮的时候才创建登录框：\n```js\nvar createDiv = function() {\n  var div;\n\n  return function() {\n    if(!div){\n      div = document.createElement(\"div\");\n      div.innerHTML = '我是登录框';\n      document.body.appendChild(div);\n    }\n    return div;\n  }\n};\n            \ndocument.querySelector(\".btn\").onclick = createDiv();\n```\n把上面创建div的过程提取出来，便得到一个通用的惰性单例模式：\n```js\nvar createSingleton = function(fn) {\n  var singleton;\n\n  return function() {\n    return singleton || (singleton = fn.apply(this, arguments));\n  }\n};\n```\n现在用通用的惰性单例改造下前面登录框的代码：\n```js\nvar createSingleton = function(fn){\n  var singleton;\n  \n  return function(){\n    return singleton || (singleton = fn.apply(this, arguments));\n  }\n};\n            \nfunction createDiv(){\n  var div = document.createElement(\"div\");\n  \n  div.innerHTML = '我是登录框';\n  document.body.appendChild(div);\n  return div;\n};\n            \nvar createDivSingleton = createSingleton(createDiv);\n            \ndocument.querySelector(\".btn\").onclick = function(){\n  var div = createDivSingleton();\n};\n```\n\n## 总结\n\n在JavaScript实现单例模式的过程中，实际上也用了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。","source":"_posts/2018-03-04-设计模式之单例模式.md","raw":"---\ntitle: 设计模式之单例模式\ndate: 2018-03-04\ntoc: false\ncomments: false\ntags:\n    - JavaScript设计模式\ncategories:\n    - 设计模式\n---\n\n单例模式是最简单也是最常用的模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n<!--more-->\n\n单例模式的特点：\n* 单例类只能有一个实例\n* 单例类必须自己创建自己的唯一实例\n* 单例类必须给所有其他对象提供这一实例\n\n主要解决：**一个全局使用的类频繁地创建与销毁**。\n\n怎么方便理解和记忆这种模式呢？\n\n用一句话来记忆它就是：**只有一个实例，有一个访问它的全局访问点，不能与new关键字一起使用**。\n\n在JavaScript中一个对象字面量可以认为是一个最简单的单例类，以为它符合单例类的特点：只有一个实例，有一个全局访问点。如：\n```js\nvar Singleton = {\n  attribute: true,\n  method: function () {\n    //do something\n  }\n};\n\nSingleton.name = false;\n```\n上面示例的单例对象可以被修改，你可以随意添加属性和方法到对象中，又或者用delete运算符删除现有的成员。这实质上是违背了面向对象设计的一个原则：**类可以被扩展，但不应该被修改**。传统意义上的单例模式的定义是：**单例类仅有一个实例，并提供一个访问它的全局访问点。上面的对象字面量不是一个实例化的类，所以严格来说，它不属于单例类**。javascript不是一门传统的语言，所以不必一定要按传统的定义来限定它，我们将单例模式的定义更广义化：**单例类是一组相关的属性和方法的集合，如果它能被实例化，那么它只能被实例化一次**。这样对象字面量就符合单例模式的定义了。\n\n## 拥有私有成员的单例类\n\n现在一个对象字面量就是JavaScript中最简单的单例类，那怎么实现单例类的**私有成员**呢？私有成员是对象内部独有的、其他对象无法访问的成员。在JavaScript中实现私有成员的方法是使用**闭包**，闭包是**高阶函数**的一种应用。闭包实现单例类如下：\n```js\nvar Singleton = (function(){\n  var name = 'singleton';\n         \n  return {\n    attribute: true,\n    getName: function () {\n      return name\n    }\n  }           \n})();\n            \nSingleton.getName();  //singleton\n```\n这样就实现了name成员的私有化，即在Singleton外无法直接访问和修改name，只能通过Singleton的getName方法访问name。\n\n## 使用构造函数实现单例类\n\n在JavaScript中没有类，但可以使用构造函数模拟类的行为，下面使用构造函数实现单例类：\n```js\nfunction Singleton (name) {\n  if (!Singleton.instance) {\n    this.name = name\n    Singleton.instance = this\n  }\n  return Singleton.instance\n}\n```\n或者，使用闭包把instance封装起来：\n```js\nvar Singleton = (function () {\n  var instance;\n  \n  var Singleton = function (name) {\n    if (!instance) {\n      this.name = name;\n      instance = this;\n    }\n    return instance;\n  }\n  return Singleton;\n})();\n```\n对该对象进行两次实例化，观察两次实例化结果是否指向同一个对象:\n```js\nvar a = new Singleton('a')\nvar b = new Singleton('b')\nconsole.log(a === b); // true\n```\n结果是：true。说明a、b之间是引用关系。\n\n在这段代码中，Singleton构造函数实际上负责了两件事情：第一是创建对象，第二是保证只有一个对象。很明显，这违背了“单一职责原则”，这是一种不好的做法。\n\n## 用代理实现单例模式\n\n通过引入代理，把创建对象和保证只有一个对象两个职责分离：\n```js\nvar Singleton = function (name) {\n  this.name = name\n}\n\n// 代理\nvar ProxySingleton = (function () {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Singleton(name);\n    }\n    return instance;\n  }\n})()\n```\n创建两个实例，测试单例类：\n```js\nvar a = new ProxySingleton('a')\nvar b = new ProxySingleton('b')\nconsole.log(a === b) // true\n```\n通过引入代理，实现了单例模式，并且职责清晰。但是现在还是有问题，引入代理后，多了一个全局变量（ProxySingleton），这样也不好。\n\n在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，这是高阶函数的另一种应用。通过向立即执行函数传参，消除多余的全局变量：\n```js\nvar Singleton = (function (Constructor) {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Constructor(name);\n    }\n    return instance;\n  }\n})(function Singleton (name) {\n  this.name = name\n})\n```\n\n## ES6实现单例模式\n\nES6中创建对象时引入了class和constructor用来创建对象。用ES6实现单例模式：\n```js\nclass Singleton {\n  constructor (name) {\n    if (!Singleton.instance) {\n      this.name = name\n      Singleton.instance = this\n    }\n    return Singleton.instance\n  }\n}\n```\n或者用代理：\n```js\nvar Singleton = (function (Constructor) {\n  var instance;\n  \n  return function (name) {\n    if (!instance) {\n      instance = new Constructor(name);\n    }\n    return instance;\n  }\n})(class Singleton {\n  constructor(name) {\n    this.name = name\n  }\n})\n```\nES6的class只不过是一个语法糖，与ES5的构造函数实现单例类没什么区别。\n\n## 惰性单例\n\n惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实\n际开发中非常有用。\n\n接下来我们使用惰性单例实现弹框，在用户点击登录按钮的时候才创建登录框：\n```js\nvar createDiv = function() {\n  var div;\n\n  return function() {\n    if(!div){\n      div = document.createElement(\"div\");\n      div.innerHTML = '我是登录框';\n      document.body.appendChild(div);\n    }\n    return div;\n  }\n};\n            \ndocument.querySelector(\".btn\").onclick = createDiv();\n```\n把上面创建div的过程提取出来，便得到一个通用的惰性单例模式：\n```js\nvar createSingleton = function(fn) {\n  var singleton;\n\n  return function() {\n    return singleton || (singleton = fn.apply(this, arguments));\n  }\n};\n```\n现在用通用的惰性单例改造下前面登录框的代码：\n```js\nvar createSingleton = function(fn){\n  var singleton;\n  \n  return function(){\n    return singleton || (singleton = fn.apply(this, arguments));\n  }\n};\n            \nfunction createDiv(){\n  var div = document.createElement(\"div\");\n  \n  div.innerHTML = '我是登录框';\n  document.body.appendChild(div);\n  return div;\n};\n            \nvar createDivSingleton = createSingleton(createDiv);\n            \ndocument.querySelector(\".btn\").onclick = function(){\n  var div = createDivSingleton();\n};\n```\n\n## 总结\n\n在JavaScript实现单例模式的过程中，实际上也用了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。","slug":"2018-03-04-设计模式之单例模式","published":1,"updated":"2019-07-29T06:45:27.781Z","layout":"post","photos":[],"link":"","_id":"ck31ar48q0001acqxwixdma7z","content":"<p>单例模式是最简单也是最常用的模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<a id=\"more\"></a>\n<p>单例模式的特点：</p>\n<ul>\n<li>单例类只能有一个实例</li>\n<li>单例类必须自己创建自己的唯一实例</li>\n<li>单例类必须给所有其他对象提供这一实例</li>\n</ul>\n<p>主要解决：<strong>一个全局使用的类频繁地创建与销毁</strong>。</p>\n<p>怎么方便理解和记忆这种模式呢？</p>\n<p>用一句话来记忆它就是：<strong>只有一个实例，有一个访问它的全局访问点，不能与new关键字一起使用</strong>。</p>\n<p>在JavaScript中一个对象字面量可以认为是一个最简单的单例类，以为它符合单例类的特点：只有一个实例，有一个全局访问点。如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = &#123;</span><br><span class=\"line\">  attribute: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.name = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面示例的单例对象可以被修改，你可以随意添加属性和方法到对象中，又或者用delete运算符删除现有的成员。这实质上是违背了面向对象设计的一个原则：<strong>类可以被扩展，但不应该被修改</strong>。传统意义上的单例模式的定义是：<strong>单例类仅有一个实例，并提供一个访问它的全局访问点。上面的对象字面量不是一个实例化的类，所以严格来说，它不属于单例类</strong>。javascript不是一门传统的语言，所以不必一定要按传统的定义来限定它，我们将单例模式的定义更广义化：<strong>单例类是一组相关的属性和方法的集合，如果它能被实例化，那么它只能被实例化一次</strong>。这样对象字面量就符合单例模式的定义了。</p>\n<h2 id=\"拥有私有成员的单例类\"><a href=\"#拥有私有成员的单例类\" class=\"headerlink\" title=\"拥有私有成员的单例类\"></a>拥有私有成员的单例类</h2><p>现在一个对象字面量就是JavaScript中最简单的单例类，那怎么实现单例类的<strong>私有成员</strong>呢？私有成员是对象内部独有的、其他对象无法访问的成员。在JavaScript中实现私有成员的方法是使用<strong>闭包</strong>，闭包是<strong>高阶函数</strong>的一种应用。闭包实现单例类如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'singleton'</span>;</span><br><span class=\"line\">         </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    attribute: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;           </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">            </span><br><span class=\"line\">Singleton.getName();  <span class=\"comment\">//singleton</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了name成员的私有化，即在Singleton外无法直接访问和修改name，只能通过Singleton的getName方法访问name。</p>\n<h2 id=\"使用构造函数实现单例类\"><a href=\"#使用构造函数实现单例类\" class=\"headerlink\" title=\"使用构造函数实现单例类\"></a>使用构造函数实现单例类</h2><p>在JavaScript中没有类，但可以使用构造函数模拟类的行为，下面使用构造函数实现单例类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Singleton</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Singleton.instance) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    Singleton.instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Singleton.instance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，使用闭包把instance封装起来：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Singleton;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>对该对象进行两次实例化，观察两次实例化结果是否指向同一个对象:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Singleton(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Singleton(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>结果是：true。说明a、b之间是引用关系。</p>\n<p>在这段代码中，Singleton构造函数实际上负责了两件事情：第一是创建对象，第二是保证只有一个对象。很明显，这违背了“单一职责原则”，这是一种不好的做法。</p>\n<h2 id=\"用代理实现单例模式\"><a href=\"#用代理实现单例模式\" class=\"headerlink\" title=\"用代理实现单例模式\"></a>用代理实现单例模式</h2><p>通过引入代理，把创建对象和保证只有一个对象两个职责分离：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ProxySingleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>创建两个实例，测试单例类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> ProxySingleton(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> ProxySingleton(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>通过引入代理，实现了单例模式，并且职责清晰。但是现在还是有问题，引入代理后，多了一个全局变量（ProxySingleton），这样也不好。</p>\n<p>在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，这是高阶函数的另一种应用。通过向立即执行函数传参，消除多余的全局变量：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Constructor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Constructor(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Singleton</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ES6实现单例模式\"><a href=\"#ES6实现单例模式\" class=\"headerlink\" title=\"ES6实现单例模式\"></a>ES6实现单例模式</h2><p>ES6中创建对象时引入了class和constructor用来创建对象。用ES6实现单例模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Singleton.instance) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">      Singleton.instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Singleton.instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者用代理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Constructor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Constructor(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>ES6的class只不过是一个语法糖，与ES5的构造函数实现单例类没什么区别。</p>\n<h2 id=\"惰性单例\"><a href=\"#惰性单例\" class=\"headerlink\" title=\"惰性单例\"></a>惰性单例</h2><p>惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实<br>际开发中非常有用。</p>\n<p>接下来我们使用惰性单例实现弹框，在用户点击登录按钮的时候才创建登录框：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createDiv = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!div)&#123;</span><br><span class=\"line\">      div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">      div.innerHTML = <span class=\"string\">'我是登录框'</span>;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".btn\"</span>).onclick = createDiv();</span><br></pre></td></tr></table></figure></p>\n<p>把上面创建div的过程提取出来，便得到一个通用的惰性单例模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createSingleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton || (singleton = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在用通用的惰性单例改造下前面登录框的代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createSingleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> singleton;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton || (singleton = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDiv</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  div.innerHTML = <span class=\"string\">'我是登录框'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> createDivSingleton = createSingleton(createDiv);</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".btn\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = createDivSingleton();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在JavaScript实现单例模式的过程中，实际上也用了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>\n","site":{"data":{}},"excerpt":"<p>单例模式是最简单也是最常用的模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>","more":"<p>单例模式的特点：</p>\n<ul>\n<li>单例类只能有一个实例</li>\n<li>单例类必须自己创建自己的唯一实例</li>\n<li>单例类必须给所有其他对象提供这一实例</li>\n</ul>\n<p>主要解决：<strong>一个全局使用的类频繁地创建与销毁</strong>。</p>\n<p>怎么方便理解和记忆这种模式呢？</p>\n<p>用一句话来记忆它就是：<strong>只有一个实例，有一个访问它的全局访问点，不能与new关键字一起使用</strong>。</p>\n<p>在JavaScript中一个对象字面量可以认为是一个最简单的单例类，以为它符合单例类的特点：只有一个实例，有一个全局访问点。如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = &#123;</span><br><span class=\"line\">  attribute: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Singleton.name = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面示例的单例对象可以被修改，你可以随意添加属性和方法到对象中，又或者用delete运算符删除现有的成员。这实质上是违背了面向对象设计的一个原则：<strong>类可以被扩展，但不应该被修改</strong>。传统意义上的单例模式的定义是：<strong>单例类仅有一个实例，并提供一个访问它的全局访问点。上面的对象字面量不是一个实例化的类，所以严格来说，它不属于单例类</strong>。javascript不是一门传统的语言，所以不必一定要按传统的定义来限定它，我们将单例模式的定义更广义化：<strong>单例类是一组相关的属性和方法的集合，如果它能被实例化，那么它只能被实例化一次</strong>。这样对象字面量就符合单例模式的定义了。</p>\n<h2 id=\"拥有私有成员的单例类\"><a href=\"#拥有私有成员的单例类\" class=\"headerlink\" title=\"拥有私有成员的单例类\"></a>拥有私有成员的单例类</h2><p>现在一个对象字面量就是JavaScript中最简单的单例类，那怎么实现单例类的<strong>私有成员</strong>呢？私有成员是对象内部独有的、其他对象无法访问的成员。在JavaScript中实现私有成员的方法是使用<strong>闭包</strong>，闭包是<strong>高阶函数</strong>的一种应用。闭包实现单例类如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'singleton'</span>;</span><br><span class=\"line\">         </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    attribute: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;           </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">            </span><br><span class=\"line\">Singleton.getName();  <span class=\"comment\">//singleton</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了name成员的私有化，即在Singleton外无法直接访问和修改name，只能通过Singleton的getName方法访问name。</p>\n<h2 id=\"使用构造函数实现单例类\"><a href=\"#使用构造函数实现单例类\" class=\"headerlink\" title=\"使用构造函数实现单例类\"></a>使用构造函数实现单例类</h2><p>在JavaScript中没有类，但可以使用构造函数模拟类的行为，下面使用构造函数实现单例类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Singleton</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Singleton.instance) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    Singleton.instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Singleton.instance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，使用闭包把instance封装起来：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Singleton;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>对该对象进行两次实例化，观察两次实例化结果是否指向同一个对象:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Singleton(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Singleton(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>结果是：true。说明a、b之间是引用关系。</p>\n<p>在这段代码中，Singleton构造函数实际上负责了两件事情：第一是创建对象，第二是保证只有一个对象。很明显，这违背了“单一职责原则”，这是一种不好的做法。</p>\n<h2 id=\"用代理实现单例模式\"><a href=\"#用代理实现单例模式\" class=\"headerlink\" title=\"用代理实现单例模式\"></a>用代理实现单例模式</h2><p>通过引入代理，把创建对象和保证只有一个对象两个职责分离：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ProxySingleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>创建两个实例，测试单例类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> ProxySingleton(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> ProxySingleton(<span class=\"string\">'b'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>通过引入代理，实现了单例模式，并且职责清晰。但是现在还是有问题，引入代理后，多了一个全局变量（ProxySingleton），这样也不好。</p>\n<p>在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，这是高阶函数的另一种应用。通过向立即执行函数传参，消除多余的全局变量：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Constructor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Constructor(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Singleton</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ES6实现单例模式\"><a href=\"#ES6实现单例模式\" class=\"headerlink\" title=\"ES6实现单例模式\"></a>ES6实现单例模式</h2><p>ES6中创建对象时引入了class和constructor用来创建对象。用ES6实现单例模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Singleton.instance) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">      Singleton.instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Singleton.instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者用代理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Singleton = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Constructor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Constructor(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>ES6的class只不过是一个语法糖，与ES5的构造函数实现单例类没什么区别。</p>\n<h2 id=\"惰性单例\"><a href=\"#惰性单例\" class=\"headerlink\" title=\"惰性单例\"></a>惰性单例</h2><p>惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实<br>际开发中非常有用。</p>\n<p>接下来我们使用惰性单例实现弹框，在用户点击登录按钮的时候才创建登录框：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createDiv = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!div)&#123;</span><br><span class=\"line\">      div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">      div.innerHTML = <span class=\"string\">'我是登录框'</span>;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".btn\"</span>).onclick = createDiv();</span><br></pre></td></tr></table></figure></p>\n<p>把上面创建div的过程提取出来，便得到一个通用的惰性单例模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createSingleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton || (singleton = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在用通用的惰性单例改造下前面登录框的代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createSingleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> singleton;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton || (singleton = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDiv</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  div.innerHTML = <span class=\"string\">'我是登录框'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> createDivSingleton = createSingleton(createDiv);</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".btn\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = createDivSingleton();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在JavaScript实现单例模式的过程中，实际上也用了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>"},{"title":"设计模式之代理模式","date":"2018-03-05T16:00:00.000Z","toc":false,"comments":0,"_content":"\n现代商业界很流行一种叫代理商的人物，在商业界中代理商又称商务代理，是在其行业管理范围内接受他人委托，为他人促成或缔结交易的一般代理人。很多公司为了迅速占领市场，通常会选用一种叫代理商加盟的商业模式。比如快递公司，很多快递公司都会有代理商网点，发送快递时，会先把快递发到网点，然后网点就会发送到收件人手中。在程序语言中，我们把像这种**一个类代表另一个类的功能的设计模式**叫做**代理模式**。\n\n<!--more-->\n\n代理模式的定义：**为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用**。\n\n主要解决问题：**在直接访问对象时带来的问题，比如说：比如对象创建开销很大、或者某些操作需要安全控制，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层（即中间层）**。\n\n## 代理模式的实现\n\n我们先用一个快递公司通过代理网点发送快递的情形，抽象出来的程序例子，来理解代理模式：\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    company += this.name\n    target.receive(company);\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar xiaoming = new Person('小明');                 // 创建快递接收人小明\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建xxx代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 快递公司设置代理网点\ncompany.send(xiaoming);  // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n这段代码中，ExpressCompany类没有直接发送快递给Person类，而是引入了第三者ProxyBranch代理类，代替ExpressCompany类转发快递给Person类，这就是代理模式。\n\n## 虚拟代理\n\n在上面代码片段中，小明是从一开始就被创建的一个接受者，这就好比代理网点一直都在惦记着要不要给小明发送快递，这是完全没有必要的，网点只需在从快递公司接收到小明的快递时再想起小明就可以了。也就是说，在一开始就把小明这个接受者创建出来是非常的不必要的，因为这样太浪费系统资源了，我们应该换一种方式，在ProxyBranch类执行send()方法时再创建小明这个Person对象的实例。像这样的代理方式叫**虚拟代理**，虚拟代理**把一些开销很大的对象，延迟到真正需要它的时候才去创建**。\n\n看下面的程序实例，理解什么是虚拟代理：\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    var xiaoming = new Person(target);  // 创建快递接收人小明\n    \n    company += this.name\n    xiaoming.receive(company);\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 设置代理网点\ncompany.send('小明');    // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n现在把创建接收者延迟到了代理类ProxyBranch的send方法中，实现了虚拟代理。\n\n## 保护代理\n\n通过上面的代码实例，我们了解到了什么是代理模式，但上面的代理模式可以说是没有任何意义的，而且还无端增加了程序的复杂性。现实中小明有可能无时无刻都在家吗？这是不可能的。那么代理网点的工作人员是不是要等到小明在家的时候才能把快递送到小明的手里？这是肯定的。这样的话，是不是相当于小明被设置了访问权限，只有他在家的时候才能访问。这就是**保护代理**——**控制其他程序对被代理对象的访问**。\n\n现在，假设小明空闲在家的时间段为: 7:00 - 9:00, 18:00 - 23:00，保护代理的实现如下:\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    var freeTime, h;\n    \n    h = new Date().getHours();\n    \n    // 小明空闲在家的时间段: 7:00 - 9:00, 18:00 - 23:00\n    freeTime = [\n      [7, 9],\n      [18, 23]\n    ];\n\n    for(var i = 0, l = freeTime.length; i < l; i++){\n      if(freeTime[i][0] < h && h < freeTime[i][1]){\n        var xiaoming = new Person(target, freeTime)  // 创建快递接收人小明\n        \n        company += this.name\n        xiaoming.receive(company);\n        break;\n      }\n    }\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name, freeTime) {\n    this.name = name;\n    this.freeTime = freeTime;\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 设置代理网点\ncompany.send('小明');    // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n\n## 总结\n\n代理模式中代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。保护代理可以控制其他程序对被代理对象的访问。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建，能有效节约系统资源。","source":"_posts/2018-03-06-设计模式之代理模式.md","raw":"---\ntitle: 设计模式之代理模式\ndate: 2018-03-06\ntoc: false\ncomments: false\ntags:\n    - JavaScript设计模式\ncategories:\n    - 设计模式\n---\n\n现代商业界很流行一种叫代理商的人物，在商业界中代理商又称商务代理，是在其行业管理范围内接受他人委托，为他人促成或缔结交易的一般代理人。很多公司为了迅速占领市场，通常会选用一种叫代理商加盟的商业模式。比如快递公司，很多快递公司都会有代理商网点，发送快递时，会先把快递发到网点，然后网点就会发送到收件人手中。在程序语言中，我们把像这种**一个类代表另一个类的功能的设计模式**叫做**代理模式**。\n\n<!--more-->\n\n代理模式的定义：**为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用**。\n\n主要解决问题：**在直接访问对象时带来的问题，比如说：比如对象创建开销很大、或者某些操作需要安全控制，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层（即中间层）**。\n\n## 代理模式的实现\n\n我们先用一个快递公司通过代理网点发送快递的情形，抽象出来的程序例子，来理解代理模式：\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    company += this.name\n    target.receive(company);\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar xiaoming = new Person('小明');                 // 创建快递接收人小明\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建xxx代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 快递公司设置代理网点\ncompany.send(xiaoming);  // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n这段代码中，ExpressCompany类没有直接发送快递给Person类，而是引入了第三者ProxyBranch代理类，代替ExpressCompany类转发快递给Person类，这就是代理模式。\n\n## 虚拟代理\n\n在上面代码片段中，小明是从一开始就被创建的一个接受者，这就好比代理网点一直都在惦记着要不要给小明发送快递，这是完全没有必要的，网点只需在从快递公司接收到小明的快递时再想起小明就可以了。也就是说，在一开始就把小明这个接受者创建出来是非常的不必要的，因为这样太浪费系统资源了，我们应该换一种方式，在ProxyBranch类执行send()方法时再创建小明这个Person对象的实例。像这样的代理方式叫**虚拟代理**，虚拟代理**把一些开销很大的对象，延迟到真正需要它的时候才去创建**。\n\n看下面的程序实例，理解什么是虚拟代理：\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    var xiaoming = new Person(target);  // 创建快递接收人小明\n    \n    company += this.name\n    xiaoming.receive(company);\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 设置代理网点\ncompany.send('小明');    // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n现在把创建接收者延迟到了代理类ProxyBranch的send方法中，实现了虚拟代理。\n\n## 保护代理\n\n通过上面的代码实例，我们了解到了什么是代理模式，但上面的代理模式可以说是没有任何意义的，而且还无端增加了程序的复杂性。现实中小明有可能无时无刻都在家吗？这是不可能的。那么代理网点的工作人员是不是要等到小明在家的时候才能把快递送到小明的手里？这是肯定的。这样的话，是不是相当于小明被设置了访问权限，只有他在家的时候才能访问。这就是**保护代理**——**控制其他程序对被代理对象的访问**。\n\n现在，假设小明空闲在家的时间段为: 7:00 - 9:00, 18:00 - 23:00，保护代理的实现如下:\n```js\n// 快递公司类\nclass ExpressCompany {\n  constructor (name) {\n    this.name = name; // 公司名称\n    this.proxy = null; // 代理\n  }\n  \n  // 设置网点\n  setProxy (proxy) {\n    this.proxy = proxy;\n  }\n  \n  // 发送\n  send (target) {\n    this.proxy.send(target, this.name);\n  }\n}\n\n// 快递公司代理网点类\nclass ProxyBranch {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 发送\n  send (target, company) {\n    var freeTime, h;\n    \n    h = new Date().getHours();\n    \n    // 小明空闲在家的时间段: 7:00 - 9:00, 18:00 - 23:00\n    freeTime = [\n      [7, 9],\n      [18, 23]\n    ];\n\n    for(var i = 0, l = freeTime.length; i < l; i++){\n      if(freeTime[i][0] < h && h < freeTime[i][1]){\n        var xiaoming = new Person(target, freeTime)  // 创建快递接收人小明\n        \n        company += this.name\n        xiaoming.receive(company);\n        break;\n      }\n    }\n  }\n}\n\n// 快递接受者类\nclass Person {\n  constructor(name, freeTime) {\n    this.name = name;\n    this.freeTime = freeTime;\n  }\n  \n  // 接收\n  receive (company) {\n    console.log(this.name + \"接收到了\" + company + \"发来的快递。\");\n  }\n}\n\nvar proxy = new ProxyBranch('xxx代理网点');        // 创建代理网点\nvar company = new ExpressCompany('xxx快递公司');   // 创建xxx快递公司\n\ncompany.setProxy(proxy); // 设置代理网点\ncompany.send('小明');    // 快递公司发送快递给小明\n// => 小明接收到了xxx快递公司xxx代理网点发来的快递。\n```\n\n## 总结\n\n代理模式中代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。保护代理可以控制其他程序对被代理对象的访问。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建，能有效节约系统资源。","slug":"2018-03-06-设计模式之代理模式","published":1,"updated":"2019-07-29T06:45:27.785Z","layout":"post","photos":[],"link":"","_id":"ck31ar49o0007acqxywmhlhzf","content":"<p>现代商业界很流行一种叫代理商的人物，在商业界中代理商又称商务代理，是在其行业管理范围内接受他人委托，为他人促成或缔结交易的一般代理人。很多公司为了迅速占领市场，通常会选用一种叫代理商加盟的商业模式。比如快递公司，很多快递公司都会有代理商网点，发送快递时，会先把快递发到网点，然后网点就会发送到收件人手中。在程序语言中，我们把像这种<strong>一个类代表另一个类的功能的设计模式</strong>叫做<strong>代理模式</strong>。</p>\n<a id=\"more\"></a>\n<p>代理模式的定义：<strong>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</strong>。</p>\n<p>主要解决问题：<strong>在直接访问对象时带来的问题，比如说：比如对象创建开销很大、或者某些操作需要安全控制，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层（即中间层）</strong>。</p>\n<h2 id=\"代理模式的实现\"><a href=\"#代理模式的实现\" class=\"headerlink\" title=\"代理模式的实现\"></a>代理模式的实现</h2><p>我们先用一个快递公司通过代理网点发送快递的情形，抽象出来的程序例子，来理解代理模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    target.receive(company);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小明'</span>);                 <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建xxx代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 快递公司设置代理网点</span></span><br><span class=\"line\">company.send(xiaoming);  <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码中，ExpressCompany类没有直接发送快递给Person类，而是引入了第三者ProxyBranch代理类，代替ExpressCompany类转发快递给Person类，这就是代理模式。</p>\n<h2 id=\"虚拟代理\"><a href=\"#虚拟代理\" class=\"headerlink\" title=\"虚拟代理\"></a>虚拟代理</h2><p>在上面代码片段中，小明是从一开始就被创建的一个接受者，这就好比代理网点一直都在惦记着要不要给小明发送快递，这是完全没有必要的，网点只需在从快递公司接收到小明的快递时再想起小明就可以了。也就是说，在一开始就把小明这个接受者创建出来是非常的不必要的，因为这样太浪费系统资源了，我们应该换一种方式，在ProxyBranch类执行send()方法时再创建小明这个Person对象的实例。像这样的代理方式叫<strong>虚拟代理</strong>，虚拟代理<strong>把一些开销很大的对象，延迟到真正需要它的时候才去创建</strong>。</p>\n<p>看下面的程序实例，理解什么是虚拟代理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(target);  <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    xiaoming.receive(company);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 设置代理网点</span></span><br><span class=\"line\">company.send(<span class=\"string\">'小明'</span>);    <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<p>现在把创建接收者延迟到了代理类ProxyBranch的send方法中，实现了虚拟代理。</p>\n<h2 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h2><p>通过上面的代码实例，我们了解到了什么是代理模式，但上面的代理模式可以说是没有任何意义的，而且还无端增加了程序的复杂性。现实中小明有可能无时无刻都在家吗？这是不可能的。那么代理网点的工作人员是不是要等到小明在家的时候才能把快递送到小明的手里？这是肯定的。这样的话，是不是相当于小明被设置了访问权限，只有他在家的时候才能访问。这就是<strong>保护代理</strong>——<strong>控制其他程序对被代理对象的访问</strong>。</p>\n<p>现在，假设小明空闲在家的时间段为: 7:00 - 9:00, 18:00 - 23:00，保护代理的实现如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> freeTime, h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    h = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getHours();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 小明空闲在家的时间段: 7:00 - 9:00, 18:00 - 23:00</span></span><br><span class=\"line\">    freeTime = [</span><br><span class=\"line\">      [<span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">      [<span class=\"number\">18</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = freeTime.length; i &lt; l; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(freeTime[i][<span class=\"number\">0</span>] &lt; h &amp;&amp; h &lt; freeTime[i][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(target, freeTime)  <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">        xiaoming.receive(company);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, freeTime) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.freeTime = freeTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 设置代理网点</span></span><br><span class=\"line\">company.send(<span class=\"string\">'小明'</span>);    <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>代理模式中代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。保护代理可以控制其他程序对被代理对象的访问。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建，能有效节约系统资源。</p>\n","site":{"data":{}},"excerpt":"<p>现代商业界很流行一种叫代理商的人物，在商业界中代理商又称商务代理，是在其行业管理范围内接受他人委托，为他人促成或缔结交易的一般代理人。很多公司为了迅速占领市场，通常会选用一种叫代理商加盟的商业模式。比如快递公司，很多快递公司都会有代理商网点，发送快递时，会先把快递发到网点，然后网点就会发送到收件人手中。在程序语言中，我们把像这种<strong>一个类代表另一个类的功能的设计模式</strong>叫做<strong>代理模式</strong>。</p>","more":"<p>代理模式的定义：<strong>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</strong>。</p>\n<p>主要解决问题：<strong>在直接访问对象时带来的问题，比如说：比如对象创建开销很大、或者某些操作需要安全控制，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层（即中间层）</strong>。</p>\n<h2 id=\"代理模式的实现\"><a href=\"#代理模式的实现\" class=\"headerlink\" title=\"代理模式的实现\"></a>代理模式的实现</h2><p>我们先用一个快递公司通过代理网点发送快递的情形，抽象出来的程序例子，来理解代理模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    target.receive(company);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小明'</span>);                 <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建xxx代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 快递公司设置代理网点</span></span><br><span class=\"line\">company.send(xiaoming);  <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码中，ExpressCompany类没有直接发送快递给Person类，而是引入了第三者ProxyBranch代理类，代替ExpressCompany类转发快递给Person类，这就是代理模式。</p>\n<h2 id=\"虚拟代理\"><a href=\"#虚拟代理\" class=\"headerlink\" title=\"虚拟代理\"></a>虚拟代理</h2><p>在上面代码片段中，小明是从一开始就被创建的一个接受者，这就好比代理网点一直都在惦记着要不要给小明发送快递，这是完全没有必要的，网点只需在从快递公司接收到小明的快递时再想起小明就可以了。也就是说，在一开始就把小明这个接受者创建出来是非常的不必要的，因为这样太浪费系统资源了，我们应该换一种方式，在ProxyBranch类执行send()方法时再创建小明这个Person对象的实例。像这样的代理方式叫<strong>虚拟代理</strong>，虚拟代理<strong>把一些开销很大的对象，延迟到真正需要它的时候才去创建</strong>。</p>\n<p>看下面的程序实例，理解什么是虚拟代理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(target);  <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    xiaoming.receive(company);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 设置代理网点</span></span><br><span class=\"line\">company.send(<span class=\"string\">'小明'</span>);    <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<p>现在把创建接收者延迟到了代理类ProxyBranch的send方法中，实现了虚拟代理。</p>\n<h2 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h2><p>通过上面的代码实例，我们了解到了什么是代理模式，但上面的代理模式可以说是没有任何意义的，而且还无端增加了程序的复杂性。现实中小明有可能无时无刻都在家吗？这是不可能的。那么代理网点的工作人员是不是要等到小明在家的时候才能把快递送到小明的手里？这是肯定的。这样的话，是不是相当于小明被设置了访问权限，只有他在家的时候才能访问。这就是<strong>保护代理</strong>——<strong>控制其他程序对被代理对象的访问</strong>。</p>\n<p>现在，假设小明空闲在家的时间段为: 7:00 - 9:00, 18:00 - 23:00，保护代理的实现如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快递公司类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressCompany</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 公司名称</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = <span class=\"literal\">null</span>; <span class=\"comment\">// 代理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 设置网点</span></span><br><span class=\"line\">  setProxy (proxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.proxy.send(target, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递公司代理网点类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyBranch</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发送</span></span><br><span class=\"line\">  send (target, company) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> freeTime, h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    h = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getHours();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 小明空闲在家的时间段: 7:00 - 9:00, 18:00 - 23:00</span></span><br><span class=\"line\">    freeTime = [</span><br><span class=\"line\">      [<span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">      [<span class=\"number\">18</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = freeTime.length; i &lt; l; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(freeTime[i][<span class=\"number\">0</span>] &lt; h &amp;&amp; h &lt; freeTime[i][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Person(target, freeTime)  <span class=\"comment\">// 创建快递接收人小明</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        company += <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">        xiaoming.receive(company);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快递接受者类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, freeTime) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.freeTime = freeTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 接收</span></span><br><span class=\"line\">  receive (company) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"接收到了\"</span> + company + <span class=\"string\">\"发来的快递。\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> ProxyBranch(<span class=\"string\">'xxx代理网点'</span>);        <span class=\"comment\">// 创建代理网点</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> company = <span class=\"keyword\">new</span> ExpressCompany(<span class=\"string\">'xxx快递公司'</span>);   <span class=\"comment\">// 创建xxx快递公司</span></span><br><span class=\"line\"></span><br><span class=\"line\">company.setProxy(proxy); <span class=\"comment\">// 设置代理网点</span></span><br><span class=\"line\">company.send(<span class=\"string\">'小明'</span>);    <span class=\"comment\">// 快递公司发送快递给小明</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; 小明接收到了xxx快递公司xxx代理网点发来的快递。</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>代理模式中代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。保护代理可以控制其他程序对被代理对象的访问。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建，能有效节约系统资源。</p>"},{"title":"详解JavaScript对象继承方式","date":"2018-03-07T16:00:00.000Z","toc":false,"comments":0,"_content":"\n继承是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。如今，JavaScript语言火热，同样支持面向对象编程。那么，JavaScript有哪些实现继承的方式呢？\n\n<!--more-->\n\n## 对象冒充\n\n对象冒充的原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 Parent 构造函数成为 Children 的方法，然后调用它。Children 就会收到 Parent 的构造函数中定义的属性和方法。\n\n例如，用下面的方式定义 Parent 和 Children：\n```js\n// 父类构造函数\nvar Parent = function (name) {\n  this.name = name;\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function (name) {\n  this.method = Parent;\n  this.method(name); // 实现继承的关键\n  delete this.method;\n\n  this.getName = function () {\n    console.log(this.name);\n  }\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\");\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getName(); // 输出： jo\n```\n其实，就是把 Parent 构造函数放到 Children 构造函数里面执行一次。那为什么不直接执行，非要转个弯把 Parent 赋值给 Children 的 method 属性再执行呢？这跟 this 的指向有关，在函数内 this 是指向 window 的。当将 Parent 赋值给 Children 的 method 时, this 就指向了 Children 类的实例。\n\n## 原型链继承\n\n众所周知，JavaScript 是一门基于原型的语言，在 JavaScript 中 prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制：\n```js\n// 父类构造函数\nvar Parent = function(){\n  this.name = \"john\";\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function(){};\n\nChildren.prototype = new Parent(); // 实现继承的关键\n\nvar p = new Parent();\nvar c = new Children();\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! john.\n```\n*注意：调用 Parent 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。*\n\n## 使用 call 或 applay 方法\n\n这个方法是与对象冒充方法最相似的方法，因为它也是通过改变了 this 的指向而实现继承:\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function(name){\n  Parent.call(this, name); // 实现继承的关键\n\n  this.getName = function(){\n    console.log(this.name);\n  }\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\");\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! john.\nc.getName(); // 输出： joe\n```\napply 方法就不举列了，它和 call 方法的区别在于它的第二个参数必须是数组。\n\n## 混合方式\n\n对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。如何选择呢？答案很简单，两者都用。\n\n在 JavaScript 中创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制：\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n};\n\nParent.prototype.sayHi = function(){\n   console.log(\"Hi! \" + this.name + \".\");\n};\n\n// 子类构造函数\nvar Children = function(name, age){\n  Parent.call(this, name); // 实现继承的关键\n  this.age = age;\n};\n\nChildren.prototype = new Parent(); // 实现继承的关键\n\nChildren.prototype.getAge = function(){\n  console.log(this.age);\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\",30);\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getAge(); // 输出： 30\n```\n\n## 使用Object.create 方法\n\nObject.create 方法会使用指定的原型对象及其属性去创建一个新的对象:\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n};\n\nParent.prototype.sayHi = function(){\n  console.log(\"Hi! \" + this.name + \".\");\n};\n\n// 子类构造函数\nvar Children = function(name, age){\n  Parent.call(this, name); // 实现继承的关键\n  this.age = age;\n};\n\nChildren.prototype = Object.create(Parent.prototype); // 实现继承的关键\nChildren.prototype.constructor = children; // @\n\nChildren.prototype.getAge = function(){\n  console.log(this.age);\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\",30);\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getAge(); // 输出： 30\n```\n*@:当执行 Children.prototype = Object.create(Parent.prototype) 这个语句后，Children 的 constructor 就被改变为 Parent ,因此需要将 Children.prototype.constructor 重新指定为 Children 自身。*\n\n## extends 关键字实现继承\n\n这个是 ES6 的语法糖，下面看下es6实现继承的方法：\n```js\nclass Parent {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nclass Children extends Parent {\n  constructor(name, age, job) {\n    this.job = job; // 这里会报错\n    super(name, age);\n    this.job = job; // 正确\n  }\n}\n```\n上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。子类Children的构造函数之中的super()，代表调用父类Parent的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n\n*注意：super虽然代表了父类Parent的构造函数，但是返回的是子类Children的实例，即super内部的this指的是Children，因此super()在这里相当于Parent.prototype.constructor.call(this)。*","source":"_posts/2018-03-08-详解JavaScript对象继承方式.md","raw":"---\ntitle: 详解JavaScript对象继承方式\ndate: 2018-03-08\ntoc: false\ncomments: false\ntags:\n    - 继承\ncategories:\n    - JavaScript\n---\n\n继承是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。如今，JavaScript语言火热，同样支持面向对象编程。那么，JavaScript有哪些实现继承的方式呢？\n\n<!--more-->\n\n## 对象冒充\n\n对象冒充的原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 Parent 构造函数成为 Children 的方法，然后调用它。Children 就会收到 Parent 的构造函数中定义的属性和方法。\n\n例如，用下面的方式定义 Parent 和 Children：\n```js\n// 父类构造函数\nvar Parent = function (name) {\n  this.name = name;\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function (name) {\n  this.method = Parent;\n  this.method(name); // 实现继承的关键\n  delete this.method;\n\n  this.getName = function () {\n    console.log(this.name);\n  }\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\");\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getName(); // 输出： jo\n```\n其实，就是把 Parent 构造函数放到 Children 构造函数里面执行一次。那为什么不直接执行，非要转个弯把 Parent 赋值给 Children 的 method 属性再执行呢？这跟 this 的指向有关，在函数内 this 是指向 window 的。当将 Parent 赋值给 Children 的 method 时, this 就指向了 Children 类的实例。\n\n## 原型链继承\n\n众所周知，JavaScript 是一门基于原型的语言，在 JavaScript 中 prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制：\n```js\n// 父类构造函数\nvar Parent = function(){\n  this.name = \"john\";\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function(){};\n\nChildren.prototype = new Parent(); // 实现继承的关键\n\nvar p = new Parent();\nvar c = new Children();\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! john.\n```\n*注意：调用 Parent 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。*\n\n## 使用 call 或 applay 方法\n\n这个方法是与对象冒充方法最相似的方法，因为它也是通过改变了 this 的指向而实现继承:\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n\n  this.sayHi = function(){\n    console.log(\"Hi! \" + this.name + \".\");\n  }\n};\n\n// 子类构造函数\nvar Children = function(name){\n  Parent.call(this, name); // 实现继承的关键\n\n  this.getName = function(){\n    console.log(this.name);\n  }\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\");\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! john.\nc.getName(); // 输出： joe\n```\napply 方法就不举列了，它和 call 方法的区别在于它的第二个参数必须是数组。\n\n## 混合方式\n\n对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。如何选择呢？答案很简单，两者都用。\n\n在 JavaScript 中创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制：\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n};\n\nParent.prototype.sayHi = function(){\n   console.log(\"Hi! \" + this.name + \".\");\n};\n\n// 子类构造函数\nvar Children = function(name, age){\n  Parent.call(this, name); // 实现继承的关键\n  this.age = age;\n};\n\nChildren.prototype = new Parent(); // 实现继承的关键\n\nChildren.prototype.getAge = function(){\n  console.log(this.age);\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\",30);\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getAge(); // 输出： 30\n```\n\n## 使用Object.create 方法\n\nObject.create 方法会使用指定的原型对象及其属性去创建一个新的对象:\n```js\n// 父类构造函数\nvar Parent = function(name){\n  this.name = name;\n};\n\nParent.prototype.sayHi = function(){\n  console.log(\"Hi! \" + this.name + \".\");\n};\n\n// 子类构造函数\nvar Children = function(name, age){\n  Parent.call(this, name); // 实现继承的关键\n  this.age = age;\n};\n\nChildren.prototype = Object.create(Parent.prototype); // 实现继承的关键\nChildren.prototype.constructor = children; // @\n\nChildren.prototype.getAge = function(){\n  console.log(this.age);\n};\n\nvar p = new Parent(\"john\");\nvar c = new Children(\"joe\",30);\n\np.sayHi(); // 输出： Hi! john.\nc.sayHi(); // 输出： Hi! joe.\nc.getAge(); // 输出： 30\n```\n*@:当执行 Children.prototype = Object.create(Parent.prototype) 这个语句后，Children 的 constructor 就被改变为 Parent ,因此需要将 Children.prototype.constructor 重新指定为 Children 自身。*\n\n## extends 关键字实现继承\n\n这个是 ES6 的语法糖，下面看下es6实现继承的方法：\n```js\nclass Parent {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nclass Children extends Parent {\n  constructor(name, age, job) {\n    this.job = job; // 这里会报错\n    super(name, age);\n    this.job = job; // 正确\n  }\n}\n```\n上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。子类Children的构造函数之中的super()，代表调用父类Parent的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n\n*注意：super虽然代表了父类Parent的构造函数，但是返回的是子类Children的实例，即super内部的this指的是Children，因此super()在这里相当于Parent.prototype.constructor.call(this)。*","slug":"2018-03-08-详解JavaScript对象继承方式","published":1,"updated":"2019-08-21T10:23:56.572Z","layout":"post","photos":[],"link":"","_id":"ck31ar49r0009acqxtlr0g6ep","content":"<p>继承是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。如今，JavaScript语言火热，同样支持面向对象编程。那么，JavaScript有哪些实现继承的方式呢？</p>\n<a id=\"more\"></a>\n<h2 id=\"对象冒充\"><a href=\"#对象冒充\" class=\"headerlink\" title=\"对象冒充\"></a>对象冒充</h2><p>对象冒充的原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 Parent 构造函数成为 Children 的方法，然后调用它。Children 就会收到 Parent 的构造函数中定义的属性和方法。</p>\n<p>例如，用下面的方式定义 Parent 和 Children：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.method = Parent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.method(name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getName(); <span class=\"comment\">// 输出： jo</span></span><br></pre></td></tr></table></figure></p>\n<p>其实，就是把 Parent 构造函数放到 Children 构造函数里面执行一次。那为什么不直接执行，非要转个弯把 Parent 赋值给 Children 的 method 属性再执行呢？这跟 this 的指向有关，在函数内 this 是指向 window 的。当将 Parent 赋值给 Children 的 method 时, this 就指向了 Children 类的实例。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>众所周知，JavaScript 是一门基于原型的语言，在 JavaScript 中 prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"john\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children();</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br></pre></td></tr></table></figure></p>\n<p><em>注意：调用 Parent 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。</em></p>\n<h2 id=\"使用-call-或-applay-方法\"><a href=\"#使用-call-或-applay-方法\" class=\"headerlink\" title=\"使用 call 或 applay 方法\"></a>使用 call 或 applay 方法</h2><p>这个方法是与对象冒充方法最相似的方法，因为它也是通过改变了 this 的指向而实现继承:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.getName(); <span class=\"comment\">// 输出： joe</span></span><br></pre></td></tr></table></figure></p>\n<p>apply 方法就不举列了，它和 call 方法的区别在于它的第二个参数必须是数组。</p>\n<h2 id=\"混合方式\"><a href=\"#混合方式\" class=\"headerlink\" title=\"混合方式\"></a>混合方式</h2><p>对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。如何选择呢？答案很简单，两者都用。</p>\n<p>在 JavaScript 中创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getAge(); <span class=\"comment\">// 输出： 30</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用Object-create-方法\"><a href=\"#使用Object-create-方法\" class=\"headerlink\" title=\"使用Object.create 方法\"></a>使用Object.create 方法</h2><p>Object.create 方法会使用指定的原型对象及其属性去创建一个新的对象:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">Children.prototype.constructor = children; <span class=\"comment\">// @</span></span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getAge(); <span class=\"comment\">// 输出： 30</span></span><br></pre></td></tr></table></figure></p>\n<p><em>@:当执行 Children.prototype = Object.create(Parent.prototype) 这个语句后，Children 的 constructor 就被改变为 Parent ,因此需要将 Children.prototype.constructor 重新指定为 Children 自身。</em></p>\n<h2 id=\"extends-关键字实现继承\"><a href=\"#extends-关键字实现继承\" class=\"headerlink\" title=\"extends 关键字实现继承\"></a>extends 关键字实现继承</h2><p>这个是 ES6 的语法糖，下面看下es6实现继承的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Children</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age, job) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = job; <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = job; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。子类Children的构造函数之中的super()，代表调用父类Parent的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>\n<p><em>注意：super虽然代表了父类Parent的构造函数，但是返回的是子类Children的实例，即super内部的this指的是Children，因此super()在这里相当于Parent.prototype.constructor.call(this)。</em></p>\n","site":{"data":{}},"excerpt":"<p>继承是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。如今，JavaScript语言火热，同样支持面向对象编程。那么，JavaScript有哪些实现继承的方式呢？</p>","more":"<h2 id=\"对象冒充\"><a href=\"#对象冒充\" class=\"headerlink\" title=\"对象冒充\"></a>对象冒充</h2><p>对象冒充的原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 Parent 构造函数成为 Children 的方法，然后调用它。Children 就会收到 Parent 的构造函数中定义的属性和方法。</p>\n<p>例如，用下面的方式定义 Parent 和 Children：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.method = Parent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.method(name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getName(); <span class=\"comment\">// 输出： jo</span></span><br></pre></td></tr></table></figure></p>\n<p>其实，就是把 Parent 构造函数放到 Children 构造函数里面执行一次。那为什么不直接执行，非要转个弯把 Parent 赋值给 Children 的 method 属性再执行呢？这跟 this 的指向有关，在函数内 this 是指向 window 的。当将 Parent 赋值给 Children 的 method 时, this 就指向了 Children 类的实例。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>众所周知，JavaScript 是一门基于原型的语言，在 JavaScript 中 prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"john\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children();</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br></pre></td></tr></table></figure></p>\n<p><em>注意：调用 Parent 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。</em></p>\n<h2 id=\"使用-call-或-applay-方法\"><a href=\"#使用-call-或-applay-方法\" class=\"headerlink\" title=\"使用 call 或 applay 方法\"></a>使用 call 或 applay 方法</h2><p>这个方法是与对象冒充方法最相似的方法，因为它也是通过改变了 this 的指向而实现继承:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.getName(); <span class=\"comment\">// 输出： joe</span></span><br></pre></td></tr></table></figure></p>\n<p>apply 方法就不举列了，它和 call 方法的区别在于它的第二个参数必须是数组。</p>\n<h2 id=\"混合方式\"><a href=\"#混合方式\" class=\"headerlink\" title=\"混合方式\"></a>混合方式</h2><p>对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。如何选择呢？答案很简单，两者都用。</p>\n<p>在 JavaScript 中创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getAge(); <span class=\"comment\">// 输出： 30</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用Object-create-方法\"><a href=\"#使用Object-create-方法\" class=\"headerlink\" title=\"使用Object.create 方法\"></a>使用Object.create 方法</h2><p>Object.create 方法会使用指定的原型对象及其属性去创建一个新的对象:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi! \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Children = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype); <span class=\"comment\">// 实现继承的关键</span></span><br><span class=\"line\">Children.prototype.constructor = children; <span class=\"comment\">// @</span></span><br><span class=\"line\"></span><br><span class=\"line\">Children.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"john\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Children(<span class=\"string\">\"joe\"</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p.sayHi(); <span class=\"comment\">// 输出： Hi! john.</span></span><br><span class=\"line\">c.sayHi(); <span class=\"comment\">// 输出： Hi! joe.</span></span><br><span class=\"line\">c.getAge(); <span class=\"comment\">// 输出： 30</span></span><br></pre></td></tr></table></figure></p>\n<p><em>@:当执行 Children.prototype = Object.create(Parent.prototype) 这个语句后，Children 的 constructor 就被改变为 Parent ,因此需要将 Children.prototype.constructor 重新指定为 Children 自身。</em></p>\n<h2 id=\"extends-关键字实现继承\"><a href=\"#extends-关键字实现继承\" class=\"headerlink\" title=\"extends 关键字实现继承\"></a>extends 关键字实现继承</h2><p>这个是 ES6 的语法糖，下面看下es6实现继承的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Children</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, age, job) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = job; <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = job; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。子类Children的构造函数之中的super()，代表调用父类Parent的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>\n<p><em>注意：super虽然代表了父类Parent的构造函数，但是返回的是子类Children的实例，即super内部的this指的是Children，因此super()在这里相当于Parent.prototype.constructor.call(this)。</em></p>"},{"title":"设计模式之工厂模式","date":"2018-03-06T16:00:00.000Z","toc":false,"comments":0,"_content":"\n工厂模式是一种最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。因为工厂模式就相当于创建实例对象的new，在JavaScript中通常会使用new关键字来实例化对象，如A：a = new A()，工厂模式也是用来创建实例对象的，所以，以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。\n\n<!--more-->\n \n设计意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行**。\n\n主要解决的问题：**在不同条件下创建不同实例时，主要解决接口选择的问题**。\n\n工厂模式就是使用工厂方法代替new操作创建对象实例的一种模式。即把new操作交给其他对象来做。\n\n最简单的工厂模式程序实例：\n```js\nclass A {\n  constructor() {}\n}\n\n// 创建class A实例的工厂函数\nvar createA = () => {\n  return new A()\n}\n```\n于是，创建一个class A的实例：\n```js\nvar a = createA()\n```\n这是最简单的工厂模式，只用于创建一种实例对象。这么简单的工厂模式是没有任何意义的，因为，要创建class A的实例直接new就好了，没必要引入createA，所以这里的createA是多余的。\n\n现在，来看下真正有用的工厂模式：\n```js\nclass A {\n  constructor() {}\n}\n\nclass B {\n  constructor() {}\n}\n\nclass C {\n  constructor() {}\n}\n\n// 工厂函数\nvar factory = (type) => {\n  if (type === 'A') {\n    return new A()\n  } else if (type === 'B') {\n    return new B()\n  } else if (type === 'C') {\n    return new C()\n  }\n}\n```\n这样，就可以使用工厂函数（factory）创建不同的类的实例了。想创建那个类的实例，只要知道其类型就可以了，剩下的操作都交给工厂函数（factory）。 而且，如果想增加一个类型，只要扩展一个工厂类就可以了。\n\n接下来我们再看一个在网页中使用的一个实例。假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类：\n```js\nvar page = (function(){\n                \n  var dom = {};\n              \n  //子类1：处理文本\n  dom.Text = function(){\n    this.insert = function(where, text){\n      var txt = document.createTextNode(text);\n      where.appendChild(txt);\n    }\n  };\n              \n  //子类2：处理链接\n  dom.Link = function(){\n    this.insert = function(where, url){\n      var link = document.createElement(\"a\");\n      link.href = url;\n      link.appendChild(document.createTextNode(url));\n      where.appendChild(link);\n    }\n  };\n              \n  //子类3：处理图片\n  dom.Image = function () {\n    this.insert = function (where, url) {\n      var img = document.createElement('img');\n      img.src = url;\n      where.appendChild(img);\n    };\n  };\n              \n  //创建函数\n  dom.create = function(type){\n    return new dom[type];\n  };\n              \n  return {\n    dom: dom\n  }\n                \n})();\n            \nvar t = page.dom.create('Text');\nt.insert(document.body, \"新建文本节点\");\n```","source":"_posts/2018-03-07-设计模式之工厂模式.md","raw":"---\ntitle: 设计模式之工厂模式\ndate: 2018-03-07\ntoc: false\ncomments: false\ntags:\n    - JavaScript设计模式\ncategories:\n    - 设计模式\n---\n\n工厂模式是一种最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。因为工厂模式就相当于创建实例对象的new，在JavaScript中通常会使用new关键字来实例化对象，如A：a = new A()，工厂模式也是用来创建实例对象的，所以，以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。\n\n<!--more-->\n \n设计意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行**。\n\n主要解决的问题：**在不同条件下创建不同实例时，主要解决接口选择的问题**。\n\n工厂模式就是使用工厂方法代替new操作创建对象实例的一种模式。即把new操作交给其他对象来做。\n\n最简单的工厂模式程序实例：\n```js\nclass A {\n  constructor() {}\n}\n\n// 创建class A实例的工厂函数\nvar createA = () => {\n  return new A()\n}\n```\n于是，创建一个class A的实例：\n```js\nvar a = createA()\n```\n这是最简单的工厂模式，只用于创建一种实例对象。这么简单的工厂模式是没有任何意义的，因为，要创建class A的实例直接new就好了，没必要引入createA，所以这里的createA是多余的。\n\n现在，来看下真正有用的工厂模式：\n```js\nclass A {\n  constructor() {}\n}\n\nclass B {\n  constructor() {}\n}\n\nclass C {\n  constructor() {}\n}\n\n// 工厂函数\nvar factory = (type) => {\n  if (type === 'A') {\n    return new A()\n  } else if (type === 'B') {\n    return new B()\n  } else if (type === 'C') {\n    return new C()\n  }\n}\n```\n这样，就可以使用工厂函数（factory）创建不同的类的实例了。想创建那个类的实例，只要知道其类型就可以了，剩下的操作都交给工厂函数（factory）。 而且，如果想增加一个类型，只要扩展一个工厂类就可以了。\n\n接下来我们再看一个在网页中使用的一个实例。假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类：\n```js\nvar page = (function(){\n                \n  var dom = {};\n              \n  //子类1：处理文本\n  dom.Text = function(){\n    this.insert = function(where, text){\n      var txt = document.createTextNode(text);\n      where.appendChild(txt);\n    }\n  };\n              \n  //子类2：处理链接\n  dom.Link = function(){\n    this.insert = function(where, url){\n      var link = document.createElement(\"a\");\n      link.href = url;\n      link.appendChild(document.createTextNode(url));\n      where.appendChild(link);\n    }\n  };\n              \n  //子类3：处理图片\n  dom.Image = function () {\n    this.insert = function (where, url) {\n      var img = document.createElement('img');\n      img.src = url;\n      where.appendChild(img);\n    };\n  };\n              \n  //创建函数\n  dom.create = function(type){\n    return new dom[type];\n  };\n              \n  return {\n    dom: dom\n  }\n                \n})();\n            \nvar t = page.dom.create('Text');\nt.insert(document.body, \"新建文本节点\");\n```","slug":"2018-03-07-设计模式之工厂模式","published":1,"updated":"2019-08-21T10:23:56.569Z","layout":"post","photos":[],"link":"","_id":"ck31ar49s000bacqxcrhimcp9","content":"<p>工厂模式是一种最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。因为工厂模式就相当于创建实例对象的new，在JavaScript中通常会使用new关键字来实例化对象，如A：a = new A()，工厂模式也是用来创建实例对象的，所以，以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>\n<a id=\"more\"></a>\n<p>设计意图：<strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</strong>。</p>\n<p>主要解决的问题：<strong>在不同条件下创建不同实例时，主要解决接口选择的问题</strong>。</p>\n<p>工厂模式就是使用工厂方法代替new操作创建对象实例的一种模式。即把new操作交给其他对象来做。</p>\n<p>最简单的工厂模式程序实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建class A实例的工厂函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> createA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>于是，创建一个class A的实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = createA()</span><br></pre></td></tr></table></figure></p>\n<p>这是最简单的工厂模式，只用于创建一种实例对象。这么简单的工厂模式是没有任何意义的，因为，要创建class A的实例直接new就好了，没必要引入createA，所以这里的createA是多余的。</p>\n<p>现在，来看下真正有用的工厂模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"function\">(<span class=\"params\">type</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'A'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'B'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'C'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，就可以使用工厂函数（factory）创建不同的类的实例了。想创建那个类的实例，只要知道其类型就可以了，剩下的操作都交给工厂函数（factory）。 而且，如果想增加一个类型，只要扩展一个工厂类就可以了。</p>\n<p>接下来我们再看一个在网页中使用的一个实例。假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> page = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">  <span class=\"keyword\">var</span> dom = &#123;&#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类1：处理文本</span></span><br><span class=\"line\">  dom.Text = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">where, text</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> txt = <span class=\"built_in\">document</span>.createTextNode(text);</span><br><span class=\"line\">      where.appendChild(txt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类2：处理链接</span></span><br><span class=\"line\">  dom.Link = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">where, url</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.appendChild(<span class=\"built_in\">document</span>.createTextNode(url));</span><br><span class=\"line\">      where.appendChild(link);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类3：处理图片</span></span><br><span class=\"line\">  dom.Image = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">where, url</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>);</span><br><span class=\"line\">      img.src = url;</span><br><span class=\"line\">      where.appendChild(img);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//创建函数</span></span><br><span class=\"line\">  dom.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> dom[type];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dom: dom</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> t = page.dom.create(<span class=\"string\">'Text'</span>);</span><br><span class=\"line\">t.insert(<span class=\"built_in\">document</span>.body, <span class=\"string\">\"新建文本节点\"</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>工厂模式是一种最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。因为工厂模式就相当于创建实例对象的new，在JavaScript中通常会使用new关键字来实例化对象，如A：a = new A()，工厂模式也是用来创建实例对象的，所以，以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>","more":"<p>设计意图：<strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</strong>。</p>\n<p>主要解决的问题：<strong>在不同条件下创建不同实例时，主要解决接口选择的问题</strong>。</p>\n<p>工厂模式就是使用工厂方法代替new操作创建对象实例的一种模式。即把new操作交给其他对象来做。</p>\n<p>最简单的工厂模式程序实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建class A实例的工厂函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> createA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>于是，创建一个class A的实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = createA()</span><br></pre></td></tr></table></figure></p>\n<p>这是最简单的工厂模式，只用于创建一种实例对象。这么简单的工厂模式是没有任何意义的，因为，要创建class A的实例直接new就好了，没必要引入createA，所以这里的createA是多余的。</p>\n<p>现在，来看下真正有用的工厂模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"function\">(<span class=\"params\">type</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'A'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'B'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'C'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，就可以使用工厂函数（factory）创建不同的类的实例了。想创建那个类的实例，只要知道其类型就可以了，剩下的操作都交给工厂函数（factory）。 而且，如果想增加一个类型，只要扩展一个工厂类就可以了。</p>\n<p>接下来我们再看一个在网页中使用的一个实例。假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> page = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">  <span class=\"keyword\">var</span> dom = &#123;&#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类1：处理文本</span></span><br><span class=\"line\">  dom.Text = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">where, text</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> txt = <span class=\"built_in\">document</span>.createTextNode(text);</span><br><span class=\"line\">      where.appendChild(txt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类2：处理链接</span></span><br><span class=\"line\">  dom.Link = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">where, url</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.appendChild(<span class=\"built_in\">document</span>.createTextNode(url));</span><br><span class=\"line\">      where.appendChild(link);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//子类3：处理图片</span></span><br><span class=\"line\">  dom.Image = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">where, url</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>);</span><br><span class=\"line\">      img.src = url;</span><br><span class=\"line\">      where.appendChild(img);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"comment\">//创建函数</span></span><br><span class=\"line\">  dom.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> dom[type];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">              </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dom: dom</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> t = page.dom.create(<span class=\"string\">'Text'</span>);</span><br><span class=\"line\">t.insert(<span class=\"built_in\">document</span>.body, <span class=\"string\">\"新建文本节点\"</span>);</span><br></pre></td></tr></table></figure></p>"},{"title":"详解javascript中this的工作原理","date":"2018-04-11T16:00:00.000Z","toc":false,"comments":0,"_content":"\n在 JavaScript 中 this 常常指向方法调用的对象，但有些时候并不是这样的，本文将详细解读在不同的情况下 this 的指向。\n\n<!--more-->\n\n## 指向 window\n\n在全局中使用 this，它将会指向全局对象，因为浏览器中运行的 JavaScript 的全局对象默认为 window，所以，此时 this 指向 window：\n```js\nconsole.log(this) // 控制台将打印出 window 对象\n```\n在全局作用域内的函数调用， this 也会执行 window：\n```js\nfunction foo(){\n  console.log(this);\n};\n\nfoo(); // 控制台也会打印出 window 对象\n```\n此处并不难理解，因为全局对象默认为 window，则 foo() 实质是 window.foo()。\n\n其实，在JavaScript中函数调用时，this都会指向window对象。看下面的执行结果：\n```js\nfunction foo(){\n  console.log(this);\n};\n            \nvar demo = document.querySelector(\".demo\");\n            \ndemo.onclick = foo;         //this指向demo元素对象\n            \ndemo.onclick = function(){\n  foo();                  //this指向window对象\n};\n```\n*注意：在 ES5 中，使用严格模式时，不存在全局变量， 此时 this 将不再指向 window， 而是 undefined 。*\n\n## 指向方法调用的对象\n\n在对象的方法调用中，this 指向该方法调用的对象：\n```js\nvar obj = {\n  getMe: function(){\n    console.log(this)\n  }\n};\n\nobj.getMe(); // 控制台打印出 obj 对象\n```\n\n## 构造函数内，指向调用构造函数所创建的对象实例\n\n通常我们会使用 new 关键词调用构造函数创建新的对象实例，此时构造函数内的 this 就会指向这个新创建出来的对象：\n```js\n//构造函数\nfunction Person(name){\n  this.name = name;\n  this.getMe = function(){\n    console.log(this);\n  }\n};\n\nvar joe = new Person(\"joe\");\n\njoe.getMe(); //控制台打印出一个新的名字为 “joe” 的 Person 实例\n```\n\n## 使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数\n\n使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数：\n```js\nvar obj = {\n  name: \"object\"\n};\n\nfunction a(){\n  console.log(this)\n};\n\na.call(obj); //控制台打印出 obj 对象\n```\n出现这样的结果是由 call、apply 和 bind 的实现原理决定的，call、apply 和 bind 改变 this 指向的原理是它动态改变了函数的运行上下文环境。","source":"_posts/2018-04-12-详解javascript中this的工作原理.md","raw":"---\ntitle: 详解javascript中this的工作原理\ndate: 2018-04-12\ntoc: false\ncomments: false\ntags:\n    - this的工作原理\ncategories:\n    - JavaScript\n---\n\n在 JavaScript 中 this 常常指向方法调用的对象，但有些时候并不是这样的，本文将详细解读在不同的情况下 this 的指向。\n\n<!--more-->\n\n## 指向 window\n\n在全局中使用 this，它将会指向全局对象，因为浏览器中运行的 JavaScript 的全局对象默认为 window，所以，此时 this 指向 window：\n```js\nconsole.log(this) // 控制台将打印出 window 对象\n```\n在全局作用域内的函数调用， this 也会执行 window：\n```js\nfunction foo(){\n  console.log(this);\n};\n\nfoo(); // 控制台也会打印出 window 对象\n```\n此处并不难理解，因为全局对象默认为 window，则 foo() 实质是 window.foo()。\n\n其实，在JavaScript中函数调用时，this都会指向window对象。看下面的执行结果：\n```js\nfunction foo(){\n  console.log(this);\n};\n            \nvar demo = document.querySelector(\".demo\");\n            \ndemo.onclick = foo;         //this指向demo元素对象\n            \ndemo.onclick = function(){\n  foo();                  //this指向window对象\n};\n```\n*注意：在 ES5 中，使用严格模式时，不存在全局变量， 此时 this 将不再指向 window， 而是 undefined 。*\n\n## 指向方法调用的对象\n\n在对象的方法调用中，this 指向该方法调用的对象：\n```js\nvar obj = {\n  getMe: function(){\n    console.log(this)\n  }\n};\n\nobj.getMe(); // 控制台打印出 obj 对象\n```\n\n## 构造函数内，指向调用构造函数所创建的对象实例\n\n通常我们会使用 new 关键词调用构造函数创建新的对象实例，此时构造函数内的 this 就会指向这个新创建出来的对象：\n```js\n//构造函数\nfunction Person(name){\n  this.name = name;\n  this.getMe = function(){\n    console.log(this);\n  }\n};\n\nvar joe = new Person(\"joe\");\n\njoe.getMe(); //控制台打印出一个新的名字为 “joe” 的 Person 实例\n```\n\n## 使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数\n\n使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数：\n```js\nvar obj = {\n  name: \"object\"\n};\n\nfunction a(){\n  console.log(this)\n};\n\na.call(obj); //控制台打印出 obj 对象\n```\n出现这样的结果是由 call、apply 和 bind 的实现原理决定的，call、apply 和 bind 改变 this 指向的原理是它动态改变了函数的运行上下文环境。","slug":"2018-04-12-详解javascript中this的工作原理","published":1,"updated":"2019-08-21T10:23:56.578Z","layout":"post","photos":[],"link":"","_id":"ck31ar49u000eacqxkcyo7gw6","content":"<p>在 JavaScript 中 this 常常指向方法调用的对象，但有些时候并不是这样的，本文将详细解读在不同的情况下 this 的指向。</p>\n<a id=\"more\"></a>\n<h2 id=\"指向-window\"><a href=\"#指向-window\" class=\"headerlink\" title=\"指向 window\"></a>指向 window</h2><p>在全局中使用 this，它将会指向全局对象，因为浏览器中运行的 JavaScript 的全局对象默认为 window，所以，此时 this 指向 window：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">// 控制台将打印出 window 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>在全局作用域内的函数调用， this 也会执行 window：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 控制台也会打印出 window 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>此处并不难理解，因为全局对象默认为 window，则 foo() 实质是 window.foo()。</p>\n<p>其实，在JavaScript中函数调用时，this都会指向window对象。看下面的执行结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".demo\"</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">demo.onclick = foo;         <span class=\"comment\">//this指向demo元素对象</span></span><br><span class=\"line\">            </span><br><span class=\"line\">demo.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  foo();                  <span class=\"comment\">//this指向window对象</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><em>注意：在 ES5 中，使用严格模式时，不存在全局变量， 此时 this 将不再指向 window， 而是 undefined 。</em></p>\n<h2 id=\"指向方法调用的对象\"><a href=\"#指向方法调用的对象\" class=\"headerlink\" title=\"指向方法调用的对象\"></a>指向方法调用的对象</h2><p>在对象的方法调用中，this 指向该方法调用的对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  getMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getMe(); <span class=\"comment\">// 控制台打印出 obj 对象</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数内，指向调用构造函数所创建的对象实例\"><a href=\"#构造函数内，指向调用构造函数所创建的对象实例\" class=\"headerlink\" title=\"构造函数内，指向调用构造函数所创建的对象实例\"></a>构造函数内，指向调用构造函数所创建的对象实例</h2><p>通常我们会使用 new 关键词调用构造函数创建新的对象实例，此时构造函数内的 this 就会指向这个新创建出来的对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getMe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getMe(); <span class=\"comment\">//控制台打印出一个新的名字为 “joe” 的 Person 实例</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用函数的-call、apply-或-bind-方法时，this-将会被显式设置为函数调用的第一个参数\"><a href=\"#使用函数的-call、apply-或-bind-方法时，this-将会被显式设置为函数调用的第一个参数\" class=\"headerlink\" title=\"使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数\"></a>使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数</h2><p>使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"object\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.call(obj); <span class=\"comment\">//控制台打印出 obj 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>出现这样的结果是由 call、apply 和 bind 的实现原理决定的，call、apply 和 bind 改变 this 指向的原理是它动态改变了函数的运行上下文环境。</p>\n","site":{"data":{}},"excerpt":"<p>在 JavaScript 中 this 常常指向方法调用的对象，但有些时候并不是这样的，本文将详细解读在不同的情况下 this 的指向。</p>","more":"<h2 id=\"指向-window\"><a href=\"#指向-window\" class=\"headerlink\" title=\"指向 window\"></a>指向 window</h2><p>在全局中使用 this，它将会指向全局对象，因为浏览器中运行的 JavaScript 的全局对象默认为 window，所以，此时 this 指向 window：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">// 控制台将打印出 window 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>在全局作用域内的函数调用， this 也会执行 window：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 控制台也会打印出 window 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>此处并不难理解，因为全局对象默认为 window，则 foo() 实质是 window.foo()。</p>\n<p>其实，在JavaScript中函数调用时，this都会指向window对象。看下面的执行结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".demo\"</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">demo.onclick = foo;         <span class=\"comment\">//this指向demo元素对象</span></span><br><span class=\"line\">            </span><br><span class=\"line\">demo.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  foo();                  <span class=\"comment\">//this指向window对象</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><em>注意：在 ES5 中，使用严格模式时，不存在全局变量， 此时 this 将不再指向 window， 而是 undefined 。</em></p>\n<h2 id=\"指向方法调用的对象\"><a href=\"#指向方法调用的对象\" class=\"headerlink\" title=\"指向方法调用的对象\"></a>指向方法调用的对象</h2><p>在对象的方法调用中，this 指向该方法调用的对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  getMe: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getMe(); <span class=\"comment\">// 控制台打印出 obj 对象</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造函数内，指向调用构造函数所创建的对象实例\"><a href=\"#构造函数内，指向调用构造函数所创建的对象实例\" class=\"headerlink\" title=\"构造函数内，指向调用构造函数所创建的对象实例\"></a>构造函数内，指向调用构造函数所创建的对象实例</h2><p>通常我们会使用 new 关键词调用构造函数创建新的对象实例，此时构造函数内的 this 就会指向这个新创建出来的对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getMe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"joe\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getMe(); <span class=\"comment\">//控制台打印出一个新的名字为 “joe” 的 Person 实例</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用函数的-call、apply-或-bind-方法时，this-将会被显式设置为函数调用的第一个参数\"><a href=\"#使用函数的-call、apply-或-bind-方法时，this-将会被显式设置为函数调用的第一个参数\" class=\"headerlink\" title=\"使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数\"></a>使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数</h2><p>使用函数的 call、apply 或 bind 方法时，this 将会被显式设置为函数调用的第一个参数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"object\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.call(obj); <span class=\"comment\">//控制台打印出 obj 对象</span></span><br></pre></td></tr></table></figure></p>\n<p>出现这样的结果是由 call、apply 和 bind 的实现原理决定的，call、apply 和 bind 改变 this 指向的原理是它动态改变了函数的运行上下文环境。</p>"},{"title":"设计模式之策略模式","date":"2018-03-04T16:00:00.000Z","toc":false,"comments":0,"_content":"\n所谓“条条道路通罗马”，在现实中，为达到某种目的往往不是只有一种方法。比如挣钱养家：可以做点小生意，可以打分工，甚至还可以是偷、抢、赌等等各种手段。在程序语言设计中，也会遇到这种类似的情况，要实现某种功能可以有多种方案选择。比如，在很多地图类软件上，你想从A地点到达B地点时，为你提供几种交通工具的选择，可以查看每种交通工具的所需费用和时间。在程序语言设计中，把这种设计模式叫做策略模式。\n\n<!--more-->\n\n策略模式的定义：**策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换**。\n\n主要解决问题：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护**。\n\n从上面两点可以知道，策略模式是通过定义一系列的算法，并对其进行封装，使其可以相互替换使用，目的是消除多层if...else语句嵌套的问题。这里的定义一系列的算法的意思是：**你可以将每一种方案封装成函数或者是类的形式**。\n\n## 策略模式的实现\n\n先看一个日常的例子，根据明天的天气状况，决定明天该做什么：晴天，和女朋友出去逛街；阴天，和隔壁老王打牌；雨天，在家看看电视剧。代码实现：\n```js\nfunction doSomething (weather) {\n  if (weather === '晴天') {\n    console.log('和女朋友出去逛街')\n  }\n  \n  if (weather === '阴天') {\n    console.log('和隔壁老王打牌')\n  }\n  \n  if (weather === '雨天') {\n    console.log('在家看看电视剧')\n  }\n}\n```\n时间流逝，第二天到来了，看了下天气预报今天是阴天，于是查下今天该干什么：\n```js\ndoSomething('阴天')\n// 和隔壁老王打牌\n```\n这段代码完全正常，使用起来一点问题都没有，但不易于维护。把天气状况在细分，如：小雨、大雨、雷雨、多云。那岂不是要写一大堆的if语句，这时，doSomething函数就会变得很臃肿，难以维护。\n\n用策略模式重构：\n```js\n// 晴天\nclass Sunny {\n  constructor () {}\n  \n  doSomething () {\n    console.log('和女朋友出去逛街')\n  }\n}\n\n// 阴天\nclass Cloudy {\n  constructor () {}\n  \n  doSomething () {\n    console.log('和隔壁老王打牌')\n  }\n}\n\n// 雨天\nclass Rainy {\n  constructor () {}\n  \n  doSomething () {\n    console.log('在家看看电视剧')\n  }\n}\n\n// 定义备忘录类\nclass Memo {\n  constructor() {\n    this.strategy = null\n  }\n  \n  setStrategy (strategy) {\n    this.strategy = strategy // 设置对应的策略对象\n  }\n  \n  doSomething () {\n    this.strategy.doSomething()\n  }\n}\n\nvar memo = new Memo()\n\nmemo.setStrategy(new Cloudy())\nmemo.doSomething()\n```\n这是模拟传统语言实现的策略模式，用策略模式实现后代码增加了不少，这样有必要吗？从代码量的角度看，策略模式没什么优势。但现实是，作为开发者我们有80%的时间是在维护旧的代码，剩下的20%才是写新的代码，所以写出可维护的代码同样很重要。改用策略模式后的代码虽然代码量增加了，但更易于维护了。为什么更容易维护了呢？因为现在可以很方便的增加或删除天气类型。那个更易于维护一眼便知。\n\n## JavaScript策略模式的实现\n\nJavaScript语言没有类的概念，所以上面不是正在意义上的JavaScript语言策略模式。在JavaScript中，函数是一等对象，可以将函数当作一个变量传递到函数内部执行，所以JavaScript语言是天生自带策略模式的哦！用高阶函数实现JavaScript语言的策略模式：\n```js\n// 晴天\nvar sunny = function () {\n  console.log('和女朋友出去逛街')\n}\n\n// 阴天\nvar cloudy = function () {\n  console.log('和隔壁老王打牌')\n}\n\n// 雨天\nvar rainy = function () {\n  console.log('在家看看电视剧')\n}\n\n// 执行策略事件\nfunction doSomething (something) {\n  something()\n}\n\ndoSomething(strategy.cloudy)\n```\n是不是眼前一亮？JavaScript语言的策略模式比传统语言，显得更加简洁、更加灵活。\n\n## 总结\n\n策略模式是一种简单的设计模式，它的设计目的就是为了解决 if...else... 所带来的复杂和难以维护的问题。在实际开发中，如果遇到复杂的 if...else... 语句，那么应该考虑是否适用策略模式去解决。","source":"_posts/2018-03-05-设计模式之策略模式.md","raw":"---\ntitle: 设计模式之策略模式\ndate: 2018-03-05\ntoc: false\ncomments: false\ntags:\n    - JavaScript设计模式\ncategories:\n    - 设计模式\n---\n\n所谓“条条道路通罗马”，在现实中，为达到某种目的往往不是只有一种方法。比如挣钱养家：可以做点小生意，可以打分工，甚至还可以是偷、抢、赌等等各种手段。在程序语言设计中，也会遇到这种类似的情况，要实现某种功能可以有多种方案选择。比如，在很多地图类软件上，你想从A地点到达B地点时，为你提供几种交通工具的选择，可以查看每种交通工具的所需费用和时间。在程序语言设计中，把这种设计模式叫做策略模式。\n\n<!--more-->\n\n策略模式的定义：**策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换**。\n\n主要解决问题：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护**。\n\n从上面两点可以知道，策略模式是通过定义一系列的算法，并对其进行封装，使其可以相互替换使用，目的是消除多层if...else语句嵌套的问题。这里的定义一系列的算法的意思是：**你可以将每一种方案封装成函数或者是类的形式**。\n\n## 策略模式的实现\n\n先看一个日常的例子，根据明天的天气状况，决定明天该做什么：晴天，和女朋友出去逛街；阴天，和隔壁老王打牌；雨天，在家看看电视剧。代码实现：\n```js\nfunction doSomething (weather) {\n  if (weather === '晴天') {\n    console.log('和女朋友出去逛街')\n  }\n  \n  if (weather === '阴天') {\n    console.log('和隔壁老王打牌')\n  }\n  \n  if (weather === '雨天') {\n    console.log('在家看看电视剧')\n  }\n}\n```\n时间流逝，第二天到来了，看了下天气预报今天是阴天，于是查下今天该干什么：\n```js\ndoSomething('阴天')\n// 和隔壁老王打牌\n```\n这段代码完全正常，使用起来一点问题都没有，但不易于维护。把天气状况在细分，如：小雨、大雨、雷雨、多云。那岂不是要写一大堆的if语句，这时，doSomething函数就会变得很臃肿，难以维护。\n\n用策略模式重构：\n```js\n// 晴天\nclass Sunny {\n  constructor () {}\n  \n  doSomething () {\n    console.log('和女朋友出去逛街')\n  }\n}\n\n// 阴天\nclass Cloudy {\n  constructor () {}\n  \n  doSomething () {\n    console.log('和隔壁老王打牌')\n  }\n}\n\n// 雨天\nclass Rainy {\n  constructor () {}\n  \n  doSomething () {\n    console.log('在家看看电视剧')\n  }\n}\n\n// 定义备忘录类\nclass Memo {\n  constructor() {\n    this.strategy = null\n  }\n  \n  setStrategy (strategy) {\n    this.strategy = strategy // 设置对应的策略对象\n  }\n  \n  doSomething () {\n    this.strategy.doSomething()\n  }\n}\n\nvar memo = new Memo()\n\nmemo.setStrategy(new Cloudy())\nmemo.doSomething()\n```\n这是模拟传统语言实现的策略模式，用策略模式实现后代码增加了不少，这样有必要吗？从代码量的角度看，策略模式没什么优势。但现实是，作为开发者我们有80%的时间是在维护旧的代码，剩下的20%才是写新的代码，所以写出可维护的代码同样很重要。改用策略模式后的代码虽然代码量增加了，但更易于维护了。为什么更容易维护了呢？因为现在可以很方便的增加或删除天气类型。那个更易于维护一眼便知。\n\n## JavaScript策略模式的实现\n\nJavaScript语言没有类的概念，所以上面不是正在意义上的JavaScript语言策略模式。在JavaScript中，函数是一等对象，可以将函数当作一个变量传递到函数内部执行，所以JavaScript语言是天生自带策略模式的哦！用高阶函数实现JavaScript语言的策略模式：\n```js\n// 晴天\nvar sunny = function () {\n  console.log('和女朋友出去逛街')\n}\n\n// 阴天\nvar cloudy = function () {\n  console.log('和隔壁老王打牌')\n}\n\n// 雨天\nvar rainy = function () {\n  console.log('在家看看电视剧')\n}\n\n// 执行策略事件\nfunction doSomething (something) {\n  something()\n}\n\ndoSomething(strategy.cloudy)\n```\n是不是眼前一亮？JavaScript语言的策略模式比传统语言，显得更加简洁、更加灵活。\n\n## 总结\n\n策略模式是一种简单的设计模式，它的设计目的就是为了解决 if...else... 所带来的复杂和难以维护的问题。在实际开发中，如果遇到复杂的 if...else... 语句，那么应该考虑是否适用策略模式去解决。","slug":"2018-03-05-设计模式之策略模式","published":1,"updated":"2019-07-29T06:45:27.783Z","layout":"post","photos":[],"link":"","_id":"ck31ar49v000hacqxfatnlntr","content":"<p>所谓“条条道路通罗马”，在现实中，为达到某种目的往往不是只有一种方法。比如挣钱养家：可以做点小生意，可以打分工，甚至还可以是偷、抢、赌等等各种手段。在程序语言设计中，也会遇到这种类似的情况，要实现某种功能可以有多种方案选择。比如，在很多地图类软件上，你想从A地点到达B地点时，为你提供几种交通工具的选择，可以查看每种交通工具的所需费用和时间。在程序语言设计中，把这种设计模式叫做策略模式。</p>\n<a id=\"more\"></a>\n<p>策略模式的定义：<strong>策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换</strong>。</p>\n<p>主要解决问题：<strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</strong>。</p>\n<p>从上面两点可以知道，策略模式是通过定义一系列的算法，并对其进行封装，使其可以相互替换使用，目的是消除多层if…else语句嵌套的问题。这里的定义一系列的算法的意思是：<strong>你可以将每一种方案封装成函数或者是类的形式</strong>。</p>\n<h2 id=\"策略模式的实现\"><a href=\"#策略模式的实现\" class=\"headerlink\" title=\"策略模式的实现\"></a>策略模式的实现</h2><p>先看一个日常的例子，根据明天的天气状况，决定明天该做什么：晴天，和女朋友出去逛街；阴天，和隔壁老王打牌；雨天，在家看看电视剧。代码实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">weather</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'晴天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'阴天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'雨天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间流逝，第二天到来了，看了下天气预报今天是阴天，于是查下今天该干什么：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething(<span class=\"string\">'阴天'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 和隔壁老王打牌</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码完全正常，使用起来一点问题都没有，但不易于维护。把天气状况在细分，如：小雨、大雨、雷雨、多云。那岂不是要写一大堆的if语句，这时，doSomething函数就会变得很臃肿，难以维护。</p>\n<p>用策略模式重构：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 晴天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sunny</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阴天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cloudy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 雨天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rainy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义备忘录类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  setStrategy (strategy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy <span class=\"comment\">// 设置对应的策略对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy.doSomething()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> memo = <span class=\"keyword\">new</span> Memo()</span><br><span class=\"line\"></span><br><span class=\"line\">memo.setStrategy(<span class=\"keyword\">new</span> Cloudy())</span><br><span class=\"line\">memo.doSomething()</span><br></pre></td></tr></table></figure></p>\n<p>这是模拟传统语言实现的策略模式，用策略模式实现后代码增加了不少，这样有必要吗？从代码量的角度看，策略模式没什么优势。但现实是，作为开发者我们有80%的时间是在维护旧的代码，剩下的20%才是写新的代码，所以写出可维护的代码同样很重要。改用策略模式后的代码虽然代码量增加了，但更易于维护了。为什么更容易维护了呢？因为现在可以很方便的增加或删除天气类型。那个更易于维护一眼便知。</p>\n<h2 id=\"JavaScript策略模式的实现\"><a href=\"#JavaScript策略模式的实现\" class=\"headerlink\" title=\"JavaScript策略模式的实现\"></a>JavaScript策略模式的实现</h2><p>JavaScript语言没有类的概念，所以上面不是正在意义上的JavaScript语言策略模式。在JavaScript中，函数是一等对象，可以将函数当作一个变量传递到函数内部执行，所以JavaScript语言是天生自带策略模式的哦！用高阶函数实现JavaScript语言的策略模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 晴天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sunny = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阴天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cloudy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 雨天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行策略事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  something()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething(strategy.cloudy)</span><br></pre></td></tr></table></figure></p>\n<p>是不是眼前一亮？JavaScript语言的策略模式比传统语言，显得更加简洁、更加灵活。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>策略模式是一种简单的设计模式，它的设计目的就是为了解决 if…else… 所带来的复杂和难以维护的问题。在实际开发中，如果遇到复杂的 if…else… 语句，那么应该考虑是否适用策略模式去解决。</p>\n","site":{"data":{}},"excerpt":"<p>所谓“条条道路通罗马”，在现实中，为达到某种目的往往不是只有一种方法。比如挣钱养家：可以做点小生意，可以打分工，甚至还可以是偷、抢、赌等等各种手段。在程序语言设计中，也会遇到这种类似的情况，要实现某种功能可以有多种方案选择。比如，在很多地图类软件上，你想从A地点到达B地点时，为你提供几种交通工具的选择，可以查看每种交通工具的所需费用和时间。在程序语言设计中，把这种设计模式叫做策略模式。</p>","more":"<p>策略模式的定义：<strong>策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换</strong>。</p>\n<p>主要解决问题：<strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</strong>。</p>\n<p>从上面两点可以知道，策略模式是通过定义一系列的算法，并对其进行封装，使其可以相互替换使用，目的是消除多层if…else语句嵌套的问题。这里的定义一系列的算法的意思是：<strong>你可以将每一种方案封装成函数或者是类的形式</strong>。</p>\n<h2 id=\"策略模式的实现\"><a href=\"#策略模式的实现\" class=\"headerlink\" title=\"策略模式的实现\"></a>策略模式的实现</h2><p>先看一个日常的例子，根据明天的天气状况，决定明天该做什么：晴天，和女朋友出去逛街；阴天，和隔壁老王打牌；雨天，在家看看电视剧。代码实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">weather</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'晴天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'阴天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (weather === <span class=\"string\">'雨天'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间流逝，第二天到来了，看了下天气预报今天是阴天，于是查下今天该干什么：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething(<span class=\"string\">'阴天'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 和隔壁老王打牌</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码完全正常，使用起来一点问题都没有，但不易于维护。把天气状况在细分，如：小雨、大雨、雷雨、多云。那岂不是要写一大堆的if语句，这时，doSomething函数就会变得很臃肿，难以维护。</p>\n<p>用策略模式重构：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 晴天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sunny</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阴天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cloudy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 雨天</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rainy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义备忘录类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  setStrategy (strategy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy <span class=\"comment\">// 设置对应的策略对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomething () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy.doSomething()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> memo = <span class=\"keyword\">new</span> Memo()</span><br><span class=\"line\"></span><br><span class=\"line\">memo.setStrategy(<span class=\"keyword\">new</span> Cloudy())</span><br><span class=\"line\">memo.doSomething()</span><br></pre></td></tr></table></figure></p>\n<p>这是模拟传统语言实现的策略模式，用策略模式实现后代码增加了不少，这样有必要吗？从代码量的角度看，策略模式没什么优势。但现实是，作为开发者我们有80%的时间是在维护旧的代码，剩下的20%才是写新的代码，所以写出可维护的代码同样很重要。改用策略模式后的代码虽然代码量增加了，但更易于维护了。为什么更容易维护了呢？因为现在可以很方便的增加或删除天气类型。那个更易于维护一眼便知。</p>\n<h2 id=\"JavaScript策略模式的实现\"><a href=\"#JavaScript策略模式的实现\" class=\"headerlink\" title=\"JavaScript策略模式的实现\"></a>JavaScript策略模式的实现</h2><p>JavaScript语言没有类的概念，所以上面不是正在意义上的JavaScript语言策略模式。在JavaScript中，函数是一等对象，可以将函数当作一个变量传递到函数内部执行，所以JavaScript语言是天生自带策略模式的哦！用高阶函数实现JavaScript语言的策略模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 晴天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sunny = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'和女朋友出去逛街'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阴天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cloudy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'和隔壁老王打牌'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 雨天</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'在家看看电视剧'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行策略事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  something()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething(strategy.cloudy)</span><br></pre></td></tr></table></figure></p>\n<p>是不是眼前一亮？JavaScript语言的策略模式比传统语言，显得更加简洁、更加灵活。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>策略模式是一种简单的设计模式，它的设计目的就是为了解决 if…else… 所带来的复杂和难以维护的问题。在实际开发中，如果遇到复杂的 if…else… 语句，那么应该考虑是否适用策略模式去解决。</p>"},{"title":"设计模式之依赖注入","date":"2018-04-28T16:00:00.000Z","toc":false,"comments":0,"_content":"\n**控制反转（IoC）**，是面向对象编程中的一种**设计原则**，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做**依赖注入（DI）**。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。\n\n<!--more-->\n\n**控制反转（IoC）**与**依赖注入（DI）**的关系：**控制反转（IoC）**是一种全新的设计模式。而**依赖注入（DI）**是**控制反转（IoC）**的一种实现方式。\n\n如果Class A中用到了Class B的对象实例b，一般情况下，需要在A的代码中显式的new一个B的对象。即：\n```js\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\nclass A {\n  constructor () {\n    this.b = new B('b');\n  }\n}\n```\n\n采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的**容器控制程序（IoC容器）**来将B对象在外部new出来并注入到A类里的引用中。而A要依赖B，必然要使用B的接口，那么：\n* 通过A的接口，把B传入\n* 通过A的构造，把B传入\n* 通过设置A的属性，把B传入\n\n这个过程叫**依赖注入（DI）**，分别对应着**依赖注入（DI）**的三种实现方式：\n* 接口注入\n* 构造注入\n* 属性注入\n\n## 接口注入\n\n接口注入是指类对外设置一个可访问的接口，通过该接口注入依赖。实现如下：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name) {\n    this.name = 'A';\n  }\n  \n  // 依赖注入接口\n  inject (name, dep) {\n    this[name] = dep;\n  }\n}\n\nvar a = new A('a');\n\na.inject('b', new B('b'));\n```\n\n## 构造注入\n\n构造注入是指在构造期间完成一个完整的、合法的对象。所有依赖关系在构造函数中集中呈现，依赖关系在构造时由容器一次性设定。即将依赖以构造函数参数的形式传进对象中：\n```js\n// 依赖对象\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A依赖class B的实例b\nclass A {\n  constructor (name, dep) {\n    this.name = 'A';\n    this.b = dep; // 将依赖dep赋给b\n  }\n}\n\nvar a = new A('a', new B('b'));\n```\n现在，class A可以通过构造函数传入一个依赖。\n\n接下来，我们将优化class A的构造函数，使它可以传入任意的依赖对象：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class C\nclass C {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name, deps = {}) {\n    this.name = 'A';\n    // 安装依赖\n    Object.keys(deps).map(k => {\n      this[k] = deps[k]\n    })\n  }\n}\n\n// class A的实例a依赖class B的实例b和class C的实例c\nvar a = new A('a', {\n  b: new B('b'),\n  c: new C('c')\n})\n```\n\n## 属性注入\n\n属性注入是指通过设置属性值的方式将依赖对象注入。通过设值方法设定依赖关系更加直观。如果依赖关系较为复杂，那么构造注入模式的构造函数也会相当庞大，而此时设值注入模式则更为简洁。\n\n设值方法设定依赖实现如下：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name) {\n    this.name = 'A';\n  }\n}\n\nvar a = new A('a');\n\na.b = new B('b') // 设定依赖\n```\n\n## 总结\n\n依赖注入解决的是一类问题，所以它是一种设计模式。即使你没有听说过它，但你可能已经用过它不止一次，只是没有意识到罢了。什么是依赖注入？依赖注入可以动态地为函数添加依赖。依赖注入在强类型语言中，如JAVA，比较常见，是一种解藕的方式。这并不是说在JavaScript中很少使用它。而是，在JavaScript中很容易就实现了这种动态依赖。JavaScript使用bind，apply，call等函数可以很方便地控制函数的参数和this变量，所以简单地依赖注入在很多情况下已经被不知不觉地使用。在AMD的模块定义中，其方式也是一种依赖注入。所以，在JavaScript中依赖注入可以说是无所不在的。","source":"_posts/2018-04-29-设计模式之依赖注入.md","raw":"---\ntitle: 设计模式之依赖注入\ndate: 2018-04-29\ntoc: false\ncomments: false\ntags:\n    - JavaScript设计模式\ncategories:\n    - 设计模式\n---\n\n**控制反转（IoC）**，是面向对象编程中的一种**设计原则**，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做**依赖注入（DI）**。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。\n\n<!--more-->\n\n**控制反转（IoC）**与**依赖注入（DI）**的关系：**控制反转（IoC）**是一种全新的设计模式。而**依赖注入（DI）**是**控制反转（IoC）**的一种实现方式。\n\n如果Class A中用到了Class B的对象实例b，一般情况下，需要在A的代码中显式的new一个B的对象。即：\n```js\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\nclass A {\n  constructor () {\n    this.b = new B('b');\n  }\n}\n```\n\n采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的**容器控制程序（IoC容器）**来将B对象在外部new出来并注入到A类里的引用中。而A要依赖B，必然要使用B的接口，那么：\n* 通过A的接口，把B传入\n* 通过A的构造，把B传入\n* 通过设置A的属性，把B传入\n\n这个过程叫**依赖注入（DI）**，分别对应着**依赖注入（DI）**的三种实现方式：\n* 接口注入\n* 构造注入\n* 属性注入\n\n## 接口注入\n\n接口注入是指类对外设置一个可访问的接口，通过该接口注入依赖。实现如下：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name) {\n    this.name = 'A';\n  }\n  \n  // 依赖注入接口\n  inject (name, dep) {\n    this[name] = dep;\n  }\n}\n\nvar a = new A('a');\n\na.inject('b', new B('b'));\n```\n\n## 构造注入\n\n构造注入是指在构造期间完成一个完整的、合法的对象。所有依赖关系在构造函数中集中呈现，依赖关系在构造时由容器一次性设定。即将依赖以构造函数参数的形式传进对象中：\n```js\n// 依赖对象\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A依赖class B的实例b\nclass A {\n  constructor (name, dep) {\n    this.name = 'A';\n    this.b = dep; // 将依赖dep赋给b\n  }\n}\n\nvar a = new A('a', new B('b'));\n```\n现在，class A可以通过构造函数传入一个依赖。\n\n接下来，我们将优化class A的构造函数，使它可以传入任意的依赖对象：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class C\nclass C {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name, deps = {}) {\n    this.name = 'A';\n    // 安装依赖\n    Object.keys(deps).map(k => {\n      this[k] = deps[k]\n    })\n  }\n}\n\n// class A的实例a依赖class B的实例b和class C的实例c\nvar a = new A('a', {\n  b: new B('b'),\n  c: new C('c')\n})\n```\n\n## 属性注入\n\n属性注入是指通过设置属性值的方式将依赖对象注入。通过设值方法设定依赖关系更加直观。如果依赖关系较为复杂，那么构造注入模式的构造函数也会相当庞大，而此时设值注入模式则更为简洁。\n\n设值方法设定依赖实现如下：\n```js\n// class B\nclass B {\n  constructor (name) {\n    this.name = name;\n  }\n}\n\n// class A\nclass A {\n  constructor (name) {\n    this.name = 'A';\n  }\n}\n\nvar a = new A('a');\n\na.b = new B('b') // 设定依赖\n```\n\n## 总结\n\n依赖注入解决的是一类问题，所以它是一种设计模式。即使你没有听说过它，但你可能已经用过它不止一次，只是没有意识到罢了。什么是依赖注入？依赖注入可以动态地为函数添加依赖。依赖注入在强类型语言中，如JAVA，比较常见，是一种解藕的方式。这并不是说在JavaScript中很少使用它。而是，在JavaScript中很容易就实现了这种动态依赖。JavaScript使用bind，apply，call等函数可以很方便地控制函数的参数和this变量，所以简单地依赖注入在很多情况下已经被不知不觉地使用。在AMD的模块定义中，其方式也是一种依赖注入。所以，在JavaScript中依赖注入可以说是无所不在的。","slug":"2018-04-29-设计模式之依赖注入","published":1,"updated":"2019-08-21T10:23:56.581Z","layout":"post","photos":[],"link":"","_id":"ck31ar49x000iacqxvwgjytn5","content":"<p><strong>控制反转（IoC）</strong>，是面向对象编程中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做<strong>依赖注入（DI）</strong>。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>\n<a id=\"more\"></a>\n<p><strong>控制反转（IoC）</strong>与<strong>依赖注入（DI）</strong>的关系：<strong>控制反转（IoC）</strong>是一种全新的设计模式。而<strong>依赖注入（DI）</strong>是<strong>控制反转（IoC）</strong>的一种实现方式。</p>\n<p>如果Class A中用到了Class B的对象实例b，一般情况下，需要在A的代码中显式的new一个B的对象。即：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的<strong>容器控制程序（IoC容器）</strong>来将B对象在外部new出来并注入到A类里的引用中。而A要依赖B，必然要使用B的接口，那么：</p>\n<ul>\n<li>通过A的接口，把B传入</li>\n<li>通过A的构造，把B传入</li>\n<li>通过设置A的属性，把B传入</li>\n</ul>\n<p>这个过程叫<strong>依赖注入（DI）</strong>，分别对应着<strong>依赖注入（DI）</strong>的三种实现方式：</p>\n<ul>\n<li>接口注入</li>\n<li>构造注入</li>\n<li>属性注入</li>\n</ul>\n<h2 id=\"接口注入\"><a href=\"#接口注入\" class=\"headerlink\" title=\"接口注入\"></a>接口注入</h2><p>接口注入是指类对外设置一个可访问的接口，通过该接口注入依赖。实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入接口</span></span><br><span class=\"line\">  inject (name, dep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[name] = dep;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.inject(<span class=\"string\">'b'</span>, <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造注入\"><a href=\"#构造注入\" class=\"headerlink\" title=\"构造注入\"></a>构造注入</h2><p>构造注入是指在构造期间完成一个完整的、合法的对象。所有依赖关系在构造函数中集中呈现，依赖关系在构造时由容器一次性设定。即将依赖以构造函数参数的形式传进对象中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A依赖class B的实例b</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name, dep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = dep; <span class=\"comment\">// 将依赖dep赋给b</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>, <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>现在，class A可以通过构造函数传入一个依赖。</p>\n<p>接下来，我们将优化class A的构造函数，使它可以传入任意的依赖对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class C</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name, deps = &#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 安装依赖</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(deps).map(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>[k] = deps[k]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A的实例a依赖class B的实例b和class C的实例c</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>, &#123;</span><br><span class=\"line\">  b: <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>),</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> C(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性注入\"><a href=\"#属性注入\" class=\"headerlink\" title=\"属性注入\"></a>属性注入</h2><p>属性注入是指通过设置属性值的方式将依赖对象注入。通过设值方法设定依赖关系更加直观。如果依赖关系较为复杂，那么构造注入模式的构造函数也会相当庞大，而此时设值注入模式则更为简洁。</p>\n<p>设值方法设定依赖实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>) <span class=\"comment\">// 设定依赖</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>依赖注入解决的是一类问题，所以它是一种设计模式。即使你没有听说过它，但你可能已经用过它不止一次，只是没有意识到罢了。什么是依赖注入？依赖注入可以动态地为函数添加依赖。依赖注入在强类型语言中，如JAVA，比较常见，是一种解藕的方式。这并不是说在JavaScript中很少使用它。而是，在JavaScript中很容易就实现了这种动态依赖。JavaScript使用bind，apply，call等函数可以很方便地控制函数的参数和this变量，所以简单地依赖注入在很多情况下已经被不知不觉地使用。在AMD的模块定义中，其方式也是一种依赖注入。所以，在JavaScript中依赖注入可以说是无所不在的。</p>\n","site":{"data":{}},"excerpt":"<p><strong>控制反转（IoC）</strong>，是面向对象编程中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做<strong>依赖注入（DI）</strong>。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>","more":"<p><strong>控制反转（IoC）</strong>与<strong>依赖注入（DI）</strong>的关系：<strong>控制反转（IoC）</strong>是一种全新的设计模式。而<strong>依赖注入（DI）</strong>是<strong>控制反转（IoC）</strong>的一种实现方式。</p>\n<p>如果Class A中用到了Class B的对象实例b，一般情况下，需要在A的代码中显式的new一个B的对象。即：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的<strong>容器控制程序（IoC容器）</strong>来将B对象在外部new出来并注入到A类里的引用中。而A要依赖B，必然要使用B的接口，那么：</p>\n<ul>\n<li>通过A的接口，把B传入</li>\n<li>通过A的构造，把B传入</li>\n<li>通过设置A的属性，把B传入</li>\n</ul>\n<p>这个过程叫<strong>依赖注入（DI）</strong>，分别对应着<strong>依赖注入（DI）</strong>的三种实现方式：</p>\n<ul>\n<li>接口注入</li>\n<li>构造注入</li>\n<li>属性注入</li>\n</ul>\n<h2 id=\"接口注入\"><a href=\"#接口注入\" class=\"headerlink\" title=\"接口注入\"></a>接口注入</h2><p>接口注入是指类对外设置一个可访问的接口，通过该接口注入依赖。实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入接口</span></span><br><span class=\"line\">  inject (name, dep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[name] = dep;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.inject(<span class=\"string\">'b'</span>, <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"构造注入\"><a href=\"#构造注入\" class=\"headerlink\" title=\"构造注入\"></a>构造注入</h2><p>构造注入是指在构造期间完成一个完整的、合法的对象。所有依赖关系在构造函数中集中呈现，依赖关系在构造时由容器一次性设定。即将依赖以构造函数参数的形式传进对象中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A依赖class B的实例b</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name, dep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = dep; <span class=\"comment\">// 将依赖dep赋给b</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>, <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>现在，class A可以通过构造函数传入一个依赖。</p>\n<p>接下来，我们将优化class A的构造函数，使它可以传入任意的依赖对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class C</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name, deps = &#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 安装依赖</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(deps).map(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>[k] = deps[k]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A的实例a依赖class B的实例b和class C的实例c</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>, &#123;</span><br><span class=\"line\">  b: <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>),</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> C(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性注入\"><a href=\"#属性注入\" class=\"headerlink\" title=\"属性注入\"></a>属性注入</h2><p>属性注入是指通过设置属性值的方式将依赖对象注入。通过设值方法设定依赖关系更加直观。如果依赖关系较为复杂，那么构造注入模式的构造函数也会相当庞大，而此时设值注入模式则更为简洁。</p>\n<p>设值方法设定依赖实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.b = <span class=\"keyword\">new</span> B(<span class=\"string\">'b'</span>) <span class=\"comment\">// 设定依赖</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>依赖注入解决的是一类问题，所以它是一种设计模式。即使你没有听说过它，但你可能已经用过它不止一次，只是没有意识到罢了。什么是依赖注入？依赖注入可以动态地为函数添加依赖。依赖注入在强类型语言中，如JAVA，比较常见，是一种解藕的方式。这并不是说在JavaScript中很少使用它。而是，在JavaScript中很容易就实现了这种动态依赖。JavaScript使用bind，apply，call等函数可以很方便地控制函数的参数和this变量，所以简单地依赖注入在很多情况下已经被不知不觉地使用。在AMD的模块定义中，其方式也是一种依赖注入。所以，在JavaScript中依赖注入可以说是无所不在的。</p>"},{"title":"javaScript识别网址并转为链接","date":"2018-04-07T16:00:00.000Z","toc":false,"comments":0,"_content":"\n最近项目有个需求：用户发送消息时，如果发送者输入的信息中含有网址文本，要在接受者界面中显示网址链接，点击该链接直接跳转到网页。这个功能和 QQ 发送网址文本的效果类似。\n\n<!--more-->\n\n## 思路\n\n首先，要判断文本中是否含有网址文本，其次，将网址文本转换为可点击的链接文本，即将网址文本通过a标签括起来。\n\n## 实现过程\n\n### 识别网址\n\n在 javaScript 中判断某种特殊格式的文本，首选正则表达式，下面是我用来检查网址的正则：\n```js\nvar re = /^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)?/g;\n```\n\n这里需要注意的是，正则必须使用全局匹配 g 。否则只能匹配到文本中的第一个网址文本。\n\n### 网址转换为链接\n\n在网址转换中涉及字符串的操作，那么自然要使用 String 对象的方法，先复习下 String 对象能与正则表达式一起使用的方法有哪些？\n\n常用的有这几个：\n\nsearch：检索与正则表达式相匹配的值。\nmatch：找到一个或多个正则表达式的匹配。\nreplace：替换与正则表达式匹配的子串。\nsplit：把字符串分割为字符串数组。\n\n可以看出来，其中 replace 是最方便、最适合这个需求的。\n\n### replace函数的用法\n\n语法：\n```\nstring.replace(searchvalue,newvalue)\n```\n参数解析：\n\nsearchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n\nnewvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n\n注意：第二个参数支持使用函数来制定文本替换的规则。\n\n回顾需求，要将网址转换为a链接,那么得到的转换规则如下：\n```html\nurl => <a href='url' target='_blank'>url</a>\n```\n\n## 封装实现函数\n\n根据上面的分析过程，使用代码来描述如下：\n```js\nvar urlToLink = function(str){\n  var re = /^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)?/g; \n\n  str = str.replace(re, function(website){ \n    return \"<a href='\" + website +\"' target='_blank'>\" + website + \"</a>\"; \n  }); \n  return str;\n};\n```\n到这里，javaScript识别网址文本并转为链接文本的函数接完成了。\n","source":"_posts/2018-04-08-javaScript识别网址并转为链接.md","raw":"---\ntitle: javaScript识别网址并转为链接\ndate: 2018-04-08\ntoc: false\ncomments: false\ntags:\n    - JavaScript\ncategories:\n    - JavaScript\n---\n\n最近项目有个需求：用户发送消息时，如果发送者输入的信息中含有网址文本，要在接受者界面中显示网址链接，点击该链接直接跳转到网页。这个功能和 QQ 发送网址文本的效果类似。\n\n<!--more-->\n\n## 思路\n\n首先，要判断文本中是否含有网址文本，其次，将网址文本转换为可点击的链接文本，即将网址文本通过a标签括起来。\n\n## 实现过程\n\n### 识别网址\n\n在 javaScript 中判断某种特殊格式的文本，首选正则表达式，下面是我用来检查网址的正则：\n```js\nvar re = /^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)?/g;\n```\n\n这里需要注意的是，正则必须使用全局匹配 g 。否则只能匹配到文本中的第一个网址文本。\n\n### 网址转换为链接\n\n在网址转换中涉及字符串的操作，那么自然要使用 String 对象的方法，先复习下 String 对象能与正则表达式一起使用的方法有哪些？\n\n常用的有这几个：\n\nsearch：检索与正则表达式相匹配的值。\nmatch：找到一个或多个正则表达式的匹配。\nreplace：替换与正则表达式匹配的子串。\nsplit：把字符串分割为字符串数组。\n\n可以看出来，其中 replace 是最方便、最适合这个需求的。\n\n### replace函数的用法\n\n语法：\n```\nstring.replace(searchvalue,newvalue)\n```\n参数解析：\n\nsearchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n\nnewvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n\n注意：第二个参数支持使用函数来制定文本替换的规则。\n\n回顾需求，要将网址转换为a链接,那么得到的转换规则如下：\n```html\nurl => <a href='url' target='_blank'>url</a>\n```\n\n## 封装实现函数\n\n根据上面的分析过程，使用代码来描述如下：\n```js\nvar urlToLink = function(str){\n  var re = /^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)?/g; \n\n  str = str.replace(re, function(website){ \n    return \"<a href='\" + website +\"' target='_blank'>\" + website + \"</a>\"; \n  }); \n  return str;\n};\n```\n到这里，javaScript识别网址文本并转为链接文本的函数接完成了。\n","slug":"2018-04-08-javaScript识别网址并转为链接","published":1,"updated":"2019-07-26T03:01:01.793Z","layout":"post","photos":[],"link":"","_id":"ck31ar49z000nacqxzrskexr9","content":"<p>最近项目有个需求：用户发送消息时，如果发送者输入的信息中含有网址文本，要在接受者界面中显示网址链接，点击该链接直接跳转到网页。这个功能和 QQ 发送网址文本的效果类似。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先，要判断文本中是否含有网址文本，其次，将网址文本转换为可点击的链接文本，即将网址文本通过a标签括起来。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><h3 id=\"识别网址\"><a href=\"#识别网址\" class=\"headerlink\" title=\"识别网址\"></a>识别网址</h3><p>在 javaScript 中判断某种特殊格式的文本，首选正则表达式，下面是我用来检查网址的正则：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/^(f|ht)&#123;1&#125;(tp|tps):\\\\/</span>\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?<span class=\"regexp\">/g;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是，正则必须使用全局匹配 g 。否则只能匹配到文本中的第一个网址文本。</p>\n<h3 id=\"网址转换为链接\"><a href=\"#网址转换为链接\" class=\"headerlink\" title=\"网址转换为链接\"></a>网址转换为链接</h3><p>在网址转换中涉及字符串的操作，那么自然要使用 String 对象的方法，先复习下 String 对象能与正则表达式一起使用的方法有哪些？</p>\n<p>常用的有这几个：</p>\n<p>search：检索与正则表达式相匹配的值。<br>match：找到一个或多个正则表达式的匹配。<br>replace：替换与正则表达式匹配的子串。<br>split：把字符串分割为字符串数组。</p>\n<p>可以看出来，其中 replace 是最方便、最适合这个需求的。</p>\n<h3 id=\"replace函数的用法\"><a href=\"#replace函数的用法\" class=\"headerlink\" title=\"replace函数的用法\"></a>replace函数的用法</h3><p>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.replace(searchvalue,newvalue)</span><br></pre></td></tr></table></figure></p>\n<p>参数解析：</p>\n<p>searchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</p>\n<p>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</p>\n<p>注意：第二个参数支持使用函数来制定文本替换的规则。</p>\n<p>回顾需求，要将网址转换为a链接,那么得到的转换规则如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url =&gt; <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">'url'</span> <span class=\"attr\">target</span>=<span class=\"string\">'_blank'</span>&gt;</span>url<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"封装实现函数\"><a href=\"#封装实现函数\" class=\"headerlink\" title=\"封装实现函数\"></a>封装实现函数</h2><p>根据上面的分析过程，使用代码来描述如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> urlToLink = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/^(f|ht)&#123;1&#125;(tp|tps):\\\\/</span>\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?<span class=\"regexp\">/g; </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  str = str.replace(re, function(website)&#123; </span></span><br><span class=\"line\"><span class=\"regexp\">    return \"&lt;a href='\" + website +\"' target='_blank'&gt;\" + website + \"&lt;/</span>a&gt;<span class=\"string\">\"; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;); </span></span><br><span class=\"line\"><span class=\"string\">  return str;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>到这里，javaScript识别网址文本并转为链接文本的函数接完成了。</p>\n","site":{"data":{}},"excerpt":"<p>最近项目有个需求：用户发送消息时，如果发送者输入的信息中含有网址文本，要在接受者界面中显示网址链接，点击该链接直接跳转到网页。这个功能和 QQ 发送网址文本的效果类似。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先，要判断文本中是否含有网址文本，其次，将网址文本转换为可点击的链接文本，即将网址文本通过a标签括起来。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><h3 id=\"识别网址\"><a href=\"#识别网址\" class=\"headerlink\" title=\"识别网址\"></a>识别网址</h3><p>在 javaScript 中判断某种特殊格式的文本，首选正则表达式，下面是我用来检查网址的正则：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/^(f|ht)&#123;1&#125;(tp|tps):\\\\/</span>\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?<span class=\"regexp\">/g;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是，正则必须使用全局匹配 g 。否则只能匹配到文本中的第一个网址文本。</p>\n<h3 id=\"网址转换为链接\"><a href=\"#网址转换为链接\" class=\"headerlink\" title=\"网址转换为链接\"></a>网址转换为链接</h3><p>在网址转换中涉及字符串的操作，那么自然要使用 String 对象的方法，先复习下 String 对象能与正则表达式一起使用的方法有哪些？</p>\n<p>常用的有这几个：</p>\n<p>search：检索与正则表达式相匹配的值。<br>match：找到一个或多个正则表达式的匹配。<br>replace：替换与正则表达式匹配的子串。<br>split：把字符串分割为字符串数组。</p>\n<p>可以看出来，其中 replace 是最方便、最适合这个需求的。</p>\n<h3 id=\"replace函数的用法\"><a href=\"#replace函数的用法\" class=\"headerlink\" title=\"replace函数的用法\"></a>replace函数的用法</h3><p>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.replace(searchvalue,newvalue)</span><br></pre></td></tr></table></figure></p>\n<p>参数解析：</p>\n<p>searchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</p>\n<p>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</p>\n<p>注意：第二个参数支持使用函数来制定文本替换的规则。</p>\n<p>回顾需求，要将网址转换为a链接,那么得到的转换规则如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url =&gt; <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">'url'</span> <span class=\"attr\">target</span>=<span class=\"string\">'_blank'</span>&gt;</span>url<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"封装实现函数\"><a href=\"#封装实现函数\" class=\"headerlink\" title=\"封装实现函数\"></a>封装实现函数</h2><p>根据上面的分析过程，使用代码来描述如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> urlToLink = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/^(f|ht)&#123;1&#125;(tp|tps):\\\\/</span>\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?<span class=\"regexp\">/g; </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  str = str.replace(re, function(website)&#123; </span></span><br><span class=\"line\"><span class=\"regexp\">    return \"&lt;a href='\" + website +\"' target='_blank'&gt;\" + website + \"&lt;/</span>a&gt;<span class=\"string\">\"; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;); </span></span><br><span class=\"line\"><span class=\"string\">  return str;</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>到这里，javaScript识别网址文本并转为链接文本的函数接完成了。</p>"},{"title":"Vue组件样式scoped的原理与样式穿透的用法","date":"2018-09-12T16:00:00.000Z","toc":false,"comments":0,"_content":"\n在Vue文件中的style标签上有一个特殊的属性——scoped。当一个style标签拥有scoped属性时候，它的css样式只能作用于当前的Vue组件。有了这个属性，可以使Vue组件的样式相互不被污染。这就相当于实现了样式的模块化。\n\n<!--more-->\n\n## scoped的实现原理\n\nVue中的scoped属性的效果主要是通过PostCss实现的。\n\n转译前的代码：\n```html\n<style scoped>\n  .example {\n    color:red;\n  }\n</style>\n<template>\n  <div class=\"example\">scoped属性例子</div>\n</template>\n```\n\n转译后的代码：\n```html\n.example[data-v-5558831a] {\n  color: red;\n}\n<template>\n  <div class=\"example\" data-v-5558831a>scoped属性例子</div>\n</template>\n```\n\nPostCSS给一个组件中样式对应的dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\n\nscoped的渲染规则：\n\n1、给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素。\n\n2、在每个css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式。\n\n## scoped样式穿透\n\nscoped在Vue组件中实现了样式的模块化，但同时也带来了一些问题——修改全局样式。当时在Vue项目中，当我们引入第三方组件库时，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。\n\nstylus预处理语言的样式穿透， 使用：>>>\n\n例如：\n```css\n.wrapper >>> .el-button {\n  border-radius:0;\n}\n```\n\nsass和less预处理语言的样式穿透，使用：/deep/\n\n例如：\n```css\n.wrapper /deep/ .el-button {\n  border-radius:0;\n}\n```\n\nscoped穿透规则：外层 穿透符号 第三方组件样式/全局样式\n\n## 样式穿透的其它方法\n\n1、在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里。\n\n2、建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入。\n\n\n\n\n\n","source":"_posts/2018-09-13-Vue组件样式scoped的实现原理以及scoped穿透的用法.md","raw":"---\ntitle: Vue组件样式scoped的原理与样式穿透的用法\ndate: 2018-09-13\ntoc: false\ncomments: false\ntags:\n    - vue组件样式\n    - scoped样式\n    - PostCss\ncategories:\n    - Vue\n---\n\n在Vue文件中的style标签上有一个特殊的属性——scoped。当一个style标签拥有scoped属性时候，它的css样式只能作用于当前的Vue组件。有了这个属性，可以使Vue组件的样式相互不被污染。这就相当于实现了样式的模块化。\n\n<!--more-->\n\n## scoped的实现原理\n\nVue中的scoped属性的效果主要是通过PostCss实现的。\n\n转译前的代码：\n```html\n<style scoped>\n  .example {\n    color:red;\n  }\n</style>\n<template>\n  <div class=\"example\">scoped属性例子</div>\n</template>\n```\n\n转译后的代码：\n```html\n.example[data-v-5558831a] {\n  color: red;\n}\n<template>\n  <div class=\"example\" data-v-5558831a>scoped属性例子</div>\n</template>\n```\n\nPostCSS给一个组件中样式对应的dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\n\nscoped的渲染规则：\n\n1、给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素。\n\n2、在每个css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式。\n\n## scoped样式穿透\n\nscoped在Vue组件中实现了样式的模块化，但同时也带来了一些问题——修改全局样式。当时在Vue项目中，当我们引入第三方组件库时，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。\n\nstylus预处理语言的样式穿透， 使用：>>>\n\n例如：\n```css\n.wrapper >>> .el-button {\n  border-radius:0;\n}\n```\n\nsass和less预处理语言的样式穿透，使用：/deep/\n\n例如：\n```css\n.wrapper /deep/ .el-button {\n  border-radius:0;\n}\n```\n\nscoped穿透规则：外层 穿透符号 第三方组件样式/全局样式\n\n## 样式穿透的其它方法\n\n1、在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里。\n\n2、建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入。\n\n\n\n\n\n","slug":"2018-09-13-Vue组件样式scoped的实现原理以及scoped穿透的用法","published":1,"updated":"2019-07-26T02:57:12.879Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a2000pacqxlyf3g7rj","content":"<p>在Vue文件中的style标签上有一个特殊的属性——scoped。当一个style标签拥有scoped属性时候，它的css样式只能作用于当前的Vue组件。有了这个属性，可以使Vue组件的样式相互不被污染。这就相当于实现了样式的模块化。</p>\n<a id=\"more\"></a>\n<h2 id=\"scoped的实现原理\"><a href=\"#scoped的实现原理\" class=\"headerlink\" title=\"scoped的实现原理\"></a>scoped的实现原理</h2><p>Vue中的scoped属性的效果主要是通过PostCss实现的。</p>\n<p>转译前的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\">  .example &#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example\"</span>&gt;</span>scoped属性例子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>转译后的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.example[data-v-5558831a] &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example\"</span> <span class=\"attr\">data-v-5558831a</span>&gt;</span>scoped属性例子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>PostCSS给一个组件中样式对应的dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。</p>\n<p>scoped的渲染规则：</p>\n<p>1、给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素。</p>\n<p>2、在每个css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式。</p>\n<h2 id=\"scoped样式穿透\"><a href=\"#scoped样式穿透\" class=\"headerlink\" title=\"scoped样式穿透\"></a>scoped样式穿透</h2><p>scoped在Vue组件中实现了样式的模块化，但同时也带来了一些问题——修改全局样式。当时在Vue项目中，当我们引入第三方组件库时，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。</p>\n<p>stylus预处理语言的样式穿透， 使用：&gt;&gt;&gt;</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &gt;&gt;&gt; <span class=\"selector-class\">.el-button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>sass和less预处理语言的样式穿透，使用：/deep/</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.wrapper /deep/ .el-button &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-radius</span><span class=\"selector-pseudo\">:0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>scoped穿透规则：外层 穿透符号 第三方组件样式/全局样式</p>\n<h2 id=\"样式穿透的其它方法\"><a href=\"#样式穿透的其它方法\" class=\"headerlink\" title=\"样式穿透的其它方法\"></a>样式穿透的其它方法</h2><p>1、在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里。</p>\n<p>2、建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入。</p>\n","site":{"data":{}},"excerpt":"<p>在Vue文件中的style标签上有一个特殊的属性——scoped。当一个style标签拥有scoped属性时候，它的css样式只能作用于当前的Vue组件。有了这个属性，可以使Vue组件的样式相互不被污染。这就相当于实现了样式的模块化。</p>","more":"<h2 id=\"scoped的实现原理\"><a href=\"#scoped的实现原理\" class=\"headerlink\" title=\"scoped的实现原理\"></a>scoped的实现原理</h2><p>Vue中的scoped属性的效果主要是通过PostCss实现的。</p>\n<p>转译前的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\">  .example &#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example\"</span>&gt;</span>scoped属性例子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>转译后的代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.example[data-v-5558831a] &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example\"</span> <span class=\"attr\">data-v-5558831a</span>&gt;</span>scoped属性例子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>PostCSS给一个组件中样式对应的dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。</p>\n<p>scoped的渲染规则：</p>\n<p>1、给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素。</p>\n<p>2、在每个css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式。</p>\n<h2 id=\"scoped样式穿透\"><a href=\"#scoped样式穿透\" class=\"headerlink\" title=\"scoped样式穿透\"></a>scoped样式穿透</h2><p>scoped在Vue组件中实现了样式的模块化，但同时也带来了一些问题——修改全局样式。当时在Vue项目中，当我们引入第三方组件库时，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。</p>\n<p>stylus预处理语言的样式穿透， 使用：&gt;&gt;&gt;</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &gt;&gt;&gt; <span class=\"selector-class\">.el-button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>sass和less预处理语言的样式穿透，使用：/deep/</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.wrapper /deep/ .el-button &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-radius</span><span class=\"selector-pseudo\">:0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>scoped穿透规则：外层 穿透符号 第三方组件样式/全局样式</p>\n<h2 id=\"样式穿透的其它方法\"><a href=\"#样式穿透的其它方法\" class=\"headerlink\" title=\"样式穿透的其它方法\"></a>样式穿透的其它方法</h2><p>1、在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里。</p>\n<p>2、建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入。</p>"},{"title":"比较var、let、const的区别","date":"2018-10-27T16:00:00.000Z","toc":false,"comments":0,"_content":"\n在前端开发工作中，JavaScript 语言是其核心语言。JavaScript 是一门动态弱类型语言，为什么是动态弱类型语言？这是因为 JavaScript 在声明变量时无需严格指定变量类型，且在变量的使用中可以随时显示或隐式变换类型。因此，理解其变量声明语句是非常基础以及非常重要的。而最常用的声明变量关键字是 var,在ES6版本中新增了let和const声明。\n\n<!--more-->\n\n## var声明与变量提升\n\n### 描述\n\n变量声明，无论发生在何处，都应在执行任何代码之前进行处理。用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。\n\n将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。\n```js\nfunction foo() {\n  a = 1;   // 在严格模式（strict mode）下会抛出ReferenceError异常。\n  var b = 2;\n}\n\nfoo();\n\nconsole.log(a); // 打印\"1\" 。\nconsole.log(b); // 抛出ReferenceError: b未在foo外部声明。\n```\n\n### 变量提升\n\n由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明自动的移动到函数或者全局代码的开头位置。\n```js\na = 2\nvar a;\n// ...\n\n// 可以理解为：\n\nvar a;\na = 2;\n```\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上解决。\n\n变量提升将影响变量声明，但不会影响其值的初始化。当到达赋值语句时，该值依然可以被分配：\n```js\nfunction foo() {\n  console.log(bar); // undefined，此处bar未声明\n  var bar = 111;\n  console.log(bar); // 111，此时bar已被声明，并以赋值，值111成功被分配给bar\n}\n\n// 相当于: \nfunction do_something() {\n  var bar;\n  console.log(bar); // undefined，bar已声明但未分配值。\n  bar = 111;\n  console.log(bar); // 111\n}\n```\n\n## let声明与块作用域\n\n### 描述\n\nES6中引入了块作用域，而let则作为声明块作用域的关键字。let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的。\n\nlet声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。\n```js\n// var声明\nfunction foo() {\n  var x = 1;\n  if (true) {\n    var x = 2;  // x是同一个变量!\n    console.log(x);  // 2\n  }\n  console.log(x);  // 2\n}\n\n// let声明\nfunction foo() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // x是两个不同的变量\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n```\n\n### 用let简化函数代码\n\n当用到内部函数的时候，let能起到简化代码的作用。\n```js\nvar ul = document.getElementById(\"ul\");\n\nfor (let i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  let j = i;\n  item.onclick = function (e) {\n    console.log(\"Item \" + j + \" is clicked.\");\n  };\n  ul.appendChild(item);\n}\n```\n上面这段代码的作用是为ul元素创建5个li，点击不同的li能够打印出当前li的序号。如果不用let，而改用var的话，将总是打印出 Item 5 is Clicked，因为 j 是函数级变量，5个内部函数都指向了同一个 j ,而 j 最后一次赋值是5。用了let后，j 变成块级域（也就是花括号中的块，每进入一次花括号就生成了一个块级域）,所以 5 个内部函数指向了不同的 j 。在ES6出来之前，由于没有块作用域的概念，因此我们常常用闭包解决，增加了函数的复杂度。\n\n### 用let模仿私有接口\n\n在面向对象编程中处理构造函数的时候，可以通过let声明而不是闭包来创建私有接口。\n\n```js\nvar Person;\n      \n{\n  let privateScope = {}; // 私有变量\n  \n  Person = function () {\n    this.publicScope = 'foo';\n    privateScope.property = 'bar';\n  }\n  \n  Person.prototype.showPublic = function () {\n    console.log(this.publicScope);\n  }\n  \n  Person.prototype.showPrivate= function () {\n    console.log(privateScope.property);\n  }\n}\n\nvar newPerson = new Person();\n\nnewPerson.showPublic();  // foo\nnewPerson.showPrivate(); // bar\n\nconsole.log(privateScope.property); // error，privateScope为私用变量，外部无法访问\n```\n\n### let对比var\n\nlet的作用域是块，而var的作用域是整个函数。\n```js\nvar a = 5;  // 作用域是整个函数内部，整个函数内部都可以访问\nvar b = 10;\n\nif (a === 5) {\n  let a = 4; // 作用域为if块，if块之外无法访问\n  var b = 1; // 作用域是整个函数内部\n\n  console.log(a);  // 4，这是if块内的a，if块之外无法访问\n  console.log(b);  // 1\n} \n\nconsole.log(a); // 5, 这是函数内的a，整个函数内部都可以访问\nconsole.log(b); // 1\n```\n\n## const声明\n\n### 描述\n\n此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。\n\n一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。\n```js\n// 定义常量a并赋值7\nconst a = 7;\n\n// 尝试重新赋值会报错\na = 20;\n\n// 输出 7\nconsole.log(\"my favorite number is: \" + a);\n\n// 尝试重新声明会报错 \nconst a = 20;\n```\n\nconst声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。\n```javascript\nconst obj = {\n  a: 'foo',\n  b: 'bar'\n}\n\nobj.a = 'a';\nconsole.log(obj.a) // a，重新赋值成功\n\nobj = {}\nconsole.log(obj) // error，报错\n```\n\n## 总结\n\n综上所述，var声明的作用域是整个函数内部，var声明会自动提升到函数最前面；let声明和const声明的作用域都是块；var声明和let声明的变量可以重复赋值，而const声明的是常量，不可以重复赋值，但声明的变量是对象等引用内容的情况下，可以改变对象的内容。\n","source":"_posts/2018-10-28-比较var、let、const的区别.md","raw":"---\ntitle: 比较var、let、const的区别\ndate: 2018-10-28\ntoc: false\ncomments: false\ntags:\n    - 变量提升\n    - 块作用域\n    - 作用域\ncategories:\n    - JavaScript\n---\n\n在前端开发工作中，JavaScript 语言是其核心语言。JavaScript 是一门动态弱类型语言，为什么是动态弱类型语言？这是因为 JavaScript 在声明变量时无需严格指定变量类型，且在变量的使用中可以随时显示或隐式变换类型。因此，理解其变量声明语句是非常基础以及非常重要的。而最常用的声明变量关键字是 var,在ES6版本中新增了let和const声明。\n\n<!--more-->\n\n## var声明与变量提升\n\n### 描述\n\n变量声明，无论发生在何处，都应在执行任何代码之前进行处理。用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。\n\n将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。\n```js\nfunction foo() {\n  a = 1;   // 在严格模式（strict mode）下会抛出ReferenceError异常。\n  var b = 2;\n}\n\nfoo();\n\nconsole.log(a); // 打印\"1\" 。\nconsole.log(b); // 抛出ReferenceError: b未在foo外部声明。\n```\n\n### 变量提升\n\n由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明自动的移动到函数或者全局代码的开头位置。\n```js\na = 2\nvar a;\n// ...\n\n// 可以理解为：\n\nvar a;\na = 2;\n```\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上解决。\n\n变量提升将影响变量声明，但不会影响其值的初始化。当到达赋值语句时，该值依然可以被分配：\n```js\nfunction foo() {\n  console.log(bar); // undefined，此处bar未声明\n  var bar = 111;\n  console.log(bar); // 111，此时bar已被声明，并以赋值，值111成功被分配给bar\n}\n\n// 相当于: \nfunction do_something() {\n  var bar;\n  console.log(bar); // undefined，bar已声明但未分配值。\n  bar = 111;\n  console.log(bar); // 111\n}\n```\n\n## let声明与块作用域\n\n### 描述\n\nES6中引入了块作用域，而let则作为声明块作用域的关键字。let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的。\n\nlet声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。\n```js\n// var声明\nfunction foo() {\n  var x = 1;\n  if (true) {\n    var x = 2;  // x是同一个变量!\n    console.log(x);  // 2\n  }\n  console.log(x);  // 2\n}\n\n// let声明\nfunction foo() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // x是两个不同的变量\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n```\n\n### 用let简化函数代码\n\n当用到内部函数的时候，let能起到简化代码的作用。\n```js\nvar ul = document.getElementById(\"ul\");\n\nfor (let i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  let j = i;\n  item.onclick = function (e) {\n    console.log(\"Item \" + j + \" is clicked.\");\n  };\n  ul.appendChild(item);\n}\n```\n上面这段代码的作用是为ul元素创建5个li，点击不同的li能够打印出当前li的序号。如果不用let，而改用var的话，将总是打印出 Item 5 is Clicked，因为 j 是函数级变量，5个内部函数都指向了同一个 j ,而 j 最后一次赋值是5。用了let后，j 变成块级域（也就是花括号中的块，每进入一次花括号就生成了一个块级域）,所以 5 个内部函数指向了不同的 j 。在ES6出来之前，由于没有块作用域的概念，因此我们常常用闭包解决，增加了函数的复杂度。\n\n### 用let模仿私有接口\n\n在面向对象编程中处理构造函数的时候，可以通过let声明而不是闭包来创建私有接口。\n\n```js\nvar Person;\n      \n{\n  let privateScope = {}; // 私有变量\n  \n  Person = function () {\n    this.publicScope = 'foo';\n    privateScope.property = 'bar';\n  }\n  \n  Person.prototype.showPublic = function () {\n    console.log(this.publicScope);\n  }\n  \n  Person.prototype.showPrivate= function () {\n    console.log(privateScope.property);\n  }\n}\n\nvar newPerson = new Person();\n\nnewPerson.showPublic();  // foo\nnewPerson.showPrivate(); // bar\n\nconsole.log(privateScope.property); // error，privateScope为私用变量，外部无法访问\n```\n\n### let对比var\n\nlet的作用域是块，而var的作用域是整个函数。\n```js\nvar a = 5;  // 作用域是整个函数内部，整个函数内部都可以访问\nvar b = 10;\n\nif (a === 5) {\n  let a = 4; // 作用域为if块，if块之外无法访问\n  var b = 1; // 作用域是整个函数内部\n\n  console.log(a);  // 4，这是if块内的a，if块之外无法访问\n  console.log(b);  // 1\n} \n\nconsole.log(a); // 5, 这是函数内的a，整个函数内部都可以访问\nconsole.log(b); // 1\n```\n\n## const声明\n\n### 描述\n\n此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。\n\n一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。\n```js\n// 定义常量a并赋值7\nconst a = 7;\n\n// 尝试重新赋值会报错\na = 20;\n\n// 输出 7\nconsole.log(\"my favorite number is: \" + a);\n\n// 尝试重新声明会报错 \nconst a = 20;\n```\n\nconst声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。\n```javascript\nconst obj = {\n  a: 'foo',\n  b: 'bar'\n}\n\nobj.a = 'a';\nconsole.log(obj.a) // a，重新赋值成功\n\nobj = {}\nconsole.log(obj) // error，报错\n```\n\n## 总结\n\n综上所述，var声明的作用域是整个函数内部，var声明会自动提升到函数最前面；let声明和const声明的作用域都是块；var声明和let声明的变量可以重复赋值，而const声明的是常量，不可以重复赋值，但声明的变量是对象等引用内容的情况下，可以改变对象的内容。\n","slug":"2018-10-28-比较var、let、const的区别","published":1,"updated":"2019-07-26T02:55:55.945Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a4000tacqx4q5ybpud","content":"<p>在前端开发工作中，JavaScript 语言是其核心语言。JavaScript 是一门动态弱类型语言，为什么是动态弱类型语言？这是因为 JavaScript 在声明变量时无需严格指定变量类型，且在变量的使用中可以随时显示或隐式变换类型。因此，理解其变量声明语句是非常基础以及非常重要的。而最常用的声明变量关键字是 var,在ES6版本中新增了let和const声明。</p>\n<a id=\"more\"></a>\n<h2 id=\"var声明与变量提升\"><a href=\"#var声明与变量提升\" class=\"headerlink\" title=\"var声明与变量提升\"></a>var声明与变量提升</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>变量声明，无论发生在何处，都应在执行任何代码之前进行处理。用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。</p>\n<p>将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;   <span class=\"comment\">// 在严格模式（strict mode）下会抛出ReferenceError异常。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 打印\"1\" 。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 抛出ReferenceError: b未在foo外部声明。</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明自动的移动到函数或者全局代码的开头位置。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以理解为：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上解决。</p>\n<p>变量提升将影响变量声明，但不会影响其值的初始化。当到达赋值语句时，该值依然可以被分配：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// undefined，此处bar未声明</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bar = <span class=\"number\">111</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 111，此时bar已被声明，并以赋值，值111成功被分配给bar</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于: </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_something</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bar;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// undefined，bar已声明但未分配值。</span></span><br><span class=\"line\">  bar = <span class=\"number\">111</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 111</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"let声明与块作用域\"><a href=\"#let声明与块作用域\" class=\"headerlink\" title=\"let声明与块作用域\"></a>let声明与块作用域</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>ES6中引入了块作用域，而let则作为声明块作用域的关键字。let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的。</p>\n<p>let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;  <span class=\"comment\">// x是同一个变量!</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;  <span class=\"comment\">// x是两个不同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用let简化函数代码\"><a href=\"#用let简化函数代码\" class=\"headerlink\" title=\"用let简化函数代码\"></a>用let简化函数代码</h3><p>当用到内部函数的时候，let能起到简化代码的作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"ul\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ul.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码的作用是为ul元素创建5个li，点击不同的li能够打印出当前li的序号。如果不用let，而改用var的话，将总是打印出 Item 5 is Clicked，因为 j 是函数级变量，5个内部函数都指向了同一个 j ,而 j 最后一次赋值是5。用了let后，j 变成块级域（也就是花括号中的块，每进入一次花括号就生成了一个块级域）,所以 5 个内部函数指向了不同的 j 。在ES6出来之前，由于没有块作用域的概念，因此我们常常用闭包解决，增加了函数的复杂度。</p>\n<h3 id=\"用let模仿私有接口\"><a href=\"#用let模仿私有接口\" class=\"headerlink\" title=\"用let模仿私有接口\"></a>用let模仿私有接口</h3><p>在面向对象编程中处理构造函数的时候，可以通过let声明而不是闭包来创建私有接口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person;</span><br><span class=\"line\">      </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> privateScope = &#123;&#125;; <span class=\"comment\">// 私有变量</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.publicScope = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">    privateScope.property = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  Person.prototype.showPublic = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.publicScope);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  Person.prototype.showPrivate= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(privateScope.property);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newPerson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">newPerson.showPublic();  <span class=\"comment\">// foo</span></span><br><span class=\"line\">newPerson.showPrivate(); <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(privateScope.property); <span class=\"comment\">// error，privateScope为私用变量，外部无法访问</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"let对比var\"><a href=\"#let对比var\" class=\"headerlink\" title=\"let对比var\"></a>let对比var</h3><p>let的作用域是块，而var的作用域是整个函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;  <span class=\"comment\">// 作用域是整个函数内部，整个函数内部都可以访问</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a === <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">4</span>; <span class=\"comment\">// 作用域为if块，if块之外无法访问</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>; <span class=\"comment\">// 作用域是整个函数内部</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// 4，这是if块内的a，if块之外无法访问</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 5, 这是函数内的a，整个函数内部都可以访问</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"const声明\"><a href=\"#const声明\" class=\"headerlink\" title=\"const声明\"></a>const声明</h2><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。</p>\n<p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义常量a并赋值7</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新赋值会报错</span></span><br><span class=\"line\">a = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is: \"</span> + a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新声明会报错 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure></p>\n<p>const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">  b: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// a，重新赋值成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// error，报错</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上所述，var声明的作用域是整个函数内部，var声明会自动提升到函数最前面；let声明和const声明的作用域都是块；var声明和let声明的变量可以重复赋值，而const声明的是常量，不可以重复赋值，但声明的变量是对象等引用内容的情况下，可以改变对象的内容。</p>\n","site":{"data":{}},"excerpt":"<p>在前端开发工作中，JavaScript 语言是其核心语言。JavaScript 是一门动态弱类型语言，为什么是动态弱类型语言？这是因为 JavaScript 在声明变量时无需严格指定变量类型，且在变量的使用中可以随时显示或隐式变换类型。因此，理解其变量声明语句是非常基础以及非常重要的。而最常用的声明变量关键字是 var,在ES6版本中新增了let和const声明。</p>","more":"<h2 id=\"var声明与变量提升\"><a href=\"#var声明与变量提升\" class=\"headerlink\" title=\"var声明与变量提升\"></a>var声明与变量提升</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>变量声明，无论发生在何处，都应在执行任何代码之前进行处理。用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。</p>\n<p>将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;   <span class=\"comment\">// 在严格模式（strict mode）下会抛出ReferenceError异常。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 打印\"1\" 。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 抛出ReferenceError: b未在foo外部声明。</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明自动的移动到函数或者全局代码的开头位置。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以理解为：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上解决。</p>\n<p>变量提升将影响变量声明，但不会影响其值的初始化。当到达赋值语句时，该值依然可以被分配：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// undefined，此处bar未声明</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bar = <span class=\"number\">111</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 111，此时bar已被声明，并以赋值，值111成功被分配给bar</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于: </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_something</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bar;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// undefined，bar已声明但未分配值。</span></span><br><span class=\"line\">  bar = <span class=\"number\">111</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 111</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"let声明与块作用域\"><a href=\"#let声明与块作用域\" class=\"headerlink\" title=\"let声明与块作用域\"></a>let声明与块作用域</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>ES6中引入了块作用域，而let则作为声明块作用域的关键字。let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的。</p>\n<p>let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;  <span class=\"comment\">// x是同一个变量!</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;  <span class=\"comment\">// x是两个不同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用let简化函数代码\"><a href=\"#用let简化函数代码\" class=\"headerlink\" title=\"用let简化函数代码\"></a>用let简化函数代码</h3><p>当用到内部函数的时候，let能起到简化代码的作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"ul\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ul.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码的作用是为ul元素创建5个li，点击不同的li能够打印出当前li的序号。如果不用let，而改用var的话，将总是打印出 Item 5 is Clicked，因为 j 是函数级变量，5个内部函数都指向了同一个 j ,而 j 最后一次赋值是5。用了let后，j 变成块级域（也就是花括号中的块，每进入一次花括号就生成了一个块级域）,所以 5 个内部函数指向了不同的 j 。在ES6出来之前，由于没有块作用域的概念，因此我们常常用闭包解决，增加了函数的复杂度。</p>\n<h3 id=\"用let模仿私有接口\"><a href=\"#用let模仿私有接口\" class=\"headerlink\" title=\"用let模仿私有接口\"></a>用let模仿私有接口</h3><p>在面向对象编程中处理构造函数的时候，可以通过let声明而不是闭包来创建私有接口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person;</span><br><span class=\"line\">      </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> privateScope = &#123;&#125;; <span class=\"comment\">// 私有变量</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.publicScope = <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">    privateScope.property = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  Person.prototype.showPublic = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.publicScope);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  Person.prototype.showPrivate= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(privateScope.property);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newPerson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">newPerson.showPublic();  <span class=\"comment\">// foo</span></span><br><span class=\"line\">newPerson.showPrivate(); <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(privateScope.property); <span class=\"comment\">// error，privateScope为私用变量，外部无法访问</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"let对比var\"><a href=\"#let对比var\" class=\"headerlink\" title=\"let对比var\"></a>let对比var</h3><p>let的作用域是块，而var的作用域是整个函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;  <span class=\"comment\">// 作用域是整个函数内部，整个函数内部都可以访问</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a === <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">4</span>; <span class=\"comment\">// 作用域为if块，if块之外无法访问</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>; <span class=\"comment\">// 作用域是整个函数内部</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// 4，这是if块内的a，if块之外无法访问</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 5, 这是函数内的a，整个函数内部都可以访问</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"const声明\"><a href=\"#const声明\" class=\"headerlink\" title=\"const声明\"></a>const声明</h2><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。</p>\n<p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义常量a并赋值7</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新赋值会报错</span></span><br><span class=\"line\">a = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is: \"</span> + a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新声明会报错 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure></p>\n<p>const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">  b: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// a，重新赋值成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// error，报错</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上所述，var声明的作用域是整个函数内部，var声明会自动提升到函数最前面；let声明和const声明的作用域都是块；var声明和let声明的变量可以重复赋值，而const声明的是常量，不可以重复赋值，但声明的变量是对象等引用内容的情况下，可以改变对象的内容。</p>"},{"title":"前端JavaScript开发日常技巧","date":"2018-11-24T16:00:00.000Z","toc":false,"comments":0,"_content":"\n如果你是一个JavaScript新手或仅仅最近才在你的开发工作中接触它，你可能感到失望。所有的语言都有自己的怪癖————JavaScript也不例外，与其他语言相比JavaScript甚至是有过之而无不及。在这篇文章中，我将分享一些JavaScript的怪异行为和一些最常用的技巧，希望我能分享给你一些曾经令我头痛不已的经验。这不是一个完整列表——仅仅是一部分————但希望它让你看清这门语言的强大之处，可能曾经被你认为是障碍或者是你正在困惑的东西。\n\n<!--more-->\n\n## 真（true）和假（false)\n\nJavaScript并没有一开始就告诉你什么值被认为是真（true）或假（false)，这就是我曾经令我很头痛和困惑的事情。在开发中经常会遇到NaN、null、undefined这样的值，我不得不先对他们进行真（true）/假（false）的判断，然后再编写我需要处理的程序逻辑。但现在我已经能够轻松的觉解这类问题，因为我发现在JavaScript中被判定为假（false）的值只有一下几种：\n\n```javascript\n\nconst a = Boolean('');           // false\nconst b = Boolean(NaN);          // false\nconst c = Boolean(0);            // false\nconst d = Boolean(null);         // false\nconst e = Boolean(undefined);    // false\nconst f = Boolean(false);        // false\n\n```\n\n你完全可以测试他们，是否如我所说的那样会被认为是假（false），下面是一个测试函数：\n\n```javascript\n\n(function test () {\n  var array = [false, '', NaN, 0, null, undefined];\n  array.forEach(value => {\n    if (value) {\n      console.log(true);\n    } else {\n      console.log(false);\n    }\n  })\n})();\n\n```\n\n现在你只需要记住以上的几个为假（false）的值，其他的都为真（true）。\n\n## 相等判断\n\n在大多数语言里==比较运算符————值类型（或字符串）当有相同值是是相等的。引用类型相等需要有相同的引用。刚开始的我很惊讶为什么JavaScript有两个等值运算符：==和===。最初我的大部分代码都是用的==，所以我并不知道当我运行如下代码的时候JavaScript为我做了什么：\n\n```javascript\n\nconst a = 1;\n\nconsole.log(a == '1' ? true : false);   // true\n\n```\n\n最后的结果是真（true），这就是让我困惑的地方————数字1和字符串‘1’怎么会是相等的？\n\n在JavaScript中，有相等（==）和严格相等（===）之说。（==）运算符将强制转换两边的操作数为相同类型后执行严格相等比较。所以在上面的例子中，字符串‘1’会被转换为整数1，这个过程在幕后进行，然后与变量a进行比较。\n\n严格相等（===）不进行类型转换。如果操作数类型不同（如整数和字符串），那么他们不全等（严格相等）：\n\n```javascript\n\nconst a = 1;\n\nconsole.log(a === '1' ? true : false);   // false\n\n```\n\n你可能正在联想可能发生强制类型转换而引起的各种恐怖问题————假设你的引用中发生了这种转换，可能导致你非常困难找到问题出在哪里。这并不奇怪，这也是为什么经验丰富的JavaScript开发者总是建议使用严格相等（===）。所以我总是使用（===）判断两个值是否相等。\n\n## 三元表达式\n\n合理的使用三元表达式可以让你的代码看起来更简洁。在我的工作中，我通常使用三元表达式来消除一般的if...else语句。这样能使我的代码看起来更简洁，书写更高效。\n举个例子，大于18岁的人为成年人，小于18岁的为未成年人：\n\n```javascript\nconst age = 21;\nvar isAdults;\n\n// 使用if...else语句\nif (age >= 18) {\n  isAdults = true\n} else {\n  isAdults = false\n}\n\n// 使用三元表达式\nisAdults = age >= 18\n```\n很明显，上面的例子中三元表达式比if...else语句要简洁的多。\n\n我们还可以将例子的复杂度提高————大于40岁的称为中年人：\n\n```javascript\nconst age = 21;\nvar people;\n\n// 使用if...else语句\nif (age < 18) {\n  people = '未成年人';\n} else if (age < 40) {\n  people = '成年人';\n} else {\n  people = '中年人';\n}\n\n// 使用三元表达式\npeople = age < 18 ? '未成年人' : age < 40 ? '成年人' : '中年人'\n```\n\n## 使用 try...catch... 语句屏蔽错误\n\n频繁的报错会使网站的性能低下，影响用户体验。一般的小项目站点有一两处报错可能影响不大，可是一旦项目体量变大了呢，这时如果出现了站点报错，你应该去重视它并且解决它。在我的经验中，我能通常使用 try...catch... 语句屏蔽一些我不希望出现的错误。\n\n比如，我需要使用数组的map方法处理数组，因为我无法保证arr是不是数组，所以我使用 try...catch... 语句，如果arr不是数组会执行catch分支返回一个空数组。这样，代码就不会报错还能保证最后返回的一定是数组：\n\n```javascript\ntry {\n  return arr.map(item => {\n    // do something\n  })\n} catch (e) {\n  return []\n}\n```\ntry...catch... 语句是一把双刃剑，千万不要滥用它。滥用它的结果那就是————你的程序执行异常，但你却找不到错误发生在哪里。","source":"_posts/2018-11-25-前端JavaScript开发日常技巧.md","raw":"---\ntitle: 前端JavaScript开发日常技巧\ndate: 2018-11-25\ntoc: false\ncomments: false\ntags:\n    - JavaScript技巧\ncategories:\n    - JavaScript\n---\n\n如果你是一个JavaScript新手或仅仅最近才在你的开发工作中接触它，你可能感到失望。所有的语言都有自己的怪癖————JavaScript也不例外，与其他语言相比JavaScript甚至是有过之而无不及。在这篇文章中，我将分享一些JavaScript的怪异行为和一些最常用的技巧，希望我能分享给你一些曾经令我头痛不已的经验。这不是一个完整列表——仅仅是一部分————但希望它让你看清这门语言的强大之处，可能曾经被你认为是障碍或者是你正在困惑的东西。\n\n<!--more-->\n\n## 真（true）和假（false)\n\nJavaScript并没有一开始就告诉你什么值被认为是真（true）或假（false)，这就是我曾经令我很头痛和困惑的事情。在开发中经常会遇到NaN、null、undefined这样的值，我不得不先对他们进行真（true）/假（false）的判断，然后再编写我需要处理的程序逻辑。但现在我已经能够轻松的觉解这类问题，因为我发现在JavaScript中被判定为假（false）的值只有一下几种：\n\n```javascript\n\nconst a = Boolean('');           // false\nconst b = Boolean(NaN);          // false\nconst c = Boolean(0);            // false\nconst d = Boolean(null);         // false\nconst e = Boolean(undefined);    // false\nconst f = Boolean(false);        // false\n\n```\n\n你完全可以测试他们，是否如我所说的那样会被认为是假（false），下面是一个测试函数：\n\n```javascript\n\n(function test () {\n  var array = [false, '', NaN, 0, null, undefined];\n  array.forEach(value => {\n    if (value) {\n      console.log(true);\n    } else {\n      console.log(false);\n    }\n  })\n})();\n\n```\n\n现在你只需要记住以上的几个为假（false）的值，其他的都为真（true）。\n\n## 相等判断\n\n在大多数语言里==比较运算符————值类型（或字符串）当有相同值是是相等的。引用类型相等需要有相同的引用。刚开始的我很惊讶为什么JavaScript有两个等值运算符：==和===。最初我的大部分代码都是用的==，所以我并不知道当我运行如下代码的时候JavaScript为我做了什么：\n\n```javascript\n\nconst a = 1;\n\nconsole.log(a == '1' ? true : false);   // true\n\n```\n\n最后的结果是真（true），这就是让我困惑的地方————数字1和字符串‘1’怎么会是相等的？\n\n在JavaScript中，有相等（==）和严格相等（===）之说。（==）运算符将强制转换两边的操作数为相同类型后执行严格相等比较。所以在上面的例子中，字符串‘1’会被转换为整数1，这个过程在幕后进行，然后与变量a进行比较。\n\n严格相等（===）不进行类型转换。如果操作数类型不同（如整数和字符串），那么他们不全等（严格相等）：\n\n```javascript\n\nconst a = 1;\n\nconsole.log(a === '1' ? true : false);   // false\n\n```\n\n你可能正在联想可能发生强制类型转换而引起的各种恐怖问题————假设你的引用中发生了这种转换，可能导致你非常困难找到问题出在哪里。这并不奇怪，这也是为什么经验丰富的JavaScript开发者总是建议使用严格相等（===）。所以我总是使用（===）判断两个值是否相等。\n\n## 三元表达式\n\n合理的使用三元表达式可以让你的代码看起来更简洁。在我的工作中，我通常使用三元表达式来消除一般的if...else语句。这样能使我的代码看起来更简洁，书写更高效。\n举个例子，大于18岁的人为成年人，小于18岁的为未成年人：\n\n```javascript\nconst age = 21;\nvar isAdults;\n\n// 使用if...else语句\nif (age >= 18) {\n  isAdults = true\n} else {\n  isAdults = false\n}\n\n// 使用三元表达式\nisAdults = age >= 18\n```\n很明显，上面的例子中三元表达式比if...else语句要简洁的多。\n\n我们还可以将例子的复杂度提高————大于40岁的称为中年人：\n\n```javascript\nconst age = 21;\nvar people;\n\n// 使用if...else语句\nif (age < 18) {\n  people = '未成年人';\n} else if (age < 40) {\n  people = '成年人';\n} else {\n  people = '中年人';\n}\n\n// 使用三元表达式\npeople = age < 18 ? '未成年人' : age < 40 ? '成年人' : '中年人'\n```\n\n## 使用 try...catch... 语句屏蔽错误\n\n频繁的报错会使网站的性能低下，影响用户体验。一般的小项目站点有一两处报错可能影响不大，可是一旦项目体量变大了呢，这时如果出现了站点报错，你应该去重视它并且解决它。在我的经验中，我能通常使用 try...catch... 语句屏蔽一些我不希望出现的错误。\n\n比如，我需要使用数组的map方法处理数组，因为我无法保证arr是不是数组，所以我使用 try...catch... 语句，如果arr不是数组会执行catch分支返回一个空数组。这样，代码就不会报错还能保证最后返回的一定是数组：\n\n```javascript\ntry {\n  return arr.map(item => {\n    // do something\n  })\n} catch (e) {\n  return []\n}\n```\ntry...catch... 语句是一把双刃剑，千万不要滥用它。滥用它的结果那就是————你的程序执行异常，但你却找不到错误发生在哪里。","slug":"2018-11-25-前端JavaScript开发日常技巧","published":1,"updated":"2019-07-26T02:54:47.678Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a5000xacqxnekzjq2u","content":"<p>如果你是一个JavaScript新手或仅仅最近才在你的开发工作中接触它，你可能感到失望。所有的语言都有自己的怪癖————JavaScript也不例外，与其他语言相比JavaScript甚至是有过之而无不及。在这篇文章中，我将分享一些JavaScript的怪异行为和一些最常用的技巧，希望我能分享给你一些曾经令我头痛不已的经验。这不是一个完整列表——仅仅是一部分————但希望它让你看清这门语言的强大之处，可能曾经被你认为是障碍或者是你正在困惑的东西。</p>\n<a id=\"more\"></a>\n<h2 id=\"真（true）和假（false\"><a href=\"#真（true）和假（false\" class=\"headerlink\" title=\"真（true）和假（false)\"></a>真（true）和假（false)</h2><p>JavaScript并没有一开始就告诉你什么值被认为是真（true）或假（false)，这就是我曾经令我很头痛和困惑的事情。在开发中经常会遇到NaN、null、undefined这样的值，我不得不先对他们进行真（true）/假（false）的判断，然后再编写我需要处理的程序逻辑。但现在我已经能够轻松的觉解这类问题，因为我发现在JavaScript中被判定为假（false）的值只有一下几种：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Boolean</span>(<span class=\"string\">''</span>);           <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>);          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>);            <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);        <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>你完全可以测试他们，是否如我所说的那样会被认为是假（false），下面是一个测试函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = [<span class=\"literal\">false</span>, <span class=\"string\">''</span>, <span class=\"literal\">NaN</span>, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\">  array.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>现在你只需要记住以上的几个为假（false）的值，其他的都为真（true）。</p>\n<h2 id=\"相等判断\"><a href=\"#相等判断\" class=\"headerlink\" title=\"相等判断\"></a>相等判断</h2><p>在大多数语言里==比较运算符————值类型（或字符串）当有相同值是是相等的。引用类型相等需要有相同的引用。刚开始的我很惊讶为什么JavaScript有两个等值运算符：==和===。最初我的大部分代码都是用的==，所以我并不知道当我运行如下代码的时候JavaScript为我做了什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a == <span class=\"string\">'1'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>);   <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>最后的结果是真（true），这就是让我困惑的地方————数字1和字符串‘1’怎么会是相等的？</p>\n<p>在JavaScript中，有相等（==）和严格相等（===）之说。（==）运算符将强制转换两边的操作数为相同类型后执行严格相等比较。所以在上面的例子中，字符串‘1’会被转换为整数1，这个过程在幕后进行，然后与变量a进行比较。</p>\n<p>严格相等（===）不进行类型转换。如果操作数类型不同（如整数和字符串），那么他们不全等（严格相等）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === <span class=\"string\">'1'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>你可能正在联想可能发生强制类型转换而引起的各种恐怖问题————假设你的引用中发生了这种转换，可能导致你非常困难找到问题出在哪里。这并不奇怪，这也是为什么经验丰富的JavaScript开发者总是建议使用严格相等（===）。所以我总是使用（===）判断两个值是否相等。</p>\n<h2 id=\"三元表达式\"><a href=\"#三元表达式\" class=\"headerlink\" title=\"三元表达式\"></a>三元表达式</h2><p>合理的使用三元表达式可以让你的代码看起来更简洁。在我的工作中，我通常使用三元表达式来消除一般的if…else语句。这样能使我的代码看起来更简洁，书写更高效。<br>举个例子，大于18岁的人为成年人，小于18岁的为未成年人：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> isAdults;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用if...else语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &gt;= <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">  isAdults = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  isAdults = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用三元表达式</span></span><br><span class=\"line\">isAdults = age &gt;= <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n<p>很明显，上面的例子中三元表达式比if…else语句要简洁的多。</p>\n<p>我们还可以将例子的复杂度提高————大于40岁的称为中年人：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> people;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用if...else语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'未成年人'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">40</span>) &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'成年人'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'中年人'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用三元表达式</span></span><br><span class=\"line\">people = age &lt; <span class=\"number\">18</span> ? <span class=\"string\">'未成年人'</span> : age &lt; <span class=\"number\">40</span> ? <span class=\"string\">'成年人'</span> : <span class=\"string\">'中年人'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-try…catch…-语句屏蔽错误\"><a href=\"#使用-try…catch…-语句屏蔽错误\" class=\"headerlink\" title=\"使用 try…catch… 语句屏蔽错误\"></a>使用 try…catch… 语句屏蔽错误</h2><p>频繁的报错会使网站的性能低下，影响用户体验。一般的小项目站点有一两处报错可能影响不大，可是一旦项目体量变大了呢，这时如果出现了站点报错，你应该去重视它并且解决它。在我的经验中，我能通常使用 try…catch… 语句屏蔽一些我不希望出现的错误。</p>\n<p>比如，我需要使用数组的map方法处理数组，因为我无法保证arr是不是数组，所以我使用 try…catch… 语句，如果arr不是数组会执行catch分支返回一个空数组。这样，代码就不会报错还能保证最后返回的一定是数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>try…catch… 语句是一把双刃剑，千万不要滥用它。滥用它的结果那就是————你的程序执行异常，但你却找不到错误发生在哪里。</p>\n","site":{"data":{}},"excerpt":"<p>如果你是一个JavaScript新手或仅仅最近才在你的开发工作中接触它，你可能感到失望。所有的语言都有自己的怪癖————JavaScript也不例外，与其他语言相比JavaScript甚至是有过之而无不及。在这篇文章中，我将分享一些JavaScript的怪异行为和一些最常用的技巧，希望我能分享给你一些曾经令我头痛不已的经验。这不是一个完整列表——仅仅是一部分————但希望它让你看清这门语言的强大之处，可能曾经被你认为是障碍或者是你正在困惑的东西。</p>","more":"<h2 id=\"真（true）和假（false\"><a href=\"#真（true）和假（false\" class=\"headerlink\" title=\"真（true）和假（false)\"></a>真（true）和假（false)</h2><p>JavaScript并没有一开始就告诉你什么值被认为是真（true）或假（false)，这就是我曾经令我很头痛和困惑的事情。在开发中经常会遇到NaN、null、undefined这样的值，我不得不先对他们进行真（true）/假（false）的判断，然后再编写我需要处理的程序逻辑。但现在我已经能够轻松的觉解这类问题，因为我发现在JavaScript中被判定为假（false）的值只有一下几种：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Boolean</span>(<span class=\"string\">''</span>);           <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>);          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>);            <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);        <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>你完全可以测试他们，是否如我所说的那样会被认为是假（false），下面是一个测试函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = [<span class=\"literal\">false</span>, <span class=\"string\">''</span>, <span class=\"literal\">NaN</span>, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\">  array.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>现在你只需要记住以上的几个为假（false）的值，其他的都为真（true）。</p>\n<h2 id=\"相等判断\"><a href=\"#相等判断\" class=\"headerlink\" title=\"相等判断\"></a>相等判断</h2><p>在大多数语言里==比较运算符————值类型（或字符串）当有相同值是是相等的。引用类型相等需要有相同的引用。刚开始的我很惊讶为什么JavaScript有两个等值运算符：==和===。最初我的大部分代码都是用的==，所以我并不知道当我运行如下代码的时候JavaScript为我做了什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a == <span class=\"string\">'1'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>);   <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>最后的结果是真（true），这就是让我困惑的地方————数字1和字符串‘1’怎么会是相等的？</p>\n<p>在JavaScript中，有相等（==）和严格相等（===）之说。（==）运算符将强制转换两边的操作数为相同类型后执行严格相等比较。所以在上面的例子中，字符串‘1’会被转换为整数1，这个过程在幕后进行，然后与变量a进行比较。</p>\n<p>严格相等（===）不进行类型转换。如果操作数类型不同（如整数和字符串），那么他们不全等（严格相等）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === <span class=\"string\">'1'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>你可能正在联想可能发生强制类型转换而引起的各种恐怖问题————假设你的引用中发生了这种转换，可能导致你非常困难找到问题出在哪里。这并不奇怪，这也是为什么经验丰富的JavaScript开发者总是建议使用严格相等（===）。所以我总是使用（===）判断两个值是否相等。</p>\n<h2 id=\"三元表达式\"><a href=\"#三元表达式\" class=\"headerlink\" title=\"三元表达式\"></a>三元表达式</h2><p>合理的使用三元表达式可以让你的代码看起来更简洁。在我的工作中，我通常使用三元表达式来消除一般的if…else语句。这样能使我的代码看起来更简洁，书写更高效。<br>举个例子，大于18岁的人为成年人，小于18岁的为未成年人：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> isAdults;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用if...else语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &gt;= <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">  isAdults = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  isAdults = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用三元表达式</span></span><br><span class=\"line\">isAdults = age &gt;= <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n<p>很明显，上面的例子中三元表达式比if…else语句要简洁的多。</p>\n<p>我们还可以将例子的复杂度提高————大于40岁的称为中年人：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> people;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用if...else语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'未成年人'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">40</span>) &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'成年人'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  people = <span class=\"string\">'中年人'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用三元表达式</span></span><br><span class=\"line\">people = age &lt; <span class=\"number\">18</span> ? <span class=\"string\">'未成年人'</span> : age &lt; <span class=\"number\">40</span> ? <span class=\"string\">'成年人'</span> : <span class=\"string\">'中年人'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-try…catch…-语句屏蔽错误\"><a href=\"#使用-try…catch…-语句屏蔽错误\" class=\"headerlink\" title=\"使用 try…catch… 语句屏蔽错误\"></a>使用 try…catch… 语句屏蔽错误</h2><p>频繁的报错会使网站的性能低下，影响用户体验。一般的小项目站点有一两处报错可能影响不大，可是一旦项目体量变大了呢，这时如果出现了站点报错，你应该去重视它并且解决它。在我的经验中，我能通常使用 try…catch… 语句屏蔽一些我不希望出现的错误。</p>\n<p>比如，我需要使用数组的map方法处理数组，因为我无法保证arr是不是数组，所以我使用 try…catch… 语句，如果arr不是数组会执行catch分支返回一个空数组。这样，代码就不会报错还能保证最后返回的一定是数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>try…catch… 语句是一把双刃剑，千万不要滥用它。滥用它的结果那就是————你的程序执行异常，但你却找不到错误发生在哪里。</p>"},{"title":"设置placeholder样式及隐藏IE浏览器input元素的删除和查看密码图标","date":"2018-04-22T16:00:00.000Z","toc":false,"comments":0,"_content":"\n如何设置placeholder样式？IE浏览器input元素的删除和查看密码图标？\n\n<!--more-->\n\n## 设置placeholder样式\n\n在做项目的时候，一般表单元素的placeholder属性样式都是使用浏览器默认的，但有时候为了追求设计上的美感需要修表单元素的placeholder样式（也有可能是遇到了一个处女座的设计师或者是客户），就不等不修改一下placeholder的样式。可以通过下面的代码修改样式：\n```css\n/*Chrome、Safari等 webkit内核浏览器*/\n::-webkit-input-placeholder{\n  color:red;\n}\n            \n/*Firefox*/\n::-moz-placeholder{\n  color:red;\n}\n            \n/*IE、Edge等 Trident 内核浏览器*/\n:-ms-input-placeholder{\n  color:red;\n}\n```\n\n## 隐藏IE浏览器input元素的删除和查看密码图标\n\n在IE、Edge等 Trident 内核浏览器中，type = “text” 的 input元素中有输入时会出现清除图标，type = “password” 的 input元素中有输入时会出现眼睛图标。添加下面的样式可以去除默认图标：\n```css\n::-ms-clear, \n::-ms-reveal{\n  display: none;\n}\n```","source":"_posts/2018-04-23-设置placeholder样式及隐藏IE浏览器input元素的删除和查看密码图标.md","raw":"---\ntitle: 设置placeholder样式及隐藏IE浏览器input元素的删除和查看密码图标\ndate: 2018-04-23\ntoc: false\ncomments: false\ntags:\n    - 设置placeholder样式\n    - 设置input样式\ncategories:\n    - CSS\n---\n\n如何设置placeholder样式？IE浏览器input元素的删除和查看密码图标？\n\n<!--more-->\n\n## 设置placeholder样式\n\n在做项目的时候，一般表单元素的placeholder属性样式都是使用浏览器默认的，但有时候为了追求设计上的美感需要修表单元素的placeholder样式（也有可能是遇到了一个处女座的设计师或者是客户），就不等不修改一下placeholder的样式。可以通过下面的代码修改样式：\n```css\n/*Chrome、Safari等 webkit内核浏览器*/\n::-webkit-input-placeholder{\n  color:red;\n}\n            \n/*Firefox*/\n::-moz-placeholder{\n  color:red;\n}\n            \n/*IE、Edge等 Trident 内核浏览器*/\n:-ms-input-placeholder{\n  color:red;\n}\n```\n\n## 隐藏IE浏览器input元素的删除和查看密码图标\n\n在IE、Edge等 Trident 内核浏览器中，type = “text” 的 input元素中有输入时会出现清除图标，type = “password” 的 input元素中有输入时会出现眼睛图标。添加下面的样式可以去除默认图标：\n```css\n::-ms-clear, \n::-ms-reveal{\n  display: none;\n}\n```","slug":"2018-04-23-设置placeholder样式及隐藏IE浏览器input元素的删除和查看密码图标","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a6000zacqxj6dyfa8o","content":"<p>如何设置placeholder样式？IE浏览器input元素的删除和查看密码图标？</p>\n<a id=\"more\"></a>\n<h2 id=\"设置placeholder样式\"><a href=\"#设置placeholder样式\" class=\"headerlink\" title=\"设置placeholder样式\"></a>设置placeholder样式</h2><p>在做项目的时候，一般表单元素的placeholder属性样式都是使用浏览器默认的，但有时候为了追求设计上的美感需要修表单元素的placeholder样式（也有可能是遇到了一个处女座的设计师或者是客户），就不等不修改一下placeholder的样式。可以通过下面的代码修改样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*Chrome、Safari等 webkit内核浏览器*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">/*Firefox*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">::-moz-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">/*IE、Edge等 Trident 内核浏览器*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">:-ms-input-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"隐藏IE浏览器input元素的删除和查看密码图标\"><a href=\"#隐藏IE浏览器input元素的删除和查看密码图标\" class=\"headerlink\" title=\"隐藏IE浏览器input元素的删除和查看密码图标\"></a>隐藏IE浏览器input元素的删除和查看密码图标</h2><p>在IE、Edge等 Trident 内核浏览器中，type = “text” 的 input元素中有输入时会出现清除图标，type = “password” 的 input元素中有输入时会出现眼睛图标。添加下面的样式可以去除默认图标：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-ms-clear</span>, </span><br><span class=\"line\"><span class=\"selector-pseudo\">::-ms-reveal</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>如何设置placeholder样式？IE浏览器input元素的删除和查看密码图标？</p>","more":"<h2 id=\"设置placeholder样式\"><a href=\"#设置placeholder样式\" class=\"headerlink\" title=\"设置placeholder样式\"></a>设置placeholder样式</h2><p>在做项目的时候，一般表单元素的placeholder属性样式都是使用浏览器默认的，但有时候为了追求设计上的美感需要修表单元素的placeholder样式（也有可能是遇到了一个处女座的设计师或者是客户），就不等不修改一下placeholder的样式。可以通过下面的代码修改样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*Chrome、Safari等 webkit内核浏览器*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">/*Firefox*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">::-moz-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">/*IE、Edge等 Trident 内核浏览器*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">:-ms-input-placeholder</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"隐藏IE浏览器input元素的删除和查看密码图标\"><a href=\"#隐藏IE浏览器input元素的删除和查看密码图标\" class=\"headerlink\" title=\"隐藏IE浏览器input元素的删除和查看密码图标\"></a>隐藏IE浏览器input元素的删除和查看密码图标</h2><p>在IE、Edge等 Trident 内核浏览器中，type = “text” 的 input元素中有输入时会出现清除图标，type = “password” 的 input元素中有输入时会出现眼睛图标。添加下面的样式可以去除默认图标：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-ms-clear</span>, </span><br><span class=\"line\"><span class=\"selector-pseudo\">::-ms-reveal</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"使用SVG symbols建立图标系统完整指南","date":"2019-07-20T16:00:00.000Z","toc":false,"comments":0,"_content":"\n从最开始的使用img图片，到后来的使用css sprite来减少服务器请求，再到流行的图形字体化图标Iconfont。现在，一种全新的图标使用方式开始流行了起来——SVG symbols图标。\n\n<!--more-->\n\n## 工作原理\n\nSVG symbols的工作原理：symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。\n\nsymbol元素对图形的作用是在同一文档中多次使用，symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的use元素）才能呈现：\n```html\n<svg>\n  <symbol viewBox=\"0 0 24 24\" id=\"heart\">\n    <path fill=\"#E86C60\" d=\"M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z\">\n    </path>\n  </symbol>\n  <symbol viewBox=\"0 0 32 32\" id=\"arrow\">\n    <path fill=\"#0f0f0f\" d=\"M16,0C7.2,0,0,7.2,0,16s7.2,16,16,16s16-7.2,16-16S24.8,0,16,0z M22.8,13.6l-6,8C16.6,21.9,16.3,22,16,22 s-0.6-0.1-0.8-0.4l-6-8c-0.2-0.3-0.3-0.7-0.1-1S9.6,12,10,12h12c0.4,0,0.7,0.2,0.9,0.6S23,13.3,22.8,13.6z\">\n    </path>\n  </symbol>\n</svg>\n```\n这段代码使用SVG symbols定义了两个图标，每个symbol元素定义一个图标，图标id分别是heart和arrow，将其放在html文件的body元素内。\n\n通过以下代码引用id为heart的图标：\n```html\n<svg>\n    <use xlink:href=\"#heart\"/>\n</svg>\n```\nxlink:href属性值就是‘#’加symbol的id名称，那么只需改变这个属性值就可以引用不同的图标。\n\n## gulp自动化处理\n\n如果你使用gulp构建项目，推荐使用一个专门用于处理SVG Symbols用的glup插件[gulp-svg-symbols](https://github.com/Hiswe/gulp-svg-symbols)，它不但能生成SVG Symbols文件，还能生成一个demo文件方便查看图标和复制代码。\n\n安装gulp-svg-symbols插件，若没有预先安装gulp请先行安装:\n```\nnpm install gulp-svg-symbols  --save-dev\n```\n\ngulpfile.js写入如下执行任务：\n```js\nconst gulp = require('gulp')\nconst svgSymbols = require('gulp-svg-symbols')\n\ngulp.task(`sprites`, function() {\n  return gulp\n    .src(`assets/svg/*.svg`)\n    .pipe(svgSymbols())\n    .pipe(gulp.dest(`assets`))\n})\n```\n现在生成SVG symbols文件了，那怎么将它引入到页面呢？如果是多页应用推荐使用[svg4everybody.js](https://www.npmjs.com/package/svg4everybody)为所有浏览器添加了SVG外部内容支持。这样就能直接使用外部的SVG symbols文件。\n\n在文档中包含该脚本：\n```html\n<script src=\"/path/to/svg4everybody.js\"></script>\n<script>svg4everybody(); // run it now or whenever you are ready</script> \n```\n\n使用外部的SVG symbols文件时，通过以下代码引用图标（map.svg是外部的SVG symbols文件，codepen是图标id）：\n```html\n<svg>\n  <use xlink:href=\"map.svg#codepen\"/>\n</svg>\n```\n\n如果是单页应用，使用svg4everybody.js就感觉太繁琐了，能不能一步搞定啊？当然可以，将将SVG symbols文件转成js文件就好了，推荐使用[gulp-svg-symbols2js](https://www.npmjs.com/package/gulp-svg-symbols2js)将SVG symbols文件转成js文件。\n\n安装gulp-svg-symbols2js插件：\n```\nnpm install gulp-svg-symbols2js --save-dev\n```\n\n修改gulpfile.js文件：\n```js\nconst gulp = require('gulp')\nconst svgSymbols = require('gulp-svg-symbols')\nconst svgSymbols2js = require('gulp-svg-symbols2js');\n\ngulp.task(`sprites`, function() {\n  return gulp\n    .src(`assets/svg/*.svg`)\n    .pipe(svgSymbols())\n    .pipe(svgSymbols2js())\n    .pipe(gulp.dest(`assets`))\n})\n```\n\n现在只要引入生成的js文件，就可以在页面中使用以下代码引用图标：\n```html\n<svg>\n  <use xlink:href=\"#codepen\"/>\n</svg>\n```\n\n## webpack自动化处理\n\n如果你的项目使用webpack进行打包，可以考虑使用[svg-sprite-loader](https://github.com/kisenka/svg-sprite-loader)插件自动生成SVG symbols文件。\n\n安装svg-sprite-loader:\n```\nnpm install svg-sprite-loader --save-dev\n```\n\n将svg图标放到src/icons目录下，在webpack配置文件中添加svg-sprite-loader的配置：\n```js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/,\n        loader: 'svg-sprite-loader',\n        include: [path.resolve(__dirname, 'src/icons')], // 仅处理src/icons目录下的svg文件\n        options: {\n          symbolId: 'icon-[name]'\n        }\n      }\n    ]\n  }\n}\n```\n\n在打包文件（index.js）中引入单个图标：\n```js\nimport cloud from './icons/cloud.svg'\n```\n这样引入的好处是只引入需要的图标，没引入的图标不会被打包，缺点是当图标很多时这样引入会显得很繁琐，因为一般情况下，所有图标都会被使用，所以有必要找到一种简单的方式一次引入所有图标。\n\n使用一些代码将svg图标全部引入：\n```js\nconst requireAll = requireContext => requireContext.keys().map(requireContext);\nconst req = require.context('./icons', true, /\\.svg$/);\nrequireAll(req);\n```\n\n现在可以在HTML中使用图标了：\n```html\n<svg>\n  <use xlink:href=\"#icon-cloud\" />\n</svg>\n```\n\n## 经验总结和建议\n\n* 始终使用gulp构建，方便浏览的图标demo在开发中很重要\n* 始终使用单色图标，多色图标只能通过id选择器修改样式\n* 始终在ie9+，及现代浏览器使用，传统浏览器使用iconfont更好\n\n","source":"_posts/2019-07-21-使用SVG symbols建立图标系统完整指南.md","raw":"---\ntitle: 使用SVG symbols建立图标系统完整指南\ndate: 2019-07-21\ntoc: false\ncomments: false\ntags:\n    - web图标\n    - symbols\n    - webpack\n    - gulp\ncategories:\n    - SVG\n---\n\n从最开始的使用img图片，到后来的使用css sprite来减少服务器请求，再到流行的图形字体化图标Iconfont。现在，一种全新的图标使用方式开始流行了起来——SVG symbols图标。\n\n<!--more-->\n\n## 工作原理\n\nSVG symbols的工作原理：symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。\n\nsymbol元素对图形的作用是在同一文档中多次使用，symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的use元素）才能呈现：\n```html\n<svg>\n  <symbol viewBox=\"0 0 24 24\" id=\"heart\">\n    <path fill=\"#E86C60\" d=\"M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z\">\n    </path>\n  </symbol>\n  <symbol viewBox=\"0 0 32 32\" id=\"arrow\">\n    <path fill=\"#0f0f0f\" d=\"M16,0C7.2,0,0,7.2,0,16s7.2,16,16,16s16-7.2,16-16S24.8,0,16,0z M22.8,13.6l-6,8C16.6,21.9,16.3,22,16,22 s-0.6-0.1-0.8-0.4l-6-8c-0.2-0.3-0.3-0.7-0.1-1S9.6,12,10,12h12c0.4,0,0.7,0.2,0.9,0.6S23,13.3,22.8,13.6z\">\n    </path>\n  </symbol>\n</svg>\n```\n这段代码使用SVG symbols定义了两个图标，每个symbol元素定义一个图标，图标id分别是heart和arrow，将其放在html文件的body元素内。\n\n通过以下代码引用id为heart的图标：\n```html\n<svg>\n    <use xlink:href=\"#heart\"/>\n</svg>\n```\nxlink:href属性值就是‘#’加symbol的id名称，那么只需改变这个属性值就可以引用不同的图标。\n\n## gulp自动化处理\n\n如果你使用gulp构建项目，推荐使用一个专门用于处理SVG Symbols用的glup插件[gulp-svg-symbols](https://github.com/Hiswe/gulp-svg-symbols)，它不但能生成SVG Symbols文件，还能生成一个demo文件方便查看图标和复制代码。\n\n安装gulp-svg-symbols插件，若没有预先安装gulp请先行安装:\n```\nnpm install gulp-svg-symbols  --save-dev\n```\n\ngulpfile.js写入如下执行任务：\n```js\nconst gulp = require('gulp')\nconst svgSymbols = require('gulp-svg-symbols')\n\ngulp.task(`sprites`, function() {\n  return gulp\n    .src(`assets/svg/*.svg`)\n    .pipe(svgSymbols())\n    .pipe(gulp.dest(`assets`))\n})\n```\n现在生成SVG symbols文件了，那怎么将它引入到页面呢？如果是多页应用推荐使用[svg4everybody.js](https://www.npmjs.com/package/svg4everybody)为所有浏览器添加了SVG外部内容支持。这样就能直接使用外部的SVG symbols文件。\n\n在文档中包含该脚本：\n```html\n<script src=\"/path/to/svg4everybody.js\"></script>\n<script>svg4everybody(); // run it now or whenever you are ready</script> \n```\n\n使用外部的SVG symbols文件时，通过以下代码引用图标（map.svg是外部的SVG symbols文件，codepen是图标id）：\n```html\n<svg>\n  <use xlink:href=\"map.svg#codepen\"/>\n</svg>\n```\n\n如果是单页应用，使用svg4everybody.js就感觉太繁琐了，能不能一步搞定啊？当然可以，将将SVG symbols文件转成js文件就好了，推荐使用[gulp-svg-symbols2js](https://www.npmjs.com/package/gulp-svg-symbols2js)将SVG symbols文件转成js文件。\n\n安装gulp-svg-symbols2js插件：\n```\nnpm install gulp-svg-symbols2js --save-dev\n```\n\n修改gulpfile.js文件：\n```js\nconst gulp = require('gulp')\nconst svgSymbols = require('gulp-svg-symbols')\nconst svgSymbols2js = require('gulp-svg-symbols2js');\n\ngulp.task(`sprites`, function() {\n  return gulp\n    .src(`assets/svg/*.svg`)\n    .pipe(svgSymbols())\n    .pipe(svgSymbols2js())\n    .pipe(gulp.dest(`assets`))\n})\n```\n\n现在只要引入生成的js文件，就可以在页面中使用以下代码引用图标：\n```html\n<svg>\n  <use xlink:href=\"#codepen\"/>\n</svg>\n```\n\n## webpack自动化处理\n\n如果你的项目使用webpack进行打包，可以考虑使用[svg-sprite-loader](https://github.com/kisenka/svg-sprite-loader)插件自动生成SVG symbols文件。\n\n安装svg-sprite-loader:\n```\nnpm install svg-sprite-loader --save-dev\n```\n\n将svg图标放到src/icons目录下，在webpack配置文件中添加svg-sprite-loader的配置：\n```js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/,\n        loader: 'svg-sprite-loader',\n        include: [path.resolve(__dirname, 'src/icons')], // 仅处理src/icons目录下的svg文件\n        options: {\n          symbolId: 'icon-[name]'\n        }\n      }\n    ]\n  }\n}\n```\n\n在打包文件（index.js）中引入单个图标：\n```js\nimport cloud from './icons/cloud.svg'\n```\n这样引入的好处是只引入需要的图标，没引入的图标不会被打包，缺点是当图标很多时这样引入会显得很繁琐，因为一般情况下，所有图标都会被使用，所以有必要找到一种简单的方式一次引入所有图标。\n\n使用一些代码将svg图标全部引入：\n```js\nconst requireAll = requireContext => requireContext.keys().map(requireContext);\nconst req = require.context('./icons', true, /\\.svg$/);\nrequireAll(req);\n```\n\n现在可以在HTML中使用图标了：\n```html\n<svg>\n  <use xlink:href=\"#icon-cloud\" />\n</svg>\n```\n\n## 经验总结和建议\n\n* 始终使用gulp构建，方便浏览的图标demo在开发中很重要\n* 始终使用单色图标，多色图标只能通过id选择器修改样式\n* 始终在ie9+，及现代浏览器使用，传统浏览器使用iconfont更好\n\n","slug":"2019-07-21-使用SVG symbols建立图标系统完整指南","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a80013acqxv75s3h09","content":"<p>从最开始的使用img图片，到后来的使用css sprite来减少服务器请求，再到流行的图形字体化图标Iconfont。现在，一种全新的图标使用方式开始流行了起来——SVG symbols图标。</p>\n<a id=\"more\"></a>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>SVG symbols的工作原理：symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。</p>\n<p>symbol元素对图形的作用是在同一文档中多次使用，symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的use元素）才能呈现：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 24 24\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"heart\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"#E86C60\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 32 32\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"arrow\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"#0f0f0f\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M16,0C7.2,0,0,7.2,0,16s7.2,16,16,16s16-7.2,16-16S24.8,0,16,0z M22.8,13.6l-6,8C16.6,21.9,16.3,22,16,22 s-0.6-0.1-0.8-0.4l-6-8c-0.2-0.3-0.3-0.7-0.1-1S9.6,12,10,12h12c0.4,0,0.7,0.2,0.9,0.6S23,13.3,22.8,13.6z\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码使用SVG symbols定义了两个图标，每个symbol元素定义一个图标，图标id分别是heart和arrow，将其放在html文件的body元素内。</p>\n<p>通过以下代码引用id为heart的图标：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#heart\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>xlink:href属性值就是‘#’加symbol的id名称，那么只需改变这个属性值就可以引用不同的图标。</p>\n<h2 id=\"gulp自动化处理\"><a href=\"#gulp自动化处理\" class=\"headerlink\" title=\"gulp自动化处理\"></a>gulp自动化处理</h2><p>如果你使用gulp构建项目，推荐使用一个专门用于处理SVG Symbols用的glup插件<a href=\"https://github.com/Hiswe/gulp-svg-symbols\" target=\"_blank\" rel=\"noopener\">gulp-svg-symbols</a>，它不但能生成SVG Symbols文件，还能生成一个demo文件方便查看图标和复制代码。</p>\n<p>安装gulp-svg-symbols插件，若没有预先安装gulp请先行安装:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-svg-symbols  --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>gulpfile.js写入如下执行任务：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">`sprites`</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp</span><br><span class=\"line\">    .src(<span class=\"string\">`assets/svg/*.svg`</span>)</span><br><span class=\"line\">    .pipe(svgSymbols())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">`assets`</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在生成SVG symbols文件了，那怎么将它引入到页面呢？如果是多页应用推荐使用<a href=\"https://www.npmjs.com/package/svg4everybody\" target=\"_blank\" rel=\"noopener\">svg4everybody.js</a>为所有浏览器添加了SVG外部内容支持。这样就能直接使用外部的SVG symbols文件。</p>\n<p>在文档中包含该脚本：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/path/to/svg4everybody.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">svg4everybody(); <span class=\"comment\">// run it now or whenever you are ready</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用外部的SVG symbols文件时，通过以下代码引用图标（map.svg是外部的SVG symbols文件，codepen是图标id）：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"map.svg#codepen\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果是单页应用，使用svg4everybody.js就感觉太繁琐了，能不能一步搞定啊？当然可以，将将SVG symbols文件转成js文件就好了，推荐使用<a href=\"https://www.npmjs.com/package/gulp-svg-symbols2js\" target=\"_blank\" rel=\"noopener\">gulp-svg-symbols2js</a>将SVG symbols文件转成js文件。</p>\n<p>安装gulp-svg-symbols2js插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-svg-symbols2js --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>修改gulpfile.js文件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols2js = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols2js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">`sprites`</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp</span><br><span class=\"line\">    .src(<span class=\"string\">`assets/svg/*.svg`</span>)</span><br><span class=\"line\">    .pipe(svgSymbols())</span><br><span class=\"line\">    .pipe(svgSymbols2js())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">`assets`</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在只要引入生成的js文件，就可以在页面中使用以下代码引用图标：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#codepen\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"webpack自动化处理\"><a href=\"#webpack自动化处理\" class=\"headerlink\" title=\"webpack自动化处理\"></a>webpack自动化处理</h2><p>如果你的项目使用webpack进行打包，可以考虑使用<a href=\"https://github.com/kisenka/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a>插件自动生成SVG symbols文件。</p>\n<p>安装svg-sprite-loader:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install svg-sprite-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>将svg图标放到src/icons目录下，在webpack配置文件中添加svg-sprite-loader的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.svg$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'svg-sprite-loader'</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src/icons'</span>)], <span class=\"comment\">// 仅处理src/icons目录下的svg文件</span></span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          symbolId: <span class=\"string\">'icon-[name]'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在打包文件（index.js）中引入单个图标：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cloud <span class=\"keyword\">from</span> <span class=\"string\">'./icons/cloud.svg'</span></span><br></pre></td></tr></table></figure></p>\n<p>这样引入的好处是只引入需要的图标，没引入的图标不会被打包，缺点是当图标很多时这样引入会显得很繁琐，因为一般情况下，所有图标都会被使用，所以有必要找到一种简单的方式一次引入所有图标。</p>\n<p>使用一些代码将svg图标全部引入：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> requireAll = <span class=\"function\"><span class=\"params\">requireContext</span> =&gt;</span> requireContext.keys().map(requireContext);</span><br><span class=\"line\"><span class=\"keyword\">const</span> req = <span class=\"built_in\">require</span>.context(<span class=\"string\">'./icons'</span>, <span class=\"literal\">true</span>, /\\.svg$/);</span><br><span class=\"line\">requireAll(req);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以在HTML中使用图标了：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#icon-cloud\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"经验总结和建议\"><a href=\"#经验总结和建议\" class=\"headerlink\" title=\"经验总结和建议\"></a>经验总结和建议</h2><ul>\n<li>始终使用gulp构建，方便浏览的图标demo在开发中很重要</li>\n<li>始终使用单色图标，多色图标只能通过id选择器修改样式</li>\n<li>始终在ie9+，及现代浏览器使用，传统浏览器使用iconfont更好</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>从最开始的使用img图片，到后来的使用css sprite来减少服务器请求，再到流行的图形字体化图标Iconfont。现在，一种全新的图标使用方式开始流行了起来——SVG symbols图标。</p>","more":"<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>SVG symbols的工作原理：symbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。</p>\n<p>symbol元素对图形的作用是在同一文档中多次使用，symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的use元素）才能呈现：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 24 24\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"heart\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"#E86C60\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 32 32\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"arrow\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"#0f0f0f\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M16,0C7.2,0,0,7.2,0,16s7.2,16,16,16s16-7.2,16-16S24.8,0,16,0z M22.8,13.6l-6,8C16.6,21.9,16.3,22,16,22 s-0.6-0.1-0.8-0.4l-6-8c-0.2-0.3-0.3-0.7-0.1-1S9.6,12,10,12h12c0.4,0,0.7,0.2,0.9,0.6S23,13.3,22.8,13.6z\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码使用SVG symbols定义了两个图标，每个symbol元素定义一个图标，图标id分别是heart和arrow，将其放在html文件的body元素内。</p>\n<p>通过以下代码引用id为heart的图标：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#heart\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>xlink:href属性值就是‘#’加symbol的id名称，那么只需改变这个属性值就可以引用不同的图标。</p>\n<h2 id=\"gulp自动化处理\"><a href=\"#gulp自动化处理\" class=\"headerlink\" title=\"gulp自动化处理\"></a>gulp自动化处理</h2><p>如果你使用gulp构建项目，推荐使用一个专门用于处理SVG Symbols用的glup插件<a href=\"https://github.com/Hiswe/gulp-svg-symbols\" target=\"_blank\" rel=\"noopener\">gulp-svg-symbols</a>，它不但能生成SVG Symbols文件，还能生成一个demo文件方便查看图标和复制代码。</p>\n<p>安装gulp-svg-symbols插件，若没有预先安装gulp请先行安装:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-svg-symbols  --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>gulpfile.js写入如下执行任务：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">`sprites`</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp</span><br><span class=\"line\">    .src(<span class=\"string\">`assets/svg/*.svg`</span>)</span><br><span class=\"line\">    .pipe(svgSymbols())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">`assets`</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在生成SVG symbols文件了，那怎么将它引入到页面呢？如果是多页应用推荐使用<a href=\"https://www.npmjs.com/package/svg4everybody\" target=\"_blank\" rel=\"noopener\">svg4everybody.js</a>为所有浏览器添加了SVG外部内容支持。这样就能直接使用外部的SVG symbols文件。</p>\n<p>在文档中包含该脚本：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/path/to/svg4everybody.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">svg4everybody(); <span class=\"comment\">// run it now or whenever you are ready</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用外部的SVG symbols文件时，通过以下代码引用图标（map.svg是外部的SVG symbols文件，codepen是图标id）：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"map.svg#codepen\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果是单页应用，使用svg4everybody.js就感觉太繁琐了，能不能一步搞定啊？当然可以，将将SVG symbols文件转成js文件就好了，推荐使用<a href=\"https://www.npmjs.com/package/gulp-svg-symbols2js\" target=\"_blank\" rel=\"noopener\">gulp-svg-symbols2js</a>将SVG symbols文件转成js文件。</p>\n<p>安装gulp-svg-symbols2js插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-svg-symbols2js --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>修改gulpfile.js文件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> svgSymbols2js = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-svg-symbols2js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">`sprites`</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp</span><br><span class=\"line\">    .src(<span class=\"string\">`assets/svg/*.svg`</span>)</span><br><span class=\"line\">    .pipe(svgSymbols())</span><br><span class=\"line\">    .pipe(svgSymbols2js())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">`assets`</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在只要引入生成的js文件，就可以在页面中使用以下代码引用图标：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#codepen\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"webpack自动化处理\"><a href=\"#webpack自动化处理\" class=\"headerlink\" title=\"webpack自动化处理\"></a>webpack自动化处理</h2><p>如果你的项目使用webpack进行打包，可以考虑使用<a href=\"https://github.com/kisenka/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a>插件自动生成SVG symbols文件。</p>\n<p>安装svg-sprite-loader:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install svg-sprite-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>将svg图标放到src/icons目录下，在webpack配置文件中添加svg-sprite-loader的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.svg$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'svg-sprite-loader'</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src/icons'</span>)], <span class=\"comment\">// 仅处理src/icons目录下的svg文件</span></span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          symbolId: <span class=\"string\">'icon-[name]'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在打包文件（index.js）中引入单个图标：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cloud <span class=\"keyword\">from</span> <span class=\"string\">'./icons/cloud.svg'</span></span><br></pre></td></tr></table></figure></p>\n<p>这样引入的好处是只引入需要的图标，没引入的图标不会被打包，缺点是当图标很多时这样引入会显得很繁琐，因为一般情况下，所有图标都会被使用，所以有必要找到一种简单的方式一次引入所有图标。</p>\n<p>使用一些代码将svg图标全部引入：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> requireAll = <span class=\"function\"><span class=\"params\">requireContext</span> =&gt;</span> requireContext.keys().map(requireContext);</span><br><span class=\"line\"><span class=\"keyword\">const</span> req = <span class=\"built_in\">require</span>.context(<span class=\"string\">'./icons'</span>, <span class=\"literal\">true</span>, /\\.svg$/);</span><br><span class=\"line\">requireAll(req);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以在HTML中使用图标了：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#icon-cloud\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"经验总结和建议\"><a href=\"#经验总结和建议\" class=\"headerlink\" title=\"经验总结和建议\"></a>经验总结和建议</h2><ul>\n<li>始终使用gulp构建，方便浏览的图标demo在开发中很重要</li>\n<li>始终使用单色图标，多色图标只能通过id选择器修改样式</li>\n<li>始终在ie9+，及现代浏览器使用，传统浏览器使用iconfont更好</li>\n</ul>"},{"title":"使用 Webpack 与 Babel 配置 ES6 开发环境","date":"2019-03-10T16:00:00.000Z","toc":false,"comments":0,"_content":"\nWebpack 和 Babel 几乎是现在前端开发必备的工具，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，Babel 是一个 ES6 编译器，由于目前浏览器对 ES6 的兼容性有差异，无法直接在项目中使用 ES6，需要使用 Babel 编译器转换成 ES5 才能在浏览器中运行。使用 Webpack 和 Babel 也开发了几个项目，使用时间少说也有两三年了，本文就讲解一下使用 Webpack 与 Babel 配置 ES6 开发环境。\n\n<!--more-->\n\n## 安装 Webpack\n\n安装：\n```\n# 本地安装\n$ npm install --save-dev webpack webpack-cli\n\n# 全局安装\n$ npm install -g webpack webpack-cli\n```\n\n在项目根目录下新建一个配置文件—— webpack.config.js 文件：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n```\n\n在 src 目录下新建 a.js 文件：\n```javascript\nexport const isNull = val => val === null\n\nexport const unique = arr => [...new Set(arr)]\n```\n\n在 src 目录下新建 index.js 文件：\n```javascript\nimport { isNull, unique } from './a.js'\n\nconst arr = [1, 1, 2, 3]\n\nconsole.log(unique(arr))\nconsole.log(isNull(arr))\n```\n\n执行编译打包命令，完成后打开 bundle.js 文件发现 isNull 和 unique 两个函数没有被编译，和 webpack 官方说法一致：webpack 默认支持 ES6 模块语法，要编译 ES6 代码依然需要 babel 编译器。\n\n## 安装配置 Babel 编译器\n\n使用 Babel 必须先安装 @babel/core 和 @babel/preset-env 两个模块，其中 @babel/core 是 Babel 的核心存在，Babel 的核心 api 都在这个模块里面，比如：transform。而 @babel/preset-env 是一个智能预设，允许您使用最新的 JavaScript，而无需微观管理您的目标环境需要哪些语法转换（以及可选的浏览器polyfill）。因为这里使用的打包工具是 Webpack，所以还需要安装 babel-loader 插件。\n\n安装：\n```\n$ npm install --save-dev @babel/core @babel/preset-env babel-loader\n```\n\n新建 .babelrc 文件：\n```json\n{\n  \"presets\": [\n    \"@babel/preset-env\"\n  ]\n}\n```\n\n修改 webpack 配置文件（webpack.config.js）：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n      }\n    ]\n  }\n}\n```\n\n由于 babel 默认只转换 ES6 新语法，不转换新的 API，如：Set、Map、Promise等，所以需要安装 @babel/polyfill 转换新 API。安装 @babel/plugin-transform-runtime 优化代码，@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序代码来节省代码的插件。\n\n安装 @babel/polyfill、@babel/plugin-transform-runtime 两个插件：\n```\n$ npm install --save-dev @babel/polyfill @babel/plugin-transform-runtime\n```\n\n修改 .babelrc 配置文件：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\", // 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。\n      \"modules\": false // 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n\n最后，配置兼容的浏览器环境。在 .babelrc 配置文件中设置 targets 属性：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\",\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": \"last 2 versions, not ie <= 9\"\n      }\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n\n执行命令编译代码，完成后检查 bundle.js 文件，是否成功转换新 API 。如果发现以下代码即说明转换成功：\n```javascript\n// 23.2 Set Objects\nmodule.exports = __webpack_require__(80)(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n```\n\n其他关于 js 压缩和 Webpack 启用 tree shaking 功能的设置本文不在赘述。\n\n## 配置文件详情概览\n\npackage.json 文件：\n```javascript\n{\n  \"name\": \"demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"webpack\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.3.4\",\n    \"@babel/plugin-transform-runtime\": \"^7.3.4\",\n    \"@babel/polyfill\": \"^7.2.5\",\n    \"@babel/preset-env\": \"^7.3.4\",\n    \"babel-loader\": \"^8.0.5\",\n    \"webpack\": \"^4.29.6\",\n    \"webpack-cli\": \"^3.2.3\"\n  }\n}\n```\n\nwebpack.config.js 文件：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n      }\n    ]\n  }\n}\n```\n\n.babelrc 文件：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\",\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": \"last 2 versions, not ie <= 9\"\n      }\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n","source":"_posts/2019-03-11-使用 Webpack 与 Babel 配置 ES6 开发环境.md","raw":"---\ntitle: 使用 Webpack 与 Babel 配置 ES6 开发环境\ndate: 2019-03-11\ntoc: false\ncomments: false\ntags:\n    - Webpack\n    - Babel\n    - ES6\n    - 搭建ES6开发环境\ncategories:\n    - 前端构建工具\n---\n\nWebpack 和 Babel 几乎是现在前端开发必备的工具，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，Babel 是一个 ES6 编译器，由于目前浏览器对 ES6 的兼容性有差异，无法直接在项目中使用 ES6，需要使用 Babel 编译器转换成 ES5 才能在浏览器中运行。使用 Webpack 和 Babel 也开发了几个项目，使用时间少说也有两三年了，本文就讲解一下使用 Webpack 与 Babel 配置 ES6 开发环境。\n\n<!--more-->\n\n## 安装 Webpack\n\n安装：\n```\n# 本地安装\n$ npm install --save-dev webpack webpack-cli\n\n# 全局安装\n$ npm install -g webpack webpack-cli\n```\n\n在项目根目录下新建一个配置文件—— webpack.config.js 文件：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n```\n\n在 src 目录下新建 a.js 文件：\n```javascript\nexport const isNull = val => val === null\n\nexport const unique = arr => [...new Set(arr)]\n```\n\n在 src 目录下新建 index.js 文件：\n```javascript\nimport { isNull, unique } from './a.js'\n\nconst arr = [1, 1, 2, 3]\n\nconsole.log(unique(arr))\nconsole.log(isNull(arr))\n```\n\n执行编译打包命令，完成后打开 bundle.js 文件发现 isNull 和 unique 两个函数没有被编译，和 webpack 官方说法一致：webpack 默认支持 ES6 模块语法，要编译 ES6 代码依然需要 babel 编译器。\n\n## 安装配置 Babel 编译器\n\n使用 Babel 必须先安装 @babel/core 和 @babel/preset-env 两个模块，其中 @babel/core 是 Babel 的核心存在，Babel 的核心 api 都在这个模块里面，比如：transform。而 @babel/preset-env 是一个智能预设，允许您使用最新的 JavaScript，而无需微观管理您的目标环境需要哪些语法转换（以及可选的浏览器polyfill）。因为这里使用的打包工具是 Webpack，所以还需要安装 babel-loader 插件。\n\n安装：\n```\n$ npm install --save-dev @babel/core @babel/preset-env babel-loader\n```\n\n新建 .babelrc 文件：\n```json\n{\n  \"presets\": [\n    \"@babel/preset-env\"\n  ]\n}\n```\n\n修改 webpack 配置文件（webpack.config.js）：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n      }\n    ]\n  }\n}\n```\n\n由于 babel 默认只转换 ES6 新语法，不转换新的 API，如：Set、Map、Promise等，所以需要安装 @babel/polyfill 转换新 API。安装 @babel/plugin-transform-runtime 优化代码，@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序代码来节省代码的插件。\n\n安装 @babel/polyfill、@babel/plugin-transform-runtime 两个插件：\n```\n$ npm install --save-dev @babel/polyfill @babel/plugin-transform-runtime\n```\n\n修改 .babelrc 配置文件：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\", // 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。\n      \"modules\": false // 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n\n最后，配置兼容的浏览器环境。在 .babelrc 配置文件中设置 targets 属性：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\",\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": \"last 2 versions, not ie <= 9\"\n      }\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n\n执行命令编译代码，完成后检查 bundle.js 文件，是否成功转换新 API 。如果发现以下代码即说明转换成功：\n```javascript\n// 23.2 Set Objects\nmodule.exports = __webpack_require__(80)(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n```\n\n其他关于 js 压缩和 Webpack 启用 tree shaking 功能的设置本文不在赘述。\n\n## 配置文件详情概览\n\npackage.json 文件：\n```javascript\n{\n  \"name\": \"demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"webpack\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.3.4\",\n    \"@babel/plugin-transform-runtime\": \"^7.3.4\",\n    \"@babel/polyfill\": \"^7.2.5\",\n    \"@babel/preset-env\": \"^7.3.4\",\n    \"babel-loader\": \"^8.0.5\",\n    \"webpack\": \"^4.29.6\",\n    \"webpack-cli\": \"^3.2.3\"\n  }\n}\n```\n\nwebpack.config.js 文件：\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n      }\n    ]\n  }\n}\n```\n\n.babelrc 文件：\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"useBuiltIns\": \"usage\",\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": \"last 2 versions, not ie <= 9\"\n      }\n    }]\n  ],\n  \"plugins\": [\n    [\"@babel/plugin-transform-runtime\", {\n      \"helpers\": false\n    }]\n  ]\n}\n```\n","slug":"2019-03-11-使用 Webpack 与 Babel 配置 ES6 开发环境","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4a90016acqxiz52stc9","content":"<p>Webpack 和 Babel 几乎是现在前端开发必备的工具，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，Babel 是一个 ES6 编译器，由于目前浏览器对 ES6 的兼容性有差异，无法直接在项目中使用 ES6，需要使用 Babel 编译器转换成 ES5 才能在浏览器中运行。使用 Webpack 和 Babel 也开发了几个项目，使用时间少说也有两三年了，本文就讲解一下使用 Webpack 与 Babel 配置 ES6 开发环境。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装-Webpack\"><a href=\"#安装-Webpack\" class=\"headerlink\" title=\"安装 Webpack\"></a>安装 Webpack</h2><p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 本地安装</span><br><span class=\"line\">$ npm install --save-dev webpack webpack-cli</span><br><span class=\"line\"></span><br><span class=\"line\"># 全局安装</span><br><span class=\"line\">$ npm install -g webpack webpack-cli</span><br></pre></td></tr></table></figure></p>\n<p>在项目根目录下新建一个配置文件—— webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下新建 a.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> isNull = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val === <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)]</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下新建 index.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isNull, unique &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isNull(arr))</span><br></pre></td></tr></table></figure></p>\n<p>执行编译打包命令，完成后打开 bundle.js 文件发现 isNull 和 unique 两个函数没有被编译，和 webpack 官方说法一致：webpack 默认支持 ES6 模块语法，要编译 ES6 代码依然需要 babel 编译器。</p>\n<h2 id=\"安装配置-Babel-编译器\"><a href=\"#安装配置-Babel-编译器\" class=\"headerlink\" title=\"安装配置 Babel 编译器\"></a>安装配置 Babel 编译器</h2><p>使用 Babel 必须先安装 @babel/core 和 @babel/preset-env 两个模块，其中 @babel/core 是 Babel 的核心存在，Babel 的核心 api 都在这个模块里面，比如：transform。而 @babel/preset-env 是一个智能预设，允许您使用最新的 JavaScript，而无需微观管理您的目标环境需要哪些语法转换（以及可选的浏览器polyfill）。因为这里使用的打包工具是 Webpack，所以还需要安装 babel-loader 插件。</p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/core @babel/preset-env babel-loader</span><br></pre></td></tr></table></figure></p>\n<p>新建 .babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-env\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改 webpack 配置文件（webpack.config.js）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于 babel 默认只转换 ES6 新语法，不转换新的 API，如：Set、Map、Promise等，所以需要安装 @babel/polyfill 转换新 API。安装 @babel/plugin-transform-runtime 优化代码，@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序代码来节省代码的插件。</p>\n<p>安装 @babel/polyfill、@babel/plugin-transform-runtime 两个插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/polyfill @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure></p>\n<p>修改 .babelrc 配置文件：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      \"useBuiltIns\": \"usage\", // 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。</span><br><span class=\"line\">      \"modules\": false // 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  \"plugins\": [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，配置兼容的浏览器环境。在 .babelrc 配置文件中设置 targets 属性：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"useBuiltIns\"</span>: <span class=\"string\">\"usage\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"targets\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, not ie &lt;= 9\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行命令编译代码，完成后检查 bundle.js 文件，是否成功转换新 API 。如果发现以下代码即说明转换成功：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 23.2 Set Objects</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = __webpack_require__(<span class=\"number\">80</span>)(SET, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">get</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">get</span>(this, arguments.length &gt; 0 ? arguments[0] : undefined); &#125;;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 23.2.3.1 Set.prototype.add(value)</span></span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strong.def(validate(<span class=\"keyword\">this</span>, SET), value = value === <span class=\"number\">0</span> ? <span class=\"number\">0</span> : value, value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, strong);</span><br></pre></td></tr></table></figure></p>\n<p>其他关于 js 压缩和 Webpack 启用 tree shaking 功能的设置本文不在赘述。</p>\n<h2 id=\"配置文件详情概览\"><a href=\"#配置文件详情概览\" class=\"headerlink\" title=\"配置文件详情概览\"></a>配置文件详情概览</h2><p>package.json 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"demo\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"description\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"keywords\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"@babel/core\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/plugin-transform-runtime\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/polyfill\"</span>: <span class=\"string\">\"^7.2.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-env\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-loader\"</span>: <span class=\"string\">\"^8.0.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^4.29.6\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.2.3\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"useBuiltIns\"</span>: <span class=\"string\">\"usage\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"targets\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, not ie &lt;= 9\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Webpack 和 Babel 几乎是现在前端开发必备的工具，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，Babel 是一个 ES6 编译器，由于目前浏览器对 ES6 的兼容性有差异，无法直接在项目中使用 ES6，需要使用 Babel 编译器转换成 ES5 才能在浏览器中运行。使用 Webpack 和 Babel 也开发了几个项目，使用时间少说也有两三年了，本文就讲解一下使用 Webpack 与 Babel 配置 ES6 开发环境。</p>","more":"<h2 id=\"安装-Webpack\"><a href=\"#安装-Webpack\" class=\"headerlink\" title=\"安装 Webpack\"></a>安装 Webpack</h2><p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 本地安装</span><br><span class=\"line\">$ npm install --save-dev webpack webpack-cli</span><br><span class=\"line\"></span><br><span class=\"line\"># 全局安装</span><br><span class=\"line\">$ npm install -g webpack webpack-cli</span><br></pre></td></tr></table></figure></p>\n<p>在项目根目录下新建一个配置文件—— webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下新建 a.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> isNull = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val === <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)]</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下新建 index.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isNull, unique &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./a.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isNull(arr))</span><br></pre></td></tr></table></figure></p>\n<p>执行编译打包命令，完成后打开 bundle.js 文件发现 isNull 和 unique 两个函数没有被编译，和 webpack 官方说法一致：webpack 默认支持 ES6 模块语法，要编译 ES6 代码依然需要 babel 编译器。</p>\n<h2 id=\"安装配置-Babel-编译器\"><a href=\"#安装配置-Babel-编译器\" class=\"headerlink\" title=\"安装配置 Babel 编译器\"></a>安装配置 Babel 编译器</h2><p>使用 Babel 必须先安装 @babel/core 和 @babel/preset-env 两个模块，其中 @babel/core 是 Babel 的核心存在，Babel 的核心 api 都在这个模块里面，比如：transform。而 @babel/preset-env 是一个智能预设，允许您使用最新的 JavaScript，而无需微观管理您的目标环境需要哪些语法转换（以及可选的浏览器polyfill）。因为这里使用的打包工具是 Webpack，所以还需要安装 babel-loader 插件。</p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/core @babel/preset-env babel-loader</span><br></pre></td></tr></table></figure></p>\n<p>新建 .babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-env\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改 webpack 配置文件（webpack.config.js）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于 babel 默认只转换 ES6 新语法，不转换新的 API，如：Set、Map、Promise等，所以需要安装 @babel/polyfill 转换新 API。安装 @babel/plugin-transform-runtime 优化代码，@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序代码来节省代码的插件。</p>\n<p>安装 @babel/polyfill、@babel/plugin-transform-runtime 两个插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/polyfill @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure></p>\n<p>修改 .babelrc 配置文件：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      \"useBuiltIns\": \"usage\", // 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。</span><br><span class=\"line\">      \"modules\": false // 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  \"plugins\": [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，配置兼容的浏览器环境。在 .babelrc 配置文件中设置 targets 属性：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"useBuiltIns\"</span>: <span class=\"string\">\"usage\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"targets\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, not ie &lt;= 9\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行命令编译代码，完成后检查 bundle.js 文件，是否成功转换新 API 。如果发现以下代码即说明转换成功：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 23.2 Set Objects</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = __webpack_require__(<span class=\"number\">80</span>)(SET, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">get</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">get</span>(this, arguments.length &gt; 0 ? arguments[0] : undefined); &#125;;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 23.2.3.1 Set.prototype.add(value)</span></span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strong.def(validate(<span class=\"keyword\">this</span>, SET), value = value === <span class=\"number\">0</span> ? <span class=\"number\">0</span> : value, value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, strong);</span><br></pre></td></tr></table></figure></p>\n<p>其他关于 js 压缩和 Webpack 启用 tree shaking 功能的设置本文不在赘述。</p>\n<h2 id=\"配置文件详情概览\"><a href=\"#配置文件详情概览\" class=\"headerlink\" title=\"配置文件详情概览\"></a>配置文件详情概览</h2><p>package.json 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"demo\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"description\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"keywords\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"@babel/core\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/plugin-transform-runtime\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/polyfill\"</span>: <span class=\"string\">\"^7.2.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-env\"</span>: <span class=\"string\">\"^7.3.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-loader\"</span>: <span class=\"string\">\"^8.0.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^4.29.6\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.2.3\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/preset-env\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"useBuiltIns\"</span>: <span class=\"string\">\"usage\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"targets\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, not ie &lt;= 9\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"helpers\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"gulp + gulp-better-rollup + rollup 构建 ES6 开发环境","date":"2019-04-27T16:00:00.000Z","toc":false,"comments":0,"_content":"\n关于 [Gulp](https://www.gulpjs.com.cn/) 就不过多啰嗦了。常用的 js 模块打包工具主要有 [webpack](https://www.webpackjs.com/)、[rollup](https://www.rollupjs.com/guide/zh) 和 [browserify](http://browserify.org/) 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 [gulp-better-rollup](https://www.npmjs.com/package/gulp-better-rollup) 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。\n\nGitHub地址：[https://github.com/JofunLiang/gulp-translation-es6-demo](https://github.com/JofunLiang/gulp-translation-es6-demo)\n\n<!--more-->\n\n## 构建基础的 ES6 语法转译环境\n\n首先，安装 gulp 工具，命令如下：\n```\n$ npm install --save-dev gulp\n```\n\n安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：\n```\n$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel\n```\n\n安装 babel 核心插件:\n```\n$ npm install --save-dev @babel/core @babel/preset-env\n```\n\n安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。\n\n新建 .babelrc 配置文件如下：\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/env\",\n      {\n        \"targets\":{\n          \"browsers\": \"last 2 versions, > 1%, ie >= 9\"\n        },\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n新建 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [babel()]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。\n\n## 使用 ployfill 兼容\n\n经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。\n\n安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。\n```\n$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2\n```\n\n修改 .babelrc 文件：\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/env\",\n      {\n        \"targets\":{\n          \"browsers\": \"last 2 versions, > 1%, ie >= 9\"\n        },\n        \"modules\": false\n      }\n    ]\n  ],\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\", {\n        \"corejs\": 2\n      }\n    ]\n  ]\n}\n```\n\n同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [\n        babel({\n          runtimeHelpers: true\n        })\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。\n```\n$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs\n```\n\n在修改 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\nconst resolve = require(\"rollup-plugin-node-resolve\");\nconst commonjs = require(\"rollup-plugin-commonjs\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [\n        commonjs(),\n        resolve(),\n        babel({\n          runtimeHelpers: true\n        })\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n## 使用 sourcemaps 和压缩\n\n注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(\"src/js/*.js\") 改为 gulp.src(\"src/js/*.js\") 只打包主文件不打包依赖模块。\n\n安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：\n```\nnpm install --save-dev gulp-sourcemaps rollup-plugin-uglify\n```\n\n修改 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\nconst resolve = require(\"rollup-plugin-node-resolve\");\nconst commonjs = require(\"rollup-plugin-commonjs\");\nconst uglify = require(\"rollup-plugin-uglify\");\nconst sourcemaps = require(\"gulp-sourcemaps\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/js/*.js\")\n    .pipe(sourcemaps.init())\n    .pipe(rollup({\n      plugins: [\n        commonjs(),\n        resolve(),\n        babel({\n          runtimeHelpers: true\n        }),\n        uglify.uglify()\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(sourcemaps.write('./'))\n    .pipe(gulp.dest(\"dist/js\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```","source":"_posts/2019-04-28-gulp + gulp-better-rollup + rollup 构建 ES6 开发环境.md","raw":"---\ntitle: gulp + gulp-better-rollup + rollup 构建 ES6 开发环境\ndate: 2019-04-28\ntoc: false\ncomments: false\ntags:\n    - gulp\n    - gulp-better-rollup\n    - rollup\n    - 搭建ES6开发环境\ncategories:\n    - 前端构建工具\n---\n\n关于 [Gulp](https://www.gulpjs.com.cn/) 就不过多啰嗦了。常用的 js 模块打包工具主要有 [webpack](https://www.webpackjs.com/)、[rollup](https://www.rollupjs.com/guide/zh) 和 [browserify](http://browserify.org/) 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 [gulp-better-rollup](https://www.npmjs.com/package/gulp-better-rollup) 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。\n\nGitHub地址：[https://github.com/JofunLiang/gulp-translation-es6-demo](https://github.com/JofunLiang/gulp-translation-es6-demo)\n\n<!--more-->\n\n## 构建基础的 ES6 语法转译环境\n\n首先，安装 gulp 工具，命令如下：\n```\n$ npm install --save-dev gulp\n```\n\n安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：\n```\n$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel\n```\n\n安装 babel 核心插件:\n```\n$ npm install --save-dev @babel/core @babel/preset-env\n```\n\n安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。\n\n新建 .babelrc 配置文件如下：\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/env\",\n      {\n        \"targets\":{\n          \"browsers\": \"last 2 versions, > 1%, ie >= 9\"\n        },\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n新建 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [babel()]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。\n\n## 使用 ployfill 兼容\n\n经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。\n\n安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。\n```\n$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2\n```\n\n修改 .babelrc 文件：\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/env\",\n      {\n        \"targets\":{\n          \"browsers\": \"last 2 versions, > 1%, ie >= 9\"\n        },\n        \"modules\": false\n      }\n    ]\n  ],\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\", {\n        \"corejs\": 2\n      }\n    ]\n  ]\n}\n```\n\n同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [\n        babel({\n          runtimeHelpers: true\n        })\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。\n```\n$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs\n```\n\n在修改 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\nconst resolve = require(\"rollup-plugin-node-resolve\");\nconst commonjs = require(\"rollup-plugin-commonjs\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/**/*.js\")\n    .pipe(rollup({\n      plugins: [\n        commonjs(),\n        resolve(),\n        babel({\n          runtimeHelpers: true\n        })\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(gulp.dest(\"dist\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```\n\n## 使用 sourcemaps 和压缩\n\n注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(\"src/js/*.js\") 改为 gulp.src(\"src/js/*.js\") 只打包主文件不打包依赖模块。\n\n安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：\n```\nnpm install --save-dev gulp-sourcemaps rollup-plugin-uglify\n```\n\n修改 gulpfile.js 文件如下：\n```js\nconst gulp = require(\"gulp\");\nconst rollup = require(\"gulp-better-rollup\");\nconst babel = require(\"rollup-plugin-babel\");\nconst resolve = require(\"rollup-plugin-node-resolve\");\nconst commonjs = require(\"rollup-plugin-commonjs\");\nconst uglify = require(\"rollup-plugin-uglify\");\nconst sourcemaps = require(\"gulp-sourcemaps\");\n\ngulp.task(\"babel\", () => {\n  return gulp.src(\"src/js/*.js\")\n    .pipe(sourcemaps.init())\n    .pipe(rollup({\n      plugins: [\n        commonjs(),\n        resolve(),\n        babel({\n          runtimeHelpers: true\n        }),\n        uglify.uglify()\n      ]\n    },{\n      format: \"iife\"\n    }))\n    .pipe(sourcemaps.write('./'))\n    .pipe(gulp.dest(\"dist/js\"))\n})\n\ngulp.task(\"watch\", () => {\n\tgulp.watch(\"src/**/*.js\", gulp.series(\"babel\"))\n})\n\ngulp.task(\"default\", gulp.series([\"babel\", \"watch\"]))\n```","slug":"2019-04-28-gulp + gulp-better-rollup + rollup 构建 ES6 开发环境","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4ab0019acqxmrrozg8h","content":"<p>关于 <a href=\"https://www.gulpjs.com.cn/\" target=\"_blank\" rel=\"noopener\">Gulp</a> 就不过多啰嗦了。常用的 js 模块打包工具主要有 <a href=\"https://www.webpackjs.com/\" target=\"_blank\" rel=\"noopener\">webpack</a>、<a href=\"https://www.rollupjs.com/guide/zh\" target=\"_blank\" rel=\"noopener\">rollup</a> 和 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserify</a> 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 <a href=\"https://www.npmjs.com/package/gulp-better-rollup\" target=\"_blank\" rel=\"noopener\">gulp-better-rollup</a> 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。</p>\n<p>GitHub地址：<a href=\"https://github.com/JofunLiang/gulp-translation-es6-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/JofunLiang/gulp-translation-es6-demo</a></p>\n<a id=\"more\"></a>\n<h2 id=\"构建基础的-ES6-语法转译环境\"><a href=\"#构建基础的-ES6-语法转译环境\" class=\"headerlink\" title=\"构建基础的 ES6 语法转译环境\"></a>构建基础的 ES6 语法转译环境</h2><p>首先，安装 gulp 工具，命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>\n<p>安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel</span><br></pre></td></tr></table></figure></p>\n<p>安装 babel 核心插件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。</p>\n<p>新建 .babelrc 配置文件如下：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"targets\"</span>:&#123;</span><br><span class=\"line\">          <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, &gt; 1%, ie &gt;= 9\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>新建 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [babel()]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。</p>\n<h2 id=\"使用-ployfill-兼容\"><a href=\"#使用-ployfill-兼容\" class=\"headerlink\" title=\"使用 ployfill 兼容\"></a>使用 ployfill 兼容</h2><p>经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。</p>\n<p>安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2</span><br></pre></td></tr></table></figure></p>\n<p>修改 .babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"targets\"</span>:&#123;</span><br><span class=\"line\">          <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, &gt; 1%, ie &gt;= 9\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"corejs\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs</span><br></pre></td></tr></table></figure></p>\n<p>在修改 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-node-resolve\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> commonjs = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-commonjs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        commonjs(),</span><br><span class=\"line\">        resolve(),</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用-sourcemaps-和压缩\"><a href=\"#使用-sourcemaps-和压缩\" class=\"headerlink\" title=\"使用 sourcemaps 和压缩\"></a>使用 sourcemaps 和压缩</h2><p>注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(“src/js/<em>.js”) 改为 gulp.src(“src/js/</em>.js”) 只打包主文件不打包依赖模块。</p>\n<p>安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev gulp-sourcemaps rollup-plugin-uglify</span><br></pre></td></tr></table></figure></p>\n<p>修改 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-node-resolve\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> commonjs = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-commonjs\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-uglify\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> sourcemaps = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-sourcemaps\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/js/*.js\"</span>)</span><br><span class=\"line\">    .pipe(sourcemaps.init())</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        commonjs(),</span><br><span class=\"line\">        resolve(),</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        uglify.uglify()</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(sourcemaps.write(<span class=\"string\">'./'</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>关于 <a href=\"https://www.gulpjs.com.cn/\" target=\"_blank\" rel=\"noopener\">Gulp</a> 就不过多啰嗦了。常用的 js 模块打包工具主要有 <a href=\"https://www.webpackjs.com/\" target=\"_blank\" rel=\"noopener\">webpack</a>、<a href=\"https://www.rollupjs.com/guide/zh\" target=\"_blank\" rel=\"noopener\">rollup</a> 和 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserify</a> 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 <a href=\"https://www.npmjs.com/package/gulp-better-rollup\" target=\"_blank\" rel=\"noopener\">gulp-better-rollup</a> 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。</p>\n<p>GitHub地址：<a href=\"https://github.com/JofunLiang/gulp-translation-es6-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/JofunLiang/gulp-translation-es6-demo</a></p>","more":"<h2 id=\"构建基础的-ES6-语法转译环境\"><a href=\"#构建基础的-ES6-语法转译环境\" class=\"headerlink\" title=\"构建基础的 ES6 语法转译环境\"></a>构建基础的 ES6 语法转译环境</h2><p>首先，安装 gulp 工具，命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>\n<p>安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel</span><br></pre></td></tr></table></figure></p>\n<p>安装 babel 核心插件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。</p>\n<p>新建 .babelrc 配置文件如下：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"targets\"</span>:&#123;</span><br><span class=\"line\">          <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, &gt; 1%, ie &gt;= 9\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>新建 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [babel()]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。</p>\n<h2 id=\"使用-ployfill-兼容\"><a href=\"#使用-ployfill-兼容\" class=\"headerlink\" title=\"使用 ployfill 兼容\"></a>使用 ployfill 兼容</h2><p>经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。</p>\n<p>安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2</span><br></pre></td></tr></table></figure></p>\n<p>修改 .babelrc 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/env\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"targets\"</span>:&#123;</span><br><span class=\"line\">          <span class=\"attr\">\"browsers\"</span>: <span class=\"string\">\"last 2 versions, &gt; 1%, ie &gt;= 9\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/plugin-transform-runtime\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"corejs\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs</span><br></pre></td></tr></table></figure></p>\n<p>在修改 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-node-resolve\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> commonjs = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-commonjs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/**/*.js\"</span>)</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        commonjs(),</span><br><span class=\"line\">        resolve(),</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用-sourcemaps-和压缩\"><a href=\"#使用-sourcemaps-和压缩\" class=\"headerlink\" title=\"使用 sourcemaps 和压缩\"></a>使用 sourcemaps 和压缩</h2><p>注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(“src/js/<em>.js”) 改为 gulp.src(“src/js/</em>.js”) 只打包主文件不打包依赖模块。</p>\n<p>安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev gulp-sourcemaps rollup-plugin-uglify</span><br></pre></td></tr></table></figure></p>\n<p>修改 gulpfile.js 文件如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rollup = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-better-rollup\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-babel\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-node-resolve\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> commonjs = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-commonjs\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"rollup-plugin-uglify\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> sourcemaps = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-sourcemaps\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"babel\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/js/*.js\"</span>)</span><br><span class=\"line\">    .pipe(sourcemaps.init())</span><br><span class=\"line\">    .pipe(rollup(&#123;</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        commonjs(),</span><br><span class=\"line\">        resolve(),</span><br><span class=\"line\">        babel(&#123;</span><br><span class=\"line\">          runtimeHelpers: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        uglify.uglify()</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      format: <span class=\"string\">\"iife\"</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(sourcemaps.write(<span class=\"string\">'./'</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"watch\"</span>, () =&gt; &#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">\"src/**/*.js\"</span>, gulp.series(<span class=\"string\">\"babel\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"default\"</span>, gulp.series([<span class=\"string\">\"babel\"</span>, <span class=\"string\">\"watch\"</span>]))</span><br></pre></td></tr></table></figure></p>"},{"title":"使用HTML5原生对话框元素，轻松创建模态框组件","date":"2019-03-04T16:00:00.000Z","toc":false,"comments":0,"_content":"\nHTML 5.2草案加入了新的dialog元素。但是是一种实验技术。\n\n以前，如果我们想要构建任何形式的模式对话框或对话框，我们需要有一个背景，一个关闭按钮，将事件绑定在对话框中的方式安排我们的标记，找到一种将消息传递出去的方式对话......这真的很复杂。对话框元素解决了上述所有问题。\n\n<!--more-->\n\n## Bootstrap 模态框和原生模态框的对比\n\n下面是一个bootstrap模态框的html结构：\n```html\n<!-- 按钮触发模态框 -->\n<button class=\"btn btn-primary btn-lg\" data-toggle=\"modal\" data-target=\"#myModal\">\n    开始演示模态框\n</button>\n<!-- 模态框（Modal） -->\n<div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">\n          &times;\n        </button>\n        <h4 class=\"modal-title\" id=\"myModalLabel\">\n          模态框（Modal）标题\n        </h4>\n      </div>\n      <div class=\"modal-body\">\n        在这里添加一些文本\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">关闭\n        </button>\n        <button type=\"button\" class=\"btn btn-primary\">\n            提交更改\n        </button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal -->\n</div>\n```\n\n下面是一个原生模态框的HTML结构：\n```html\n<!-- 按钮触发模态框 -->\n<button type=\"button\" class=\"btn\">显示模态框</button>\n\n<!-- 模态框 -->\n<dialog open>\n  HTML5原生模态框\n</dialog>\n```\n\n## 基础的模态框样式\n\n我们已经看到了对话框元素的最简单标记，您可能已经注意到open是上面对话框中的属性。将该属性添加到元素将强制显示对话框，否则将删除它。该对话框也将绝对定位在页面上。\n\n![基础的模态框样式](https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528172622475-1217033821.png)\n\n上图展示了一个最基本的模态框样式。\n\n打开浏览器可以查看到它的基本样式是这样的：\n```css\ndialog {\n  display: block;\n  position: absolute;\n  left: 0px;\n  right: 0px;\n  width: -webkit-fit-content;\n  height: -webkit-fit-content;\n  color: black;\n  margin: auto;\n  border-width: initial;\n  border-style: solid;\n  border-color: initial;\n  border-image: initial;\n  padding: 1em;\n  background: white;\n}\n```\n\ndialog元素还引入了一个新的伪类选择器::backdrop，通过浏览器查看到默认的::backdrop样式如下：\n```css\ndialog::backdrop {\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  background: rgba(0, 0, 0, 0.1);\n}\n```\n\n## 设置对话框样式\n\n我们可以像任何HTML元素一样设置dialog元素的样式，几乎所有的CSS样式都可以。通过::backdrop伪类选择器，我们可以用它来设置背景的样式。\n\n例如：\n```css\ndialog{\n  margin-top:200px;\n  width:250px;\n  height:250px;\n  text-align:center;\n  line-height:250px;\n  border-radius: 4px;\n  border: none;\n  box-shadow: 0 0 15px lightgray;\n}\n            \ndialog::backdrop {\n  background: rgba(black, .5);\n}\n```\n上面的样式效果如下图：\n\n![自定义对话框样式](https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528174904984-389738259.png)\n\n## 对话框操作 API\n\n下面是一个基本的对话框，因为没有设置open属性，所以它不会在视觉上显示任何东西。您需要使用JavaScript API来显示/隐藏它:\n```html\n<dialog>这是dialog对话框！</ dialog>\n```\n\ndialog元素的.show()和.close()两个api分别是显示和关闭对话框，通过在DOM元素上使用这两个api，您可以显示和关闭对话框。\n\n例如：\n```html\n<!-- HTML -->\n<dialog>\n  <p>这是dialog对话框！</p>\n  <button id=\"close\">关闭对话框</button>\n</dialog>\n<button id=\"show\">显示对话框</button>\n  \n<!-- script -->      \n<script>\n  var dialog = document.querySelector(\"dialog\");\n          \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.show();\n  };\n          \n  document.querySelector(\"#close\").onclick = function(){\n    dialog.close();\n  };\n</script>\n```\n\n你可以传递一个参数给dialog.close()。通过监听dialog元素的close事件，该dialog.returnValue属性将返回给定的值。\n\n如：\n```html\n<!--HTML-->\n<dialog>\n  <p>这是dialog对话框！</p>\n  <p><input type=\"text\" id=\"return_value\" value=\"\" placeholder=\"请输入内容\"/></p>\n  <button id=\"close\">关闭对话框</button>\n</dialog>\n<button id=\"show\">显示对话框</button>\n\n<!--script-->\n<script>\n  var dialog = document.querySelector(\"dialog\");\n  \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.showModal();\n  };\n  \n  document.querySelector(\"#close\").onclick = function(){\n    var val = document.querySelector(\"#return_value\").value;\n    dialog.close(val);\n  };\n  \n  //监听dialog元素的close事件\n  dialog.addEventListener(\"close\", function(){\n    alert(this.returnValue);\n  });\n</script>\n```\n\n显示dialog对话框的另一个api是.showModal()\n\n如果你不希望用户与对话框以外的其他页面元素对象进行交互，那么请使用.showModal()打开对话框而不是使用.show()。用.showModal()打开的对话框会有一个全窗口的半透明背景层，阻断用户与对话框之外的页面元素对象进行交互，同时对话框会默认显示在窗口正中间（上下左右都居中）；而用.show()打开的对话框会默认显示在窗口顶部（可以通过css实现居中显示）。\n\n关闭对话框后，close会触发一个事件。另外，用户可以通过输入“Escape”键来关闭模式对话框。这将激发cancel您可以取消使用的事件event.preventDefault()。\n\n## 与表单集成使用\n\n您可以使用form[method=\"dialog\"]将表单与一个<dialog>元素集成使用。表单提交后，它会关闭对话框并设置dialog.returnValue到value已使用的提交按钮。\n\n此外，您可以使用该autofocus属性在弹出对话框时自动将焦点对准对话框内的窗体控件。\n\n例如：\n```html\n<!--HTML-->\n<dialog id =\"dialog\">\n  <form method =\"dialog\">\n    <p>你是否同意使用条款？</p>\n    <p><textarea class =\"form-control\" disabled>条款要求...</textarea></p>\n    <button type =\"submit\" value =\"是\">是</button>\n    <button type =\"submit\" value =\"否\" autofocus>否</button>\n  </form>\n</dialog>\n<button id=\"show\">显示表单对话框</button>\n\n<!--script-->\n<script>\n  var dialog = document.querySelector(\"dialog\");\n  \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.showModal();\n  };\n  \n  //监听dialog元素的close事件\n  dialog.addEventListener(\"close\", function(e){\n    if(this.returnValue === \"是\"){\n      alert(this.returnValue)\n      //dosomething...\n    }else{\n      alert(this.returnValue)\n      //dosomething...\n    };\n  });\n</script>\n```\n\n## 浏览器兼容性\n\n桌面浏览器只有谷歌浏览器支持dialog的完整功能（到本博文发表时），要实现跨浏览器兼容请使用 [dialog-polyfill](https://github.com/GoogleChrome/dialog-polyfill)。\n\n<iframe src=\"//caniuse.com/dialog/embed\" scrolling=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" width=\"100%\" height=\"415\" frameborder=\"0\"></iframe>\n\n## 参考文献\n\n参考文章：[对话框元素演示](https://demo.agektmr.com/dialog/)\n\n## 符本人开源项目\n\nusuallyjs函数库：[https://github.com/JofunLiang/usuallyjs](https://github.com/JofunLiang/usuallyjs)","source":"_posts/2019-03-05-使用HTML5原生对话框元素，轻松创建模态框组件.md","raw":"---\ntitle: 使用HTML5原生对话框元素，轻松创建模态框组件\ndate: 2019-03-05\ntoc: false\ncomments: false\ntags:\n    - dialog元素\n    - html5\n    - dialog-polyfill\ncategories:\n    - HTML\n---\n\nHTML 5.2草案加入了新的dialog元素。但是是一种实验技术。\n\n以前，如果我们想要构建任何形式的模式对话框或对话框，我们需要有一个背景，一个关闭按钮，将事件绑定在对话框中的方式安排我们的标记，找到一种将消息传递出去的方式对话......这真的很复杂。对话框元素解决了上述所有问题。\n\n<!--more-->\n\n## Bootstrap 模态框和原生模态框的对比\n\n下面是一个bootstrap模态框的html结构：\n```html\n<!-- 按钮触发模态框 -->\n<button class=\"btn btn-primary btn-lg\" data-toggle=\"modal\" data-target=\"#myModal\">\n    开始演示模态框\n</button>\n<!-- 模态框（Modal） -->\n<div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">\n          &times;\n        </button>\n        <h4 class=\"modal-title\" id=\"myModalLabel\">\n          模态框（Modal）标题\n        </h4>\n      </div>\n      <div class=\"modal-body\">\n        在这里添加一些文本\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">关闭\n        </button>\n        <button type=\"button\" class=\"btn btn-primary\">\n            提交更改\n        </button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal -->\n</div>\n```\n\n下面是一个原生模态框的HTML结构：\n```html\n<!-- 按钮触发模态框 -->\n<button type=\"button\" class=\"btn\">显示模态框</button>\n\n<!-- 模态框 -->\n<dialog open>\n  HTML5原生模态框\n</dialog>\n```\n\n## 基础的模态框样式\n\n我们已经看到了对话框元素的最简单标记，您可能已经注意到open是上面对话框中的属性。将该属性添加到元素将强制显示对话框，否则将删除它。该对话框也将绝对定位在页面上。\n\n![基础的模态框样式](https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528172622475-1217033821.png)\n\n上图展示了一个最基本的模态框样式。\n\n打开浏览器可以查看到它的基本样式是这样的：\n```css\ndialog {\n  display: block;\n  position: absolute;\n  left: 0px;\n  right: 0px;\n  width: -webkit-fit-content;\n  height: -webkit-fit-content;\n  color: black;\n  margin: auto;\n  border-width: initial;\n  border-style: solid;\n  border-color: initial;\n  border-image: initial;\n  padding: 1em;\n  background: white;\n}\n```\n\ndialog元素还引入了一个新的伪类选择器::backdrop，通过浏览器查看到默认的::backdrop样式如下：\n```css\ndialog::backdrop {\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  background: rgba(0, 0, 0, 0.1);\n}\n```\n\n## 设置对话框样式\n\n我们可以像任何HTML元素一样设置dialog元素的样式，几乎所有的CSS样式都可以。通过::backdrop伪类选择器，我们可以用它来设置背景的样式。\n\n例如：\n```css\ndialog{\n  margin-top:200px;\n  width:250px;\n  height:250px;\n  text-align:center;\n  line-height:250px;\n  border-radius: 4px;\n  border: none;\n  box-shadow: 0 0 15px lightgray;\n}\n            \ndialog::backdrop {\n  background: rgba(black, .5);\n}\n```\n上面的样式效果如下图：\n\n![自定义对话框样式](https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528174904984-389738259.png)\n\n## 对话框操作 API\n\n下面是一个基本的对话框，因为没有设置open属性，所以它不会在视觉上显示任何东西。您需要使用JavaScript API来显示/隐藏它:\n```html\n<dialog>这是dialog对话框！</ dialog>\n```\n\ndialog元素的.show()和.close()两个api分别是显示和关闭对话框，通过在DOM元素上使用这两个api，您可以显示和关闭对话框。\n\n例如：\n```html\n<!-- HTML -->\n<dialog>\n  <p>这是dialog对话框！</p>\n  <button id=\"close\">关闭对话框</button>\n</dialog>\n<button id=\"show\">显示对话框</button>\n  \n<!-- script -->      \n<script>\n  var dialog = document.querySelector(\"dialog\");\n          \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.show();\n  };\n          \n  document.querySelector(\"#close\").onclick = function(){\n    dialog.close();\n  };\n</script>\n```\n\n你可以传递一个参数给dialog.close()。通过监听dialog元素的close事件，该dialog.returnValue属性将返回给定的值。\n\n如：\n```html\n<!--HTML-->\n<dialog>\n  <p>这是dialog对话框！</p>\n  <p><input type=\"text\" id=\"return_value\" value=\"\" placeholder=\"请输入内容\"/></p>\n  <button id=\"close\">关闭对话框</button>\n</dialog>\n<button id=\"show\">显示对话框</button>\n\n<!--script-->\n<script>\n  var dialog = document.querySelector(\"dialog\");\n  \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.showModal();\n  };\n  \n  document.querySelector(\"#close\").onclick = function(){\n    var val = document.querySelector(\"#return_value\").value;\n    dialog.close(val);\n  };\n  \n  //监听dialog元素的close事件\n  dialog.addEventListener(\"close\", function(){\n    alert(this.returnValue);\n  });\n</script>\n```\n\n显示dialog对话框的另一个api是.showModal()\n\n如果你不希望用户与对话框以外的其他页面元素对象进行交互，那么请使用.showModal()打开对话框而不是使用.show()。用.showModal()打开的对话框会有一个全窗口的半透明背景层，阻断用户与对话框之外的页面元素对象进行交互，同时对话框会默认显示在窗口正中间（上下左右都居中）；而用.show()打开的对话框会默认显示在窗口顶部（可以通过css实现居中显示）。\n\n关闭对话框后，close会触发一个事件。另外，用户可以通过输入“Escape”键来关闭模式对话框。这将激发cancel您可以取消使用的事件event.preventDefault()。\n\n## 与表单集成使用\n\n您可以使用form[method=\"dialog\"]将表单与一个<dialog>元素集成使用。表单提交后，它会关闭对话框并设置dialog.returnValue到value已使用的提交按钮。\n\n此外，您可以使用该autofocus属性在弹出对话框时自动将焦点对准对话框内的窗体控件。\n\n例如：\n```html\n<!--HTML-->\n<dialog id =\"dialog\">\n  <form method =\"dialog\">\n    <p>你是否同意使用条款？</p>\n    <p><textarea class =\"form-control\" disabled>条款要求...</textarea></p>\n    <button type =\"submit\" value =\"是\">是</button>\n    <button type =\"submit\" value =\"否\" autofocus>否</button>\n  </form>\n</dialog>\n<button id=\"show\">显示表单对话框</button>\n\n<!--script-->\n<script>\n  var dialog = document.querySelector(\"dialog\");\n  \n  document.querySelector(\"#show\").onclick = function(){\n    dialog.showModal();\n  };\n  \n  //监听dialog元素的close事件\n  dialog.addEventListener(\"close\", function(e){\n    if(this.returnValue === \"是\"){\n      alert(this.returnValue)\n      //dosomething...\n    }else{\n      alert(this.returnValue)\n      //dosomething...\n    };\n  });\n</script>\n```\n\n## 浏览器兼容性\n\n桌面浏览器只有谷歌浏览器支持dialog的完整功能（到本博文发表时），要实现跨浏览器兼容请使用 [dialog-polyfill](https://github.com/GoogleChrome/dialog-polyfill)。\n\n<iframe src=\"//caniuse.com/dialog/embed\" scrolling=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" width=\"100%\" height=\"415\" frameborder=\"0\"></iframe>\n\n## 参考文献\n\n参考文章：[对话框元素演示](https://demo.agektmr.com/dialog/)\n\n## 符本人开源项目\n\nusuallyjs函数库：[https://github.com/JofunLiang/usuallyjs](https://github.com/JofunLiang/usuallyjs)","slug":"2019-03-05-使用HTML5原生对话框元素，轻松创建模态框组件","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4ac001bacqx5ipzphpr","content":"<p>HTML 5.2草案加入了新的dialog元素。但是是一种实验技术。</p>\n<p>以前，如果我们想要构建任何形式的模式对话框或对话框，我们需要有一个背景，一个关闭按钮，将事件绑定在对话框中的方式安排我们的标记，找到一种将消息传递出去的方式对话……这真的很复杂。对话框元素解决了上述所有问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"Bootstrap-模态框和原生模态框的对比\"><a href=\"#Bootstrap-模态框和原生模态框的对比\" class=\"headerlink\" title=\"Bootstrap 模态框和原生模态框的对比\"></a>Bootstrap 模态框和原生模态框的对比</h2><p>下面是一个bootstrap模态框的html结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 按钮触发模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary btn-lg\"</span> <span class=\"attr\">data-toggle</span>=<span class=\"string\">\"modal\"</span> <span class=\"attr\">data-target</span>=<span class=\"string\">\"#myModal\"</span>&gt;</span></span><br><span class=\"line\">    开始演示模态框</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 模态框（Modal） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal fade\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myModal\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"-1\"</span> <span class=\"attr\">role</span>=<span class=\"string\">\"dialog\"</span> <span class=\"attr\">aria-labelledby</span>=<span class=\"string\">\"myModalLabel\"</span> <span class=\"attr\">aria-hidden</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-content\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-header\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"close\"</span> <span class=\"attr\">data-dismiss</span>=<span class=\"string\">\"modal\"</span> <span class=\"attr\">aria-hidden</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">          &amp;times;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-title\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myModalLabel\"</span>&gt;</span></span><br><span class=\"line\">          模态框（Modal）标题</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-body\"</span>&gt;</span></span><br><span class=\"line\">        在这里添加一些文本</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-footer\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-default\"</span> <span class=\"attr\">data-dismiss</span>=<span class=\"string\">\"modal\"</span>&gt;</span>关闭</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span></span><br><span class=\"line\">            提交更改</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"comment\">&lt;!-- /.modal-content --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"comment\">&lt;!-- /.modal --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是一个原生模态框的HTML结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 按钮触发模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>显示模态框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">open</span>&gt;</span></span><br><span class=\"line\">  HTML5原生模态框</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基础的模态框样式\"><a href=\"#基础的模态框样式\" class=\"headerlink\" title=\"基础的模态框样式\"></a>基础的模态框样式</h2><p>我们已经看到了对话框元素的最简单标记，您可能已经注意到open是上面对话框中的属性。将该属性添加到元素将强制显示对话框，否则将删除它。该对话框也将绝对定位在页面上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528172622475-1217033821.png\" alt=\"基础的模态框样式\"></p>\n<p>上图展示了一个最基本的模态框样式。</p>\n<p>打开浏览器可以查看到它的基本样式是这样的：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: -webkit-fit-content;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: -webkit-fit-content;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">border-image</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>dialog元素还引入了一个新的伪类选择器::backdrop，通过浏览器查看到默认的::backdrop样式如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0, 0, 0, 0.1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"设置对话框样式\"><a href=\"#设置对话框样式\" class=\"headerlink\" title=\"设置对话框样式\"></a>设置对话框样式</h2><p>我们可以像任何HTML元素一样设置dialog元素的样式，几乎所有的CSS样式都可以。通过::backdrop伪类选择器，我们可以用它来设置背景的样式。</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> lightgray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(black, .5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的样式效果如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528174904984-389738259.png\" alt=\"自定义对话框样式\"></p>\n<h2 id=\"对话框操作-API\"><a href=\"#对话框操作-API\" class=\"headerlink\" title=\"对话框操作 API\"></a>对话框操作 API</h2><p>下面是一个基本的对话框，因为没有设置open属性，所以它不会在视觉上显示任何东西。您需要使用JavaScript API来显示/隐藏它:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/ <span class=\"attr\">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>dialog元素的.show()和.close()两个api分别是显示和关闭对话框，通过在DOM元素上使用这两个api，您可以显示和关闭对话框。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- HTML --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"close\"</span>&gt;</span>关闭对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- script --&gt;</span>      </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.show();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#close\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.close();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以传递一个参数给dialog.close()。通过监听dialog元素的close事件，该dialog.returnValue属性将返回给定的值。</p>\n<p>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"return_value\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"请输入内容\"</span>/&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"close\"</span>&gt;</span>关闭对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--script--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.showModal();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#close\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> val = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#return_value\"</span>).value;</span></span><br><span class=\"line\">    dialog.close(val);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">//监听dialog元素的close事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">  dialog.addEventListener(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    alert(<span class=\"keyword\">this</span>.returnValue);</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>显示dialog对话框的另一个api是.showModal()</p>\n<p>如果你不希望用户与对话框以外的其他页面元素对象进行交互，那么请使用.showModal()打开对话框而不是使用.show()。用.showModal()打开的对话框会有一个全窗口的半透明背景层，阻断用户与对话框之外的页面元素对象进行交互，同时对话框会默认显示在窗口正中间（上下左右都居中）；而用.show()打开的对话框会默认显示在窗口顶部（可以通过css实现居中显示）。</p>\n<p>关闭对话框后，close会触发一个事件。另外，用户可以通过输入“Escape”键来关闭模式对话框。这将激发cancel您可以取消使用的事件event.preventDefault()。</p>\n<h2 id=\"与表单集成使用\"><a href=\"#与表单集成使用\" class=\"headerlink\" title=\"与表单集成使用\"></a>与表单集成使用</h2><p>您可以使用form[method=”dialog”]将表单与一个<dialog>元素集成使用。表单提交后，它会关闭对话框并设置dialog.returnValue到value已使用的提交按钮。</dialog></p>\n<p>此外，您可以使用该autofocus属性在弹出对话框时自动将焦点对准对话框内的窗体控件。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">id</span> =<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span> =<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>你是否同意使用条款？<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">class</span> =<span class=\"string\">\"form-control\"</span> <span class=\"attr\">disabled</span>&gt;</span>条款要求...<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> =<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span> =<span class=\"string\">\"是\"</span>&gt;</span>是<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> =<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span> =<span class=\"string\">\"否\"</span> <span class=\"attr\">autofocus</span>&gt;</span>否<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示表单对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--script--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.showModal();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">//监听dialog元素的close事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">  dialog.addEventListener(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.returnValue === <span class=\"string\">\"是\"</span>)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"keyword\">this</span>.returnValue)</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">//dosomething...</span></span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;<span class=\"keyword\">else</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"keyword\">this</span>.returnValue)</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">//dosomething...</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p>桌面浏览器只有谷歌浏览器支持dialog的完整功能（到本博文发表时），要实现跨浏览器兼容请使用 <a href=\"https://github.com/GoogleChrome/dialog-polyfill\" target=\"_blank\" rel=\"noopener\">dialog-polyfill</a>。</p>\n<iframe src=\"//caniuse.com/dialog/embed\" scrolling=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" width=\"100%\" height=\"415\" frameborder=\"0\"></iframe>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>参考文章：<a href=\"https://demo.agektmr.com/dialog/\" target=\"_blank\" rel=\"noopener\">对话框元素演示</a></p>\n<h2 id=\"符本人开源项目\"><a href=\"#符本人开源项目\" class=\"headerlink\" title=\"符本人开源项目\"></a>符本人开源项目</h2><p>usuallyjs函数库：<a href=\"https://github.com/JofunLiang/usuallyjs\" target=\"_blank\" rel=\"noopener\">https://github.com/JofunLiang/usuallyjs</a></p>\n","site":{"data":{}},"excerpt":"<p>HTML 5.2草案加入了新的dialog元素。但是是一种实验技术。</p>\n<p>以前，如果我们想要构建任何形式的模式对话框或对话框，我们需要有一个背景，一个关闭按钮，将事件绑定在对话框中的方式安排我们的标记，找到一种将消息传递出去的方式对话……这真的很复杂。对话框元素解决了上述所有问题。</p>","more":"<h2 id=\"Bootstrap-模态框和原生模态框的对比\"><a href=\"#Bootstrap-模态框和原生模态框的对比\" class=\"headerlink\" title=\"Bootstrap 模态框和原生模态框的对比\"></a>Bootstrap 模态框和原生模态框的对比</h2><p>下面是一个bootstrap模态框的html结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 按钮触发模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary btn-lg\"</span> <span class=\"attr\">data-toggle</span>=<span class=\"string\">\"modal\"</span> <span class=\"attr\">data-target</span>=<span class=\"string\">\"#myModal\"</span>&gt;</span></span><br><span class=\"line\">    开始演示模态框</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 模态框（Modal） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal fade\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myModal\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"-1\"</span> <span class=\"attr\">role</span>=<span class=\"string\">\"dialog\"</span> <span class=\"attr\">aria-labelledby</span>=<span class=\"string\">\"myModalLabel\"</span> <span class=\"attr\">aria-hidden</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-content\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-header\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"close\"</span> <span class=\"attr\">data-dismiss</span>=<span class=\"string\">\"modal\"</span> <span class=\"attr\">aria-hidden</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">          &amp;times;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-title\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myModalLabel\"</span>&gt;</span></span><br><span class=\"line\">          模态框（Modal）标题</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-body\"</span>&gt;</span></span><br><span class=\"line\">        在这里添加一些文本</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal-footer\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-default\"</span> <span class=\"attr\">data-dismiss</span>=<span class=\"string\">\"modal\"</span>&gt;</span>关闭</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span></span><br><span class=\"line\">            提交更改</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"comment\">&lt;!-- /.modal-content --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"comment\">&lt;!-- /.modal --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是一个原生模态框的HTML结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 按钮触发模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>显示模态框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 模态框 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">open</span>&gt;</span></span><br><span class=\"line\">  HTML5原生模态框</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基础的模态框样式\"><a href=\"#基础的模态框样式\" class=\"headerlink\" title=\"基础的模态框样式\"></a>基础的模态框样式</h2><p>我们已经看到了对话框元素的最简单标记，您可能已经注意到open是上面对话框中的属性。将该属性添加到元素将强制显示对话框，否则将删除它。该对话框也将绝对定位在页面上。</p>\n<p><img src=\"https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528172622475-1217033821.png\" alt=\"基础的模态框样式\"></p>\n<p>上图展示了一个最基本的模态框样式。</p>\n<p>打开浏览器可以查看到它的基本样式是这样的：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: -webkit-fit-content;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: -webkit-fit-content;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">border-image</span>: initial;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>dialog元素还引入了一个新的伪类选择器::backdrop，通过浏览器查看到默认的::backdrop样式如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(0, 0, 0, 0.1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"设置对话框样式\"><a href=\"#设置对话框样式\" class=\"headerlink\" title=\"设置对话框样式\"></a>设置对话框样式</h2><p>我们可以像任何HTML元素一样设置dialog元素的样式，几乎所有的CSS样式都可以。通过::backdrop伪类选择器，我们可以用它来设置背景的样式。</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">dialog</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>:<span class=\"number\">250px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> lightgray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-tag\">dialog</span><span class=\"selector-pseudo\">::backdrop</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(black, .5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的样式效果如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JofunLiang/JofunLiang.github.io/master/assets/images/1339591-20180528174904984-389738259.png\" alt=\"自定义对话框样式\"></p>\n<h2 id=\"对话框操作-API\"><a href=\"#对话框操作-API\" class=\"headerlink\" title=\"对话框操作 API\"></a>对话框操作 API</h2><p>下面是一个基本的对话框，因为没有设置open属性，所以它不会在视觉上显示任何东西。您需要使用JavaScript API来显示/隐藏它:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/ <span class=\"attr\">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>dialog元素的.show()和.close()两个api分别是显示和关闭对话框，通过在DOM元素上使用这两个api，您可以显示和关闭对话框。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- HTML --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"close\"</span>&gt;</span>关闭对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- script --&gt;</span>      </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.show();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#close\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.close();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以传递一个参数给dialog.close()。通过监听dialog元素的close事件，该dialog.returnValue属性将返回给定的值。</p>\n<p>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是dialog对话框！<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"return_value\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"请输入内容\"</span>/&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"close\"</span>&gt;</span>关闭对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--script--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.showModal();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#close\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> val = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#return_value\"</span>).value;</span></span><br><span class=\"line\">    dialog.close(val);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">//监听dialog元素的close事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">  dialog.addEventListener(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    alert(<span class=\"keyword\">this</span>.returnValue);</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>显示dialog对话框的另一个api是.showModal()</p>\n<p>如果你不希望用户与对话框以外的其他页面元素对象进行交互，那么请使用.showModal()打开对话框而不是使用.show()。用.showModal()打开的对话框会有一个全窗口的半透明背景层，阻断用户与对话框之外的页面元素对象进行交互，同时对话框会默认显示在窗口正中间（上下左右都居中）；而用.show()打开的对话框会默认显示在窗口顶部（可以通过css实现居中显示）。</p>\n<p>关闭对话框后，close会触发一个事件。另外，用户可以通过输入“Escape”键来关闭模式对话框。这将激发cancel您可以取消使用的事件event.preventDefault()。</p>\n<h2 id=\"与表单集成使用\"><a href=\"#与表单集成使用\" class=\"headerlink\" title=\"与表单集成使用\"></a>与表单集成使用</h2><p>您可以使用form[method=”dialog”]将表单与一个<dialog>元素集成使用。表单提交后，它会关闭对话框并设置dialog.returnValue到value已使用的提交按钮。</dialog></p>\n<p>此外，您可以使用该autofocus属性在弹出对话框时自动将焦点对准对话框内的窗体控件。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">id</span> =<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span> =<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>你是否同意使用条款？<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">class</span> =<span class=\"string\">\"form-control\"</span> <span class=\"attr\">disabled</span>&gt;</span>条款要求...<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> =<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span> =<span class=\"string\">\"是\"</span>&gt;</span>是<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> =<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span> =<span class=\"string\">\"否\"</span> <span class=\"attr\">autofocus</span>&gt;</span>否<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"show\"</span>&gt;</span>显示表单对话框<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--script--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"dialog\"</span>);</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#show\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    dialog.showModal();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">//监听dialog元素的close事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">  dialog.addEventListener(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.returnValue === <span class=\"string\">\"是\"</span>)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"keyword\">this</span>.returnValue)</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">//dosomething...</span></span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;<span class=\"keyword\">else</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"keyword\">this</span>.returnValue)</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">//dosomething...</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p>桌面浏览器只有谷歌浏览器支持dialog的完整功能（到本博文发表时），要实现跨浏览器兼容请使用 <a href=\"https://github.com/GoogleChrome/dialog-polyfill\" target=\"_blank\" rel=\"noopener\">dialog-polyfill</a>。</p>\n<iframe src=\"//caniuse.com/dialog/embed\" scrolling=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" width=\"100%\" height=\"415\" frameborder=\"0\"></iframe>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>参考文章：<a href=\"https://demo.agektmr.com/dialog/\" target=\"_blank\" rel=\"noopener\">对话框元素演示</a></p>\n<h2 id=\"符本人开源项目\"><a href=\"#符本人开源项目\" class=\"headerlink\" title=\"符本人开源项目\"></a>符本人开源项目</h2><p>usuallyjs函数库：<a href=\"https://github.com/JofunLiang/usuallyjs\" target=\"_blank\" rel=\"noopener\">https://github.com/JofunLiang/usuallyjs</a></p>"},{"title":"JavaScript管道语法提案","date":"2019-07-21T16:00:00.000Z","toc":false,"comments":0,"_content":"\n管道语法引入了一个 |> 类似于 F＃， OCaml， Elixir， Elm， Julia， Hack和LiveScript的新运算符，以及UNIX管道。它是一种向后兼容的方式，以可读，功能的方式简化链式函数调用，并提供了扩展内置原型的实用替代方法。\n\n<!--more-->\n\n## 单个参数的函数调用\n\n对于具有单个参数的函数调用，管道运算符本质上是一个有用的语法糖。换句话说，sqrt(64)相当于64 |> sqrt。\n\n当将多个功能链接在一起时，这具有更好的可读性。例如，给定以下功能：\n```js\nfunction doubleSay (str) {\n  return str + \", \" + str;\n}\n\nfunction capitalize (str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction exclaim (str) {\n  return str + '!';\n}\n```\n\n...以下调用是等效的：\n```js\nlet result = exclaim(capitalize(doubleSay('hello')));\n// result => 'Hello, hello!'\n\nlet result = 'hello'\n  |> doubleSay\n  |> capitalize\n  |> exclaim;\n// result => 'Hello, hello!'\n```\n\n## 具有多个参数的函数\n\n对于具有多个参数的函数，管道运算符不需要任何特殊规则; JavaScript已经有办法处理这种情况。\n\n例如，给定以下功能：\n```js\nfunction double (x) {\n  return x + x;\n}\n\nfunction add (x, y) {\n  return x + y;\n}\n\nfunction boundScore (min, max, score) {\n  return Math.max(min, Math.min(max, score));\n}\n```\n...您可以使用箭头函数来处理多参数函数（例如add）：\n```js\nlet person = {\n  score: 25\n}\n\nlet newScore = person.score\n  |> double\n  |> (_ => add(7, _))\n  |> (_ => boundScore(0, 100, _));\n// newScore => 57\n```\n相当于:\n```js\nlet newScore = boundScore( 0, 100, add(7, double(person.score)) );\n// newScore => 57\n```\n注意：_不需要使用下划线; 它只是一个箭头功能，所以你可以使用你喜欢的任何参数名称。\n\n正如您所看到的，因为管道运算符总是管道单个结果值，所以它与单参数箭头函数语法非常相似。此外，由于管道运算符的语义是纯粹而简单的，因此JavaScript引擎可以优化箭头函数。\n\n## 构建工具\n\nBabel管道支持插件：[@babel/plugin-proposal-pipeline-operator](https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator.html)\n\n安装：\n```\n$ npm install @babel/plugin-proposal-pipeline-operator\n```\n\n配置.babelrc插件选项：\n```js\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-proposal-pipeline-operator\",\n      {\n        \"proposal\": \"minimal\"\n      }\n    ]\n  ]\n}\n```\n\n## 附录\n[管道语法提案](https://github.com/tc39/proposal-pipeline-operator)","source":"_posts/2019-07-22-JavaScript管道语法提案.md","raw":"---\ntitle: JavaScript管道语法提案\ndate: 2019-07-22\ntoc: false\ncomments: false\ntags:\n    - 管道语法\n    - 管道函数\ncategories:\n    - JavaScript\n---\n\n管道语法引入了一个 |> 类似于 F＃， OCaml， Elixir， Elm， Julia， Hack和LiveScript的新运算符，以及UNIX管道。它是一种向后兼容的方式，以可读，功能的方式简化链式函数调用，并提供了扩展内置原型的实用替代方法。\n\n<!--more-->\n\n## 单个参数的函数调用\n\n对于具有单个参数的函数调用，管道运算符本质上是一个有用的语法糖。换句话说，sqrt(64)相当于64 |> sqrt。\n\n当将多个功能链接在一起时，这具有更好的可读性。例如，给定以下功能：\n```js\nfunction doubleSay (str) {\n  return str + \", \" + str;\n}\n\nfunction capitalize (str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction exclaim (str) {\n  return str + '!';\n}\n```\n\n...以下调用是等效的：\n```js\nlet result = exclaim(capitalize(doubleSay('hello')));\n// result => 'Hello, hello!'\n\nlet result = 'hello'\n  |> doubleSay\n  |> capitalize\n  |> exclaim;\n// result => 'Hello, hello!'\n```\n\n## 具有多个参数的函数\n\n对于具有多个参数的函数，管道运算符不需要任何特殊规则; JavaScript已经有办法处理这种情况。\n\n例如，给定以下功能：\n```js\nfunction double (x) {\n  return x + x;\n}\n\nfunction add (x, y) {\n  return x + y;\n}\n\nfunction boundScore (min, max, score) {\n  return Math.max(min, Math.min(max, score));\n}\n```\n...您可以使用箭头函数来处理多参数函数（例如add）：\n```js\nlet person = {\n  score: 25\n}\n\nlet newScore = person.score\n  |> double\n  |> (_ => add(7, _))\n  |> (_ => boundScore(0, 100, _));\n// newScore => 57\n```\n相当于:\n```js\nlet newScore = boundScore( 0, 100, add(7, double(person.score)) );\n// newScore => 57\n```\n注意：_不需要使用下划线; 它只是一个箭头功能，所以你可以使用你喜欢的任何参数名称。\n\n正如您所看到的，因为管道运算符总是管道单个结果值，所以它与单参数箭头函数语法非常相似。此外，由于管道运算符的语义是纯粹而简单的，因此JavaScript引擎可以优化箭头函数。\n\n## 构建工具\n\nBabel管道支持插件：[@babel/plugin-proposal-pipeline-operator](https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator.html)\n\n安装：\n```\n$ npm install @babel/plugin-proposal-pipeline-operator\n```\n\n配置.babelrc插件选项：\n```js\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-proposal-pipeline-operator\",\n      {\n        \"proposal\": \"minimal\"\n      }\n    ]\n  ]\n}\n```\n\n## 附录\n[管道语法提案](https://github.com/tc39/proposal-pipeline-operator)","slug":"2019-07-22-JavaScript管道语法提案","published":1,"updated":"2019-07-26T02:51:40.429Z","layout":"post","photos":[],"link":"","_id":"ck31ar4aj001facqx75dkq7y4","content":"<p>管道语法引入了一个 |&gt; 类似于 F＃， OCaml， Elixir， Elm， Julia， Hack和LiveScript的新运算符，以及UNIX管道。它是一种向后兼容的方式，以可读，功能的方式简化链式函数调用，并提供了扩展内置原型的实用替代方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"单个参数的函数调用\"><a href=\"#单个参数的函数调用\" class=\"headerlink\" title=\"单个参数的函数调用\"></a>单个参数的函数调用</h2><p>对于具有单个参数的函数调用，管道运算符本质上是一个有用的语法糖。换句话说，sqrt(64)相当于64 |&gt; sqrt。</p>\n<p>当将多个功能链接在一起时，这具有更好的可读性。例如，给定以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleSay</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str + <span class=\"string\">\", \"</span> + str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalize</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str[<span class=\"number\">0</span>].toUpperCase() + str.substring(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">exclaim</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str + <span class=\"string\">'!'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>…以下调用是等效的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = exclaim(capitalize(doubleSay(<span class=\"string\">'hello'</span>)));</span><br><span class=\"line\"><span class=\"comment\">// result =&gt; 'Hello, hello!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"string\">'hello'</span></span><br><span class=\"line\">  |&gt; doubleSay</span><br><span class=\"line\">  |&gt; capitalize</span><br><span class=\"line\">  |&gt; exclaim;</span><br><span class=\"line\"><span class=\"comment\">// result =&gt; 'Hello, hello!'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"具有多个参数的函数\"><a href=\"#具有多个参数的函数\" class=\"headerlink\" title=\"具有多个参数的函数\"></a>具有多个参数的函数</h2><p>对于具有多个参数的函数，管道运算符不需要任何特殊规则; JavaScript已经有办法处理这种情况。</p>\n<p>例如，给定以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundScore</span> (<span class=\"params\">min, max, score</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(min, <span class=\"built_in\">Math</span>.min(max, score));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>…您可以使用箭头函数来处理多参数函数（例如add）：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  score: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> newScore = person.score</span><br><span class=\"line\">  |&gt; double</span><br><span class=\"line\">  |&gt; (<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> add(<span class=\"number\">7</span>, _))</span><br><span class=\"line\">  |&gt; (<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> boundScore(<span class=\"number\">0</span>, <span class=\"number\">100</span>, _));</span><br><span class=\"line\"><span class=\"comment\">// newScore =&gt; 57</span></span><br></pre></td></tr></table></figure></p>\n<p>相当于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newScore = boundScore( <span class=\"number\">0</span>, <span class=\"number\">100</span>, add(<span class=\"number\">7</span>, double(person.score)) );</span><br><span class=\"line\"><span class=\"comment\">// newScore =&gt; 57</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：_不需要使用下划线; 它只是一个箭头功能，所以你可以使用你喜欢的任何参数名称。</p>\n<p>正如您所看到的，因为管道运算符总是管道单个结果值，所以它与单参数箭头函数语法非常相似。此外，由于管道运算符的语义是纯粹而简单的，因此JavaScript引擎可以优化箭头函数。</p>\n<h2 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h2><p>Babel管道支持插件：<a href=\"https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator.html\" target=\"_blank\" rel=\"noopener\">@babel/plugin-proposal-pipeline-operator</a></p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @babel/plugin-proposal-pipeline-operator</span><br></pre></td></tr></table></figure></p>\n<p>配置.babelrc插件选项：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/plugin-proposal-pipeline-operator\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"proposal\"</span>: <span class=\"string\">\"minimal\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"https://github.com/tc39/proposal-pipeline-operator\" target=\"_blank\" rel=\"noopener\">管道语法提案</a></p>\n","site":{"data":{}},"excerpt":"<p>管道语法引入了一个 |&gt; 类似于 F＃， OCaml， Elixir， Elm， Julia， Hack和LiveScript的新运算符，以及UNIX管道。它是一种向后兼容的方式，以可读，功能的方式简化链式函数调用，并提供了扩展内置原型的实用替代方法。</p>","more":"<h2 id=\"单个参数的函数调用\"><a href=\"#单个参数的函数调用\" class=\"headerlink\" title=\"单个参数的函数调用\"></a>单个参数的函数调用</h2><p>对于具有单个参数的函数调用，管道运算符本质上是一个有用的语法糖。换句话说，sqrt(64)相当于64 |&gt; sqrt。</p>\n<p>当将多个功能链接在一起时，这具有更好的可读性。例如，给定以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleSay</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str + <span class=\"string\">\", \"</span> + str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalize</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str[<span class=\"number\">0</span>].toUpperCase() + str.substring(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">exclaim</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str + <span class=\"string\">'!'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>…以下调用是等效的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = exclaim(capitalize(doubleSay(<span class=\"string\">'hello'</span>)));</span><br><span class=\"line\"><span class=\"comment\">// result =&gt; 'Hello, hello!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"string\">'hello'</span></span><br><span class=\"line\">  |&gt; doubleSay</span><br><span class=\"line\">  |&gt; capitalize</span><br><span class=\"line\">  |&gt; exclaim;</span><br><span class=\"line\"><span class=\"comment\">// result =&gt; 'Hello, hello!'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"具有多个参数的函数\"><a href=\"#具有多个参数的函数\" class=\"headerlink\" title=\"具有多个参数的函数\"></a>具有多个参数的函数</h2><p>对于具有多个参数的函数，管道运算符不需要任何特殊规则; JavaScript已经有办法处理这种情况。</p>\n<p>例如，给定以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundScore</span> (<span class=\"params\">min, max, score</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(min, <span class=\"built_in\">Math</span>.min(max, score));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>…您可以使用箭头函数来处理多参数函数（例如add）：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  score: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> newScore = person.score</span><br><span class=\"line\">  |&gt; double</span><br><span class=\"line\">  |&gt; (<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> add(<span class=\"number\">7</span>, _))</span><br><span class=\"line\">  |&gt; (<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> boundScore(<span class=\"number\">0</span>, <span class=\"number\">100</span>, _));</span><br><span class=\"line\"><span class=\"comment\">// newScore =&gt; 57</span></span><br></pre></td></tr></table></figure></p>\n<p>相当于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newScore = boundScore( <span class=\"number\">0</span>, <span class=\"number\">100</span>, add(<span class=\"number\">7</span>, double(person.score)) );</span><br><span class=\"line\"><span class=\"comment\">// newScore =&gt; 57</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：_不需要使用下划线; 它只是一个箭头功能，所以你可以使用你喜欢的任何参数名称。</p>\n<p>正如您所看到的，因为管道运算符总是管道单个结果值，所以它与单参数箭头函数语法非常相似。此外，由于管道运算符的语义是纯粹而简单的，因此JavaScript引擎可以优化箭头函数。</p>\n<h2 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h2><p>Babel管道支持插件：<a href=\"https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator.html\" target=\"_blank\" rel=\"noopener\">@babel/plugin-proposal-pipeline-operator</a></p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @babel/plugin-proposal-pipeline-operator</span><br></pre></td></tr></table></figure></p>\n<p>配置.babelrc插件选项：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"@babel/plugin-proposal-pipeline-operator\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"proposal\"</span>: <span class=\"string\">\"minimal\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"https://github.com/tc39/proposal-pipeline-operator\" target=\"_blank\" rel=\"noopener\">管道语法提案</a></p>"},{"title":"CSS隐藏元素滚动条","date":"2019-07-08T16:00:00.000Z","toc":false,"comments":0,"_content":"\n如何隐藏滚动条，同时仍然可以在任何元素上滚动？\n\n首先，如果需要隐藏滚动条并在内容溢出时显示滚动条，只需要设置overflow：auto样式即可。想要完全隐藏滚动条只需设置overflow：hidden即可，但是这样一来将导致元素内容不可滚动。时至今日，还没有任何一条CSS规则可以使元素可以隐藏滚动条的同时依然可以滚动内容，只能通过针对特定浏览器设置滚动条样式来实现。\n\n<!--more-->\n\n## Firefox浏览器\n\n对于Firefox，我们可以将滚动条宽度设置为none：\n```css\nscrollbar-width: none; /* Firefox */\n```\n\n## IE浏览器\n\n对于IE，我们需要使用-ms-prefix属性定义滚动条样式：\n```css\n-ms-overflow-style: none; /* IE 10+ */\n```\n\n## Chrome和Safari浏览器\n\n对于Chrome和Safari浏览器，我们必须使用CSS滚动条选择器，然后使用display：none隐藏它：\n```css\n::-webkit-scrollbar {\n  display: none; /* Chrome Safari */\n}\n```\n\n** 注意：当你要隐藏滚动条的时候，最好将overflow显示设置为auto或者scroll保证内容是可滚动的。 **\n\n## 示例\n\n我们使用上面的CSS属性以及溢出实现下面一个实例——隐藏水平滚动条，同时允许垂直滚动条：\n```css\n.demo::-webkit-scrollbar {\n  display: none; /* Chrome Safari */\n}\n\n.demo {\n  scrollbar-width: none; /* firefox */\n  -ms-overflow-style: none; /* IE 10+ */\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n```","source":"_posts/2019-07-09-CSS隐藏元素滚动条.md","raw":"---\ntitle: CSS隐藏元素滚动条\ndate: 2019-07-09\ntoc: false\ncomments: false\ncategories:\n    - CSS\n---\n\n如何隐藏滚动条，同时仍然可以在任何元素上滚动？\n\n首先，如果需要隐藏滚动条并在内容溢出时显示滚动条，只需要设置overflow：auto样式即可。想要完全隐藏滚动条只需设置overflow：hidden即可，但是这样一来将导致元素内容不可滚动。时至今日，还没有任何一条CSS规则可以使元素可以隐藏滚动条的同时依然可以滚动内容，只能通过针对特定浏览器设置滚动条样式来实现。\n\n<!--more-->\n\n## Firefox浏览器\n\n对于Firefox，我们可以将滚动条宽度设置为none：\n```css\nscrollbar-width: none; /* Firefox */\n```\n\n## IE浏览器\n\n对于IE，我们需要使用-ms-prefix属性定义滚动条样式：\n```css\n-ms-overflow-style: none; /* IE 10+ */\n```\n\n## Chrome和Safari浏览器\n\n对于Chrome和Safari浏览器，我们必须使用CSS滚动条选择器，然后使用display：none隐藏它：\n```css\n::-webkit-scrollbar {\n  display: none; /* Chrome Safari */\n}\n```\n\n** 注意：当你要隐藏滚动条的时候，最好将overflow显示设置为auto或者scroll保证内容是可滚动的。 **\n\n## 示例\n\n我们使用上面的CSS属性以及溢出实现下面一个实例——隐藏水平滚动条，同时允许垂直滚动条：\n```css\n.demo::-webkit-scrollbar {\n  display: none; /* Chrome Safari */\n}\n\n.demo {\n  scrollbar-width: none; /* firefox */\n  -ms-overflow-style: none; /* IE 10+ */\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n```","slug":"2019-07-09-CSS隐藏元素滚动条","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4ao001gacqxmd54q97a","content":"<p>如何隐藏滚动条，同时仍然可以在任何元素上滚动？</p>\n<p>首先，如果需要隐藏滚动条并在内容溢出时显示滚动条，只需要设置overflow：auto样式即可。想要完全隐藏滚动条只需设置overflow：hidden即可，但是这样一来将导致元素内容不可滚动。时至今日，还没有任何一条CSS规则可以使元素可以隐藏滚动条的同时依然可以滚动内容，只能通过针对特定浏览器设置滚动条样式来实现。</p>\n<a id=\"more\"></a>\n<h2 id=\"Firefox浏览器\"><a href=\"#Firefox浏览器\" class=\"headerlink\" title=\"Firefox浏览器\"></a>Firefox浏览器</h2><p>对于Firefox，我们可以将滚动条宽度设置为none：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">scrollbar-width</span>: <span class=\"selector-tag\">none</span>; <span class=\"comment\">/* Firefox */</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"IE浏览器\"><a href=\"#IE浏览器\" class=\"headerlink\" title=\"IE浏览器\"></a>IE浏览器</h2><p>对于IE，我们需要使用-ms-prefix属性定义滚动条样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-ms-overflow-style</span>: <span class=\"selector-tag\">none</span>; <span class=\"comment\">/* IE 10+ */</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Chrome和Safari浏览器\"><a href=\"#Chrome和Safari浏览器\" class=\"headerlink\" title=\"Chrome和Safari浏览器\"></a>Chrome和Safari浏览器</h2><p>对于Chrome和Safari浏览器，我们必须使用CSS滚动条选择器，然后使用display：none隐藏它：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none; <span class=\"comment\">/* Chrome Safari */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 注意：当你要隐藏滚动条的时候，最好将overflow显示设置为auto或者scroll保证内容是可滚动的。 </strong></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>我们使用上面的CSS属性以及溢出实现下面一个实例——隐藏水平滚动条，同时允许垂直滚动条：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none; <span class=\"comment\">/* Chrome Safari */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">scrollbar-width</span>: none; <span class=\"comment\">/* firefox */</span></span><br><span class=\"line\">  <span class=\"attribute\">-ms-overflow-style</span>: none; <span class=\"comment\">/* IE 10+ */</span></span><br><span class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>如何隐藏滚动条，同时仍然可以在任何元素上滚动？</p>\n<p>首先，如果需要隐藏滚动条并在内容溢出时显示滚动条，只需要设置overflow：auto样式即可。想要完全隐藏滚动条只需设置overflow：hidden即可，但是这样一来将导致元素内容不可滚动。时至今日，还没有任何一条CSS规则可以使元素可以隐藏滚动条的同时依然可以滚动内容，只能通过针对特定浏览器设置滚动条样式来实现。</p>","more":"<h2 id=\"Firefox浏览器\"><a href=\"#Firefox浏览器\" class=\"headerlink\" title=\"Firefox浏览器\"></a>Firefox浏览器</h2><p>对于Firefox，我们可以将滚动条宽度设置为none：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">scrollbar-width</span>: <span class=\"selector-tag\">none</span>; <span class=\"comment\">/* Firefox */</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"IE浏览器\"><a href=\"#IE浏览器\" class=\"headerlink\" title=\"IE浏览器\"></a>IE浏览器</h2><p>对于IE，我们需要使用-ms-prefix属性定义滚动条样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-ms-overflow-style</span>: <span class=\"selector-tag\">none</span>; <span class=\"comment\">/* IE 10+ */</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Chrome和Safari浏览器\"><a href=\"#Chrome和Safari浏览器\" class=\"headerlink\" title=\"Chrome和Safari浏览器\"></a>Chrome和Safari浏览器</h2><p>对于Chrome和Safari浏览器，我们必须使用CSS滚动条选择器，然后使用display：none隐藏它：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none; <span class=\"comment\">/* Chrome Safari */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 注意：当你要隐藏滚动条的时候，最好将overflow显示设置为auto或者scroll保证内容是可滚动的。 </strong></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>我们使用上面的CSS属性以及溢出实现下面一个实例——隐藏水平滚动条，同时允许垂直滚动条：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none; <span class=\"comment\">/* Chrome Safari */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">scrollbar-width</span>: none; <span class=\"comment\">/* firefox */</span></span><br><span class=\"line\">  <span class=\"attribute\">-ms-overflow-style</span>: none; <span class=\"comment\">/* IE 10+ */</span></span><br><span class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"简析JSX语法","date":"2019-07-23T16:00:00.000Z","toc":false,"comments":0,"_content":"\nJSX，是一个 JavaScript 的语法扩展。是React组件编写UI逻辑的语言扩展（JSX除了能在React中使用之外还可以用于别的地方）。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。\n\n<!--more-->\n\nJSX 有以下优点：\n* JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。\n* 它是类型安全的，在编译过程中就能发现错误。\n* 使用 JSX 编写模板更加简单快速。\n\n## JSX 原理\nJSX 能在HTML中正常显示必须转换成 DOM，了解更多关于 DOM 的知识请移步[DOM 概述](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction),\nDOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。DOM 是web页面的完全的面向对象表述，即每个DOM元素的结构都可以用JavaScript的对象来表示。\n\n下面这个最简单的DOM元素为例，怎么使用JavaScript的对象来表现一个DOM元素的结果：\n```html\n<h1 class=\"title\">Hello World!</h1>\n```\n你会发现，DOM元素包含的信息其实只有三个：标签名（HTML元素）、属性（HTML元素属性）和子元素（HTML元素或文本节点）。那么上面的这个HTML标签对应的所有信息可以用下面这个对象来描述：\n```js\n{\n  tag: 'div',\n  attrs: {\n    className: 'title'\n  },\n  children: 'Hello World!'\n}\n```\nHTML的信息和JavaScript所包含的结构和信息其实是一样的，我们可以用JavaScript对象来描述所有能用HTML表示的UI信息。\n\n在React中会把类似HTML的JSX结构转换成JavaScript的对象结构，如：\n```jsx\nconst element = <h1 className=\"title\">Hello World!</h1>\n```\nJSX 实际是一个对象，element包含以下信息：\n```js\n{\n  type: \"h1\",\n  props: {\n    children: \"Hello World!\",\n    className: \"title\"\n  }\n}\n```\nBabel会把JSX转译成一个名为React.createElement()函数调用。比如下面的两段代码，起到的作用是同等的：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n```jsx\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n实际上，JSX 仅仅只是React.createElement(component, props, ...children)函数的语法糖。\n\n## 使用大括号嵌入 JavaScript 表达式\n\n在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式：\n```jsx\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n```\n\n嵌入函数：\n```jsx\nconst getName = () => 'Josh Perez';\nconst element = <h1>Hello, {getName()}</h1>;\n```\n\n注意：if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。\n\n## JSX 也是一个表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：\n```jsx\nconst getName = () => 'jofun'\n\nfunction getGreeting (name) {\n  if (name) {\n    return <h1>Hello, {name}</h1>\n  }\n  return <h1>Hello, {getName()}</h1>\n}\n\nconst element = <div>{getGreeting('joe')}</div>\n```\n\n## JSX 特定属性\n\n你可以通过使用引号，来将属性值指定为字符串字面量：\n```jsx\nconst element = <div tabIndex=\"0\"></div>\n```\n\n使用大括号，来在属性值中插入一个 JavaScript 表达式：\n```jsx\nconst element = <img src={user.avatarUrl} />\n```\n在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。\n\n注意：因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。如：tabindex 变为 tabIndex。需要特别注意的是，在JSX中要是会用到class和for属性时，需要将class换成 className，for换成 htmlFor。那是因为class和for是JavaScript中的关键字。\n\n## 使用 JSX 指定子元素\n\nJSX 标签里和HTML一样能够嵌套包含子元素:\n```jsx\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n```\n\n## JSX 防止注入攻击\n\n你可以安全地在 JSX 当中插入用户输入内容：\n```jsx\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>;\n```\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。","source":"_posts/2019-07-24-简析JSX语法.md","raw":"---\ntitle: 简析JSX语法\ndate: 2019-07-24\ntoc: false\ncomments: false\ntags:\n    - JSX语法\ncategories:\n    - React\n---\n\nJSX，是一个 JavaScript 的语法扩展。是React组件编写UI逻辑的语言扩展（JSX除了能在React中使用之外还可以用于别的地方）。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。\n\n<!--more-->\n\nJSX 有以下优点：\n* JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。\n* 它是类型安全的，在编译过程中就能发现错误。\n* 使用 JSX 编写模板更加简单快速。\n\n## JSX 原理\nJSX 能在HTML中正常显示必须转换成 DOM，了解更多关于 DOM 的知识请移步[DOM 概述](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction),\nDOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。DOM 是web页面的完全的面向对象表述，即每个DOM元素的结构都可以用JavaScript的对象来表示。\n\n下面这个最简单的DOM元素为例，怎么使用JavaScript的对象来表现一个DOM元素的结果：\n```html\n<h1 class=\"title\">Hello World!</h1>\n```\n你会发现，DOM元素包含的信息其实只有三个：标签名（HTML元素）、属性（HTML元素属性）和子元素（HTML元素或文本节点）。那么上面的这个HTML标签对应的所有信息可以用下面这个对象来描述：\n```js\n{\n  tag: 'div',\n  attrs: {\n    className: 'title'\n  },\n  children: 'Hello World!'\n}\n```\nHTML的信息和JavaScript所包含的结构和信息其实是一样的，我们可以用JavaScript对象来描述所有能用HTML表示的UI信息。\n\n在React中会把类似HTML的JSX结构转换成JavaScript的对象结构，如：\n```jsx\nconst element = <h1 className=\"title\">Hello World!</h1>\n```\nJSX 实际是一个对象，element包含以下信息：\n```js\n{\n  type: \"h1\",\n  props: {\n    children: \"Hello World!\",\n    className: \"title\"\n  }\n}\n```\nBabel会把JSX转译成一个名为React.createElement()函数调用。比如下面的两段代码，起到的作用是同等的：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n```jsx\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n实际上，JSX 仅仅只是React.createElement(component, props, ...children)函数的语法糖。\n\n## 使用大括号嵌入 JavaScript 表达式\n\n在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式：\n```jsx\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n```\n\n嵌入函数：\n```jsx\nconst getName = () => 'Josh Perez';\nconst element = <h1>Hello, {getName()}</h1>;\n```\n\n注意：if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。\n\n## JSX 也是一个表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：\n```jsx\nconst getName = () => 'jofun'\n\nfunction getGreeting (name) {\n  if (name) {\n    return <h1>Hello, {name}</h1>\n  }\n  return <h1>Hello, {getName()}</h1>\n}\n\nconst element = <div>{getGreeting('joe')}</div>\n```\n\n## JSX 特定属性\n\n你可以通过使用引号，来将属性值指定为字符串字面量：\n```jsx\nconst element = <div tabIndex=\"0\"></div>\n```\n\n使用大括号，来在属性值中插入一个 JavaScript 表达式：\n```jsx\nconst element = <img src={user.avatarUrl} />\n```\n在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。\n\n注意：因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。如：tabindex 变为 tabIndex。需要特别注意的是，在JSX中要是会用到class和for属性时，需要将class换成 className，for换成 htmlFor。那是因为class和for是JavaScript中的关键字。\n\n## 使用 JSX 指定子元素\n\nJSX 标签里和HTML一样能够嵌套包含子元素:\n```jsx\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n```\n\n## JSX 防止注入攻击\n\n你可以安全地在 JSX 当中插入用户输入内容：\n```jsx\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>;\n```\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。","slug":"2019-07-24-简析JSX语法","published":1,"updated":"2019-07-29T06:45:27.786Z","layout":"post","photos":[],"link":"","_id":"ck31ar4aq001kacqx3ffvg7ym","content":"<p>JSX，是一个 JavaScript 的语法扩展。是React组件编写UI逻辑的语言扩展（JSX除了能在React中使用之外还可以用于别的地方）。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p>\n<a id=\"more\"></a>\n<p>JSX 有以下优点：</p>\n<ul>\n<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li>\n<li>它是类型安全的，在编译过程中就能发现错误。</li>\n<li>使用 JSX 编写模板更加简单快速。</li>\n</ul>\n<h2 id=\"JSX-原理\"><a href=\"#JSX-原理\" class=\"headerlink\" title=\"JSX 原理\"></a>JSX 原理</h2><p>JSX 能在HTML中正常显示必须转换成 DOM，了解更多关于 DOM 的知识请移步<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction\" target=\"_blank\" rel=\"noopener\">DOM 概述</a>,<br>DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。DOM 是web页面的完全的面向对象表述，即每个DOM元素的结构都可以用JavaScript的对象来表示。</p>\n<p>下面这个最简单的DOM元素为例，怎么使用JavaScript的对象来表现一个DOM元素的结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你会发现，DOM元素包含的信息其实只有三个：标签名（HTML元素）、属性（HTML元素属性）和子元素（HTML元素或文本节点）。那么上面的这个HTML标签对应的所有信息可以用下面这个对象来描述：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">  attrs: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">'title'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  children: <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML的信息和JavaScript所包含的结构和信息其实是一样的，我们可以用JavaScript对象来描述所有能用HTML表示的UI信息。</p>\n<p>在React中会把类似HTML的JSX结构转换成JavaScript的对象结构，如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"title\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>JSX 实际是一个对象，element包含以下信息：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: <span class=\"string\">\"Hello World!\"</span>,</span><br><span class=\"line\">    className: <span class=\"string\">\"title\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Babel会把JSX转译成一个名为React.createElement()函数调用。比如下面的两段代码，起到的作用是同等的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">\"greeting\"</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">'Hello, world!'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>实际上，JSX 仅仅只是React.createElement(component, props, …children)函数的语法糖。</p>\n<h2 id=\"使用大括号嵌入-JavaScript-表达式\"><a href=\"#使用大括号嵌入-JavaScript-表达式\" class=\"headerlink\" title=\"使用大括号嵌入 JavaScript 表达式\"></a>使用大括号嵌入 JavaScript 表达式</h2><p>在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Josh Perez'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>嵌入函数：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Josh Perez'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;getName()&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>注意：if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。</p>\n<h2 id=\"JSX-也是一个表达式\"><a href=\"#JSX-也是一个表达式\" class=\"headerlink\" title=\"JSX 也是一个表达式\"></a>JSX 也是一个表达式</h2><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>\n<p>也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'jofun'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGreeting</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;getName()&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;getGreeting('joe')&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSX-特定属性\"><a href=\"#JSX-特定属性\" class=\"headerlink\" title=\"JSX 特定属性\"></a>JSX 特定属性</h2><p>你可以通过使用引号，来将属性值指定为字符串字面量：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">tabIndex</span>=<span class=\"string\">\"0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>使用大括号，来在属性值中插入一个 JavaScript 表达式：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;user.avatarUrl&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>\n<p>注意：因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。如：tabindex 变为 tabIndex。需要特别注意的是，在JSX中要是会用到class和for属性时，需要将class换成 className，for换成 htmlFor。那是因为class和for是JavaScript中的关键字。</p>\n<h2 id=\"使用-JSX-指定子元素\"><a href=\"#使用-JSX-指定子元素\" class=\"headerlink\" title=\"使用 JSX 指定子元素\"></a>使用 JSX 指定子元素</h2><p>JSX 标签里和HTML一样能够嵌套包含子元素:<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;Good to see you here.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSX-防止注入攻击\"><a href=\"#JSX-防止注入攻击\" class=\"headerlink\" title=\"JSX 防止注入攻击\"></a>JSX 防止注入攻击</h2><p>你可以安全地在 JSX 当中插入用户输入内容：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> title = response.potentiallyMaliciousInput;</span><br><span class=\"line\"><span class=\"comment\">// 直接使用是安全的：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;title&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p>\n","site":{"data":{}},"excerpt":"<p>JSX，是一个 JavaScript 的语法扩展。是React组件编写UI逻辑的语言扩展（JSX除了能在React中使用之外还可以用于别的地方）。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p>","more":"<p>JSX 有以下优点：</p>\n<ul>\n<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li>\n<li>它是类型安全的，在编译过程中就能发现错误。</li>\n<li>使用 JSX 编写模板更加简单快速。</li>\n</ul>\n<h2 id=\"JSX-原理\"><a href=\"#JSX-原理\" class=\"headerlink\" title=\"JSX 原理\"></a>JSX 原理</h2><p>JSX 能在HTML中正常显示必须转换成 DOM，了解更多关于 DOM 的知识请移步<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction\" target=\"_blank\" rel=\"noopener\">DOM 概述</a>,<br>DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。DOM 是web页面的完全的面向对象表述，即每个DOM元素的结构都可以用JavaScript的对象来表示。</p>\n<p>下面这个最简单的DOM元素为例，怎么使用JavaScript的对象来表现一个DOM元素的结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你会发现，DOM元素包含的信息其实只有三个：标签名（HTML元素）、属性（HTML元素属性）和子元素（HTML元素或文本节点）。那么上面的这个HTML标签对应的所有信息可以用下面这个对象来描述：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">  attrs: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">'title'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  children: <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML的信息和JavaScript所包含的结构和信息其实是一样的，我们可以用JavaScript对象来描述所有能用HTML表示的UI信息。</p>\n<p>在React中会把类似HTML的JSX结构转换成JavaScript的对象结构，如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"title\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>JSX 实际是一个对象，element包含以下信息：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: <span class=\"string\">\"Hello World!\"</span>,</span><br><span class=\"line\">    className: <span class=\"string\">\"title\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Babel会把JSX转译成一个名为React.createElement()函数调用。比如下面的两段代码，起到的作用是同等的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">\"greeting\"</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">'Hello, world!'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>实际上，JSX 仅仅只是React.createElement(component, props, …children)函数的语法糖。</p>\n<h2 id=\"使用大括号嵌入-JavaScript-表达式\"><a href=\"#使用大括号嵌入-JavaScript-表达式\" class=\"headerlink\" title=\"使用大括号嵌入 JavaScript 表达式\"></a>使用大括号嵌入 JavaScript 表达式</h2><p>在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Josh Perez'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>嵌入函数：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Josh Perez'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;getName()&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>注意：if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。</p>\n<h2 id=\"JSX-也是一个表达式\"><a href=\"#JSX-也是一个表达式\" class=\"headerlink\" title=\"JSX 也是一个表达式\"></a>JSX 也是一个表达式</h2><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>\n<p>也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'jofun'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGreeting</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;getName()&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;getGreeting('joe')&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSX-特定属性\"><a href=\"#JSX-特定属性\" class=\"headerlink\" title=\"JSX 特定属性\"></a>JSX 特定属性</h2><p>你可以通过使用引号，来将属性值指定为字符串字面量：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">tabIndex</span>=<span class=\"string\">\"0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>使用大括号，来在属性值中插入一个 JavaScript 表达式：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;user.avatarUrl&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>\n<p>注意：因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。如：tabindex 变为 tabIndex。需要特别注意的是，在JSX中要是会用到class和for属性时，需要将class换成 className，for换成 htmlFor。那是因为class和for是JavaScript中的关键字。</p>\n<h2 id=\"使用-JSX-指定子元素\"><a href=\"#使用-JSX-指定子元素\" class=\"headerlink\" title=\"使用 JSX 指定子元素\"></a>使用 JSX 指定子元素</h2><p>JSX 标签里和HTML一样能够嵌套包含子元素:<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;Good to see you here.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSX-防止注入攻击\"><a href=\"#JSX-防止注入攻击\" class=\"headerlink\" title=\"JSX 防止注入攻击\"></a>JSX 防止注入攻击</h2><p>你可以安全地在 JSX 当中插入用户输入内容：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> title = response.potentiallyMaliciousInput;</span><br><span class=\"line\"><span class=\"comment\">// 直接使用是安全的：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;title&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p>"},{"title":"前端静态资源自动化处理版本号防缓存","date":"2019-02-28T16:00:00.000Z","toc":false,"comments":0,"_content":"\n浏览器会默认缓存网站的静态资源文件，如：js文件、css文件、图片等。缓存带来网站性能提升的同时也带来了一些困扰，最常见的问题就是不能及时更新静态资源，造成新版本发布时用户无法及时看到新版本的变化，严重影响了用户体验。\n\n<!--more-->\n\n上述问题，最简单的办法就是在资源的请求路径上添加版本号，格式如下：\n```\nurl?v=1.0.0\n```\n每次在更改资源的时候，手动修改版本号，但是每次手动改那么多后缀有些费事，现在有很多的工具可以让我们更轻松的完成这项工具。本文将探讨使用目前最流行的前端构建工具 Gulp 和 Webpack 自动化为静态资源添加版本号防缓存处理。\n\n## 使用 Gulp 处理文件版本\n\nGulp 是一个简单易用的前端自动化构建工具，非常适合于构建多页面的工作流程。\n\n安装 Gulp（这里使用的是 Gulp 4+ 版本）：\n```\n$ npm install --save-dev gulp\n```\n\n安装 gulp-rev 插件：\n```\n$ npm install --save-dev gulp-rev\n```\ngulp-rev 插件的作用就是为静态资源添加版本号。\n\n新建 gulpfile.js 文件：\n```javascript\nconst gulp = require('gulp');\nconst rev = require('gulp-rev');\n\n// 添加版本号\ngulp.task('rev', () => {\n  return gulp.src('src/css/*.css')\n    .pipe(rev()) // 将所有匹配到的文件名全部生成相应的版本号\n    .pipe(gulp.dest('dist/css'))\n    .pipe(rev.manifest()) //把所有生成的带版本号的文件名保存到rev-manifest.json文件中\n    .pipe(gulp.dest('rev/css')) //把rev-manifest.json文件保存到指定的路径\n});\n```\n执行 rev 任务后，rev/css 文件加下多了一个 rev-manifest.json 文件。\n\nrev-manifest.json 文件的内容如下：\n```javascript\n{\n  \"index.css\": \"index-35c63c1fbe.css\"\n}\n```\n\n然后，安装 gulp-rev-collector 插件：\n```\n$ npm install --save-dev gulp-rev-collector\n```\ngulp-rev-collector 插件主要是配合 gulp-rev 替换文件版本号。\n\n修改 gulpfile.js 文件：\n```javascript\nconst gulp = require('gulp');\nconst rev = require('gulp-rev');\n\n// 添加版本号\ngulp.task('rev', () => {\n  return gulp.src('src/css/*.css')\n    .pipe(rev()) // 将所有匹配到的文件名全部生成相应的版本号\n    .pipe(gulp.dest('dist/css'))\n    .pipe(rev.manifest()) //把所有生成的带版本号的文件名保存到rev-manifest.json文件中\n    .pipe(gulp.dest('rev/css')) //把rev-manifest.json文件保存到指定的路径\n});\n\nconst revCollector = require('gulp-rev-collector');\n\n// 控制文件版本号\ngulp.task('rev-collector', () => {\n  return gulp.src(['rev/**/*.json', 'src/**/*.html'])\n    .pipe(revCollector({\n      replaceReved: true\n    }))\n    .pipe(gulp.dest('dist'))\n})\n\ngulp.task('default', gulp.series('clean', 'rev', 'rev-collector'))\n\n```\n执行 gulp 默认任务。检查 dist 下 index.html 文件 css 的版本是否替换成功。\n\n\n## 使用 Webpack 处理文件版本\n\nWebpack 是一个现代 JavaScript 应用程序的静态模块打包器，非常适合于构建单页面的工作流程，当然也可以构建多页面的工作流程。\n\n安装 Webpack（这里使用的是 webpack 4+ 版本）。\n```\n$ npm install --save-dev webpack webpack-cli\n```\n\n通过使用 output.filename 进行文件名替换，webpack 使用 [chunkhash] 替换文件名，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。\n\n安装 clean-webpack-plugin 插件（清理文件夹）：\n```\n$ npm install --save-dev clean-webpack-plugin\n```\nclean-webpack-plugin 插件的作用是清理文件夹，由于每次打包的文件版本不同，输出目录会生成很多不同版本的目标文件，所以需要清理文件夹。\n\n配置文件 webpack.config.js 如下：\n```javascript\nconst path = require('path');\nconst CleanWebpackPlugin = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.[chunkhash:5].js', //这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new CleanWebpackPlugin(['dist'])\n  ]\n}\n```\n\n在 src 目录新建一个 index.html 文件：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Webpack实现静态资源版本管理自动化</title>\n  </head>\n  <body>\n    <script src=\"index.js\"></script>\n  </body>\n</html>\n```\n\n安装 html-webpack-plugin 插件：\n```\n$ npm install --save-dev html-webpack-plugin\n```\nhtml-webpack-plugin 插件编译 html 替换带有哈希值版本信息的资源文件。\n\n修改 webpack.config.js 文件：\n```javascript\nconst path = require('path');\nconst CleanWebpackPlugin = require('clean-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.[chunkhash:5].js', //这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new CleanWebpackPlugin(['dist']),\n    new HtmlWebpackPlugin({\n      title: 'Webpack实现静态资源版本管理自动化'\n    })\n  ]\n}\n```\n\nhtml-webpack-plugin 默认入口文件为 index.html，具体的参数配置请参考[https://www.npmjs.com/package/html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)。\n关于 Webpack 处理缓存的更多教程请移步官方文档。\n","source":"_posts/2019-03-01-前端静态资源自动化处理版本号防缓存.md","raw":"---\ntitle: 前端静态资源自动化处理版本号防缓存\ndate: 2019-03-01\ntoc: false\ncomments: false\ntags:\n    - 浏览器缓存\n    - gulp\n    - gulp-rev\n    - gulp-rev-collector\n    - webpack\n    - clean-webpack-plugin\n    - html-webpack-plugin\n    - 前端自动化\ncategories:\n    - 前端构建工具\n---\n\n浏览器会默认缓存网站的静态资源文件，如：js文件、css文件、图片等。缓存带来网站性能提升的同时也带来了一些困扰，最常见的问题就是不能及时更新静态资源，造成新版本发布时用户无法及时看到新版本的变化，严重影响了用户体验。\n\n<!--more-->\n\n上述问题，最简单的办法就是在资源的请求路径上添加版本号，格式如下：\n```\nurl?v=1.0.0\n```\n每次在更改资源的时候，手动修改版本号，但是每次手动改那么多后缀有些费事，现在有很多的工具可以让我们更轻松的完成这项工具。本文将探讨使用目前最流行的前端构建工具 Gulp 和 Webpack 自动化为静态资源添加版本号防缓存处理。\n\n## 使用 Gulp 处理文件版本\n\nGulp 是一个简单易用的前端自动化构建工具，非常适合于构建多页面的工作流程。\n\n安装 Gulp（这里使用的是 Gulp 4+ 版本）：\n```\n$ npm install --save-dev gulp\n```\n\n安装 gulp-rev 插件：\n```\n$ npm install --save-dev gulp-rev\n```\ngulp-rev 插件的作用就是为静态资源添加版本号。\n\n新建 gulpfile.js 文件：\n```javascript\nconst gulp = require('gulp');\nconst rev = require('gulp-rev');\n\n// 添加版本号\ngulp.task('rev', () => {\n  return gulp.src('src/css/*.css')\n    .pipe(rev()) // 将所有匹配到的文件名全部生成相应的版本号\n    .pipe(gulp.dest('dist/css'))\n    .pipe(rev.manifest()) //把所有生成的带版本号的文件名保存到rev-manifest.json文件中\n    .pipe(gulp.dest('rev/css')) //把rev-manifest.json文件保存到指定的路径\n});\n```\n执行 rev 任务后，rev/css 文件加下多了一个 rev-manifest.json 文件。\n\nrev-manifest.json 文件的内容如下：\n```javascript\n{\n  \"index.css\": \"index-35c63c1fbe.css\"\n}\n```\n\n然后，安装 gulp-rev-collector 插件：\n```\n$ npm install --save-dev gulp-rev-collector\n```\ngulp-rev-collector 插件主要是配合 gulp-rev 替换文件版本号。\n\n修改 gulpfile.js 文件：\n```javascript\nconst gulp = require('gulp');\nconst rev = require('gulp-rev');\n\n// 添加版本号\ngulp.task('rev', () => {\n  return gulp.src('src/css/*.css')\n    .pipe(rev()) // 将所有匹配到的文件名全部生成相应的版本号\n    .pipe(gulp.dest('dist/css'))\n    .pipe(rev.manifest()) //把所有生成的带版本号的文件名保存到rev-manifest.json文件中\n    .pipe(gulp.dest('rev/css')) //把rev-manifest.json文件保存到指定的路径\n});\n\nconst revCollector = require('gulp-rev-collector');\n\n// 控制文件版本号\ngulp.task('rev-collector', () => {\n  return gulp.src(['rev/**/*.json', 'src/**/*.html'])\n    .pipe(revCollector({\n      replaceReved: true\n    }))\n    .pipe(gulp.dest('dist'))\n})\n\ngulp.task('default', gulp.series('clean', 'rev', 'rev-collector'))\n\n```\n执行 gulp 默认任务。检查 dist 下 index.html 文件 css 的版本是否替换成功。\n\n\n## 使用 Webpack 处理文件版本\n\nWebpack 是一个现代 JavaScript 应用程序的静态模块打包器，非常适合于构建单页面的工作流程，当然也可以构建多页面的工作流程。\n\n安装 Webpack（这里使用的是 webpack 4+ 版本）。\n```\n$ npm install --save-dev webpack webpack-cli\n```\n\n通过使用 output.filename 进行文件名替换，webpack 使用 [chunkhash] 替换文件名，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。\n\n安装 clean-webpack-plugin 插件（清理文件夹）：\n```\n$ npm install --save-dev clean-webpack-plugin\n```\nclean-webpack-plugin 插件的作用是清理文件夹，由于每次打包的文件版本不同，输出目录会生成很多不同版本的目标文件，所以需要清理文件夹。\n\n配置文件 webpack.config.js 如下：\n```javascript\nconst path = require('path');\nconst CleanWebpackPlugin = require('clean-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.[chunkhash:5].js', //这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new CleanWebpackPlugin(['dist'])\n  ]\n}\n```\n\n在 src 目录新建一个 index.html 文件：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Webpack实现静态资源版本管理自动化</title>\n  </head>\n  <body>\n    <script src=\"index.js\"></script>\n  </body>\n</html>\n```\n\n安装 html-webpack-plugin 插件：\n```\n$ npm install --save-dev html-webpack-plugin\n```\nhtml-webpack-plugin 插件编译 html 替换带有哈希值版本信息的资源文件。\n\n修改 webpack.config.js 文件：\n```javascript\nconst path = require('path');\nconst CleanWebpackPlugin = require('clean-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.[chunkhash:5].js', //这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new CleanWebpackPlugin(['dist']),\n    new HtmlWebpackPlugin({\n      title: 'Webpack实现静态资源版本管理自动化'\n    })\n  ]\n}\n```\n\nhtml-webpack-plugin 默认入口文件为 index.html，具体的参数配置请参考[https://www.npmjs.com/package/html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)。\n关于 Webpack 处理缓存的更多教程请移步官方文档。\n","slug":"2019-03-01-前端静态资源自动化处理版本号防缓存","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4as001macqxyraeontm","content":"<p>浏览器会默认缓存网站的静态资源文件，如：js文件、css文件、图片等。缓存带来网站性能提升的同时也带来了一些困扰，最常见的问题就是不能及时更新静态资源，造成新版本发布时用户无法及时看到新版本的变化，严重影响了用户体验。</p>\n<a id=\"more\"></a>\n<p>上述问题，最简单的办法就是在资源的请求路径上添加版本号，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url?v=1.0.0</span><br></pre></td></tr></table></figure></p>\n<p>每次在更改资源的时候，手动修改版本号，但是每次手动改那么多后缀有些费事，现在有很多的工具可以让我们更轻松的完成这项工具。本文将探讨使用目前最流行的前端构建工具 Gulp 和 Webpack 自动化为静态资源添加版本号防缓存处理。</p>\n<h2 id=\"使用-Gulp-处理文件版本\"><a href=\"#使用-Gulp-处理文件版本\" class=\"headerlink\" title=\"使用 Gulp 处理文件版本\"></a>使用 Gulp 处理文件版本</h2><p>Gulp 是一个简单易用的前端自动化构建工具，非常适合于构建多页面的工作流程。</p>\n<p>安装 Gulp（这里使用的是 Gulp 4+ 版本）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>\n<p>安装 gulp-rev 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-rev</span><br></pre></td></tr></table></figure></p>\n<p>gulp-rev 插件的作用就是为静态资源添加版本号。</p>\n<p>新建 gulpfile.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">    .pipe(rev()) <span class=\"comment\">// 将所有匹配到的文件名全部生成相应的版本号</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest()) <span class=\"comment\">//把所有生成的带版本号的文件名保存到rev-manifest.json文件中</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>)) <span class=\"comment\">//把rev-manifest.json文件保存到指定的路径</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行 rev 任务后，rev/css 文件加下多了一个 rev-manifest.json 文件。</p>\n<p>rev-manifest.json 文件的内容如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"index.css\"</span>: <span class=\"string\">\"index-35c63c1fbe.css\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，安装 gulp-rev-collector 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-rev-collector</span><br></pre></td></tr></table></figure></p>\n<p>gulp-rev-collector 插件主要是配合 gulp-rev 替换文件版本号。</p>\n<p>修改 gulpfile.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">    .pipe(rev()) <span class=\"comment\">// 将所有匹配到的文件名全部生成相应的版本号</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest()) <span class=\"comment\">//把所有生成的带版本号的文件名保存到rev-manifest.json文件中</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>)) <span class=\"comment\">//把rev-manifest.json文件保存到指定的路径</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> revCollector = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev-collector'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制文件版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev-collector'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/**/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector(&#123;</span><br><span class=\"line\">      replaceReved: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, gulp.series(<span class=\"string\">'clean'</span>, <span class=\"string\">'rev'</span>, <span class=\"string\">'rev-collector'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>执行 gulp 默认任务。检查 dist 下 index.html 文件 css 的版本是否替换成功。</p>\n<h2 id=\"使用-Webpack-处理文件版本\"><a href=\"#使用-Webpack-处理文件版本\" class=\"headerlink\" title=\"使用 Webpack 处理文件版本\"></a>使用 Webpack 处理文件版本</h2><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，非常适合于构建单页面的工作流程，当然也可以构建多页面的工作流程。</p>\n<p>安装 Webpack（这里使用的是 webpack 4+ 版本）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure></p>\n<p>通过使用 output.filename 进行文件名替换，webpack 使用 [chunkhash] 替换文件名，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。</p>\n<p>安装 clean-webpack-plugin 插件（清理文件夹）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure></p>\n<p>clean-webpack-plugin 插件的作用是清理文件夹，由于每次打包的文件版本不同，输出目录会生成很多不同版本的目标文件，所以需要清理文件夹。</p>\n<p>配置文件 webpack.config.js 如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash:5].js'</span>, <span class=\"comment\">//这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">'dist'</span>])</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录新建一个 index.html 文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Webpack实现静态资源版本管理自动化<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"index.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>安装 html-webpack-plugin 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></p>\n<p>html-webpack-plugin 插件编译 html 替换带有哈希值版本信息的资源文件。</p>\n<p>修改 webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash:5].js'</span>, <span class=\"comment\">//这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">'dist'</span>]),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      title: <span class=\"string\">'Webpack实现静态资源版本管理自动化'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>html-webpack-plugin 默认入口文件为 index.html，具体的参数配置请参考<a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a>。<br>关于 Webpack 处理缓存的更多教程请移步官方文档。</p>\n","site":{"data":{}},"excerpt":"<p>浏览器会默认缓存网站的静态资源文件，如：js文件、css文件、图片等。缓存带来网站性能提升的同时也带来了一些困扰，最常见的问题就是不能及时更新静态资源，造成新版本发布时用户无法及时看到新版本的变化，严重影响了用户体验。</p>","more":"<p>上述问题，最简单的办法就是在资源的请求路径上添加版本号，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url?v=1.0.0</span><br></pre></td></tr></table></figure></p>\n<p>每次在更改资源的时候，手动修改版本号，但是每次手动改那么多后缀有些费事，现在有很多的工具可以让我们更轻松的完成这项工具。本文将探讨使用目前最流行的前端构建工具 Gulp 和 Webpack 自动化为静态资源添加版本号防缓存处理。</p>\n<h2 id=\"使用-Gulp-处理文件版本\"><a href=\"#使用-Gulp-处理文件版本\" class=\"headerlink\" title=\"使用 Gulp 处理文件版本\"></a>使用 Gulp 处理文件版本</h2><p>Gulp 是一个简单易用的前端自动化构建工具，非常适合于构建多页面的工作流程。</p>\n<p>安装 Gulp（这里使用的是 Gulp 4+ 版本）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>\n<p>安装 gulp-rev 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-rev</span><br></pre></td></tr></table></figure></p>\n<p>gulp-rev 插件的作用就是为静态资源添加版本号。</p>\n<p>新建 gulpfile.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">    .pipe(rev()) <span class=\"comment\">// 将所有匹配到的文件名全部生成相应的版本号</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest()) <span class=\"comment\">//把所有生成的带版本号的文件名保存到rev-manifest.json文件中</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>)) <span class=\"comment\">//把rev-manifest.json文件保存到指定的路径</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行 rev 任务后，rev/css 文件加下多了一个 rev-manifest.json 文件。</p>\n<p>rev-manifest.json 文件的内容如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"index.css\"</span>: <span class=\"string\">\"index-35c63c1fbe.css\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，安装 gulp-rev-collector 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev gulp-rev-collector</span><br></pre></td></tr></table></figure></p>\n<p>gulp-rev-collector 插件主要是配合 gulp-rev 替换文件版本号。</p>\n<p>修改 gulpfile.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">    .pipe(rev()) <span class=\"comment\">// 将所有匹配到的文件名全部生成相应的版本号</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest()) <span class=\"comment\">//把所有生成的带版本号的文件名保存到rev-manifest.json文件中</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>)) <span class=\"comment\">//把rev-manifest.json文件保存到指定的路径</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> revCollector = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev-collector'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制文件版本号</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'rev-collector'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/**/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector(&#123;</span><br><span class=\"line\">      replaceReved: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, gulp.series(<span class=\"string\">'clean'</span>, <span class=\"string\">'rev'</span>, <span class=\"string\">'rev-collector'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>执行 gulp 默认任务。检查 dist 下 index.html 文件 css 的版本是否替换成功。</p>\n<h2 id=\"使用-Webpack-处理文件版本\"><a href=\"#使用-Webpack-处理文件版本\" class=\"headerlink\" title=\"使用 Webpack 处理文件版本\"></a>使用 Webpack 处理文件版本</h2><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，非常适合于构建单页面的工作流程，当然也可以构建多页面的工作流程。</p>\n<p>安装 Webpack（这里使用的是 webpack 4+ 版本）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure></p>\n<p>通过使用 output.filename 进行文件名替换，webpack 使用 [chunkhash] 替换文件名，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。</p>\n<p>安装 clean-webpack-plugin 插件（清理文件夹）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure></p>\n<p>clean-webpack-plugin 插件的作用是清理文件夹，由于每次打包的文件版本不同，输出目录会生成很多不同版本的目标文件，所以需要清理文件夹。</p>\n<p>配置文件 webpack.config.js 如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash:5].js'</span>, <span class=\"comment\">//这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">'dist'</span>])</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 src 目录新建一个 index.html 文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Webpack实现静态资源版本管理自动化<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"index.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>安装 html-webpack-plugin 插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></p>\n<p>html-webpack-plugin 插件编译 html 替换带有哈希值版本信息的资源文件。</p>\n<p>修改 webpack.config.js 文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CleanWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash:5].js'</span>, <span class=\"comment\">//这里设置 [chunkhash] 替换文件名，数字5为 chunkhash 的字符长度。</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin([<span class=\"string\">'dist'</span>]),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      title: <span class=\"string\">'Webpack实现静态资源版本管理自动化'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>html-webpack-plugin 默认入口文件为 index.html，具体的参数配置请参考<a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/html-webpack-plugin</a>。<br>关于 Webpack 处理缓存的更多教程请移步官方文档。</p>"},{"title":"理解高阶函数与闭包","date":"2019-08-20T16:00:00.000Z","toc":false,"comments":0,"_content":"\n什么是高阶函数？什么是闭包？为什么要把他们放在一起？\n\n<!--more-->\n\n## 高阶函数\n\n高阶函数是至少满足下列一个条件的函数:\n* 接受一个或多个函数作为输入\n* 输出一个函数\n\n即接受一个或多个函数作为参数或返回值是一个函数的函数，就称为高阶函数。\n\n在JavaScript中，函数是一等对象，如：\n```js\nfunction foo () {}\n      \nfoo.fname = '函数对象'\n\nconsole.log(foo.fname) // => '函数对象'\n```\n\n在JavaScript中，函数是一种数据类型，变量可以指向一个函数，如：\n```js\nconst foo = function () {\n  console.log('foo')\n}\n```\n\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数:\n```js\nfunction A () {\n  console.log('A')\n}\n\nfunction B (fn) {\n  console.log('B')\n  fn()\n}\n\n// 调用\nB(A)\n```\n\n函数可以作为返回值输出：\n```js\nfunction A () {\n  let count = 0;\n  \n  return function () {\n    return count++;\n  }\n}\n\nconst add = A()\n\nadd()\n```\n\n高阶函数在函数式编程中被广泛使用，在JavaScript数组对象中存在很多的使用高阶函数的方法，如：\n* Array.map\n* Array.reduce\n* Array.filter\n* Array.some\n* Array.sort\n* Array.from\n* Array.every\n* Array.forEach\n\n## 理解闭包\n\n什么是闭包？\n\n闭包是定义在一个函数内部且引用了该函数内部变量的函数。闭包是将函数内部和函数外部连接起来的桥梁。\n\n你能判断出那些是闭包函数吗？如下:\n```js\nfunction A () {\n  return function () {\n    let a = 5;\n    return a;\n  }\n}\n\nfunction B () {\n  return function (sum) {\n    return sum;\n  }\n}\n\nfunction C (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nfunction D () {\n  let a = 0;\n  \n  return function () {\n    return a++;\n  }\n}\n\nfunction E () {\n  let a = 0;\n  \n  return (function () {\n    return a++;\n  })()\n}\n\nfunction F () {\n  let a = 0;\n  \n  return (function (sum) {\n    return sum;\n  })(a++)\n}\n```\n其中，A、B、F都没有形成闭包，只有C和D实现了闭包。A、B没有形成闭包是因为它们的返回值函数内部都没有引用相应A、B函数的内部变量，而F没有形成闭包是由于它的返回值是一个立即执行函数且a是通过参数传递的。C能形成闭包环境是因为它的返回值函数引用了C的参数x，在D中，它的返回值函数引用了D的内部变量a，D也是闭包的一般形式，而E是因为它返回的立即执行函数内部直接引用了E的变量a，所以E是闭包。\n\n怎么知道一个函数是不是闭包？\n\n通过debugger在浏览器控制台中查看是否形成闭包环境，如函数D：\n```js\nfunction D () {\n  let a = 0;\n  \n  return function () {\n    debugger\n    return a++;\n  }\n}\n\nvar d = D();\n\nd();\n```\n如果出现红框中的Closure内容，即形成了闭包：\n![调试闭包示意图](/images/debugger_closure.png)\n\n需要注意区分高阶函数和闭包，一个函数内返回函数不一定形成闭包，只能说明这是一个高阶函数，只有当返回的函数体内引用了函数内部变量时，才会形成闭包。闭包的一个重要特征是**函数内引用了外层函数作用域的变量**。\n\n","source":"_posts/2019-08-21-理解高阶函数与闭包.md","raw":"---\ntitle: 理解高阶函数与闭包\ndate: 2019-08-21\ntoc: false\ncomments: false\ntags:\n    - 高阶函数\n    - 闭包\ncategories:\n    - JavaScript\n---\n\n什么是高阶函数？什么是闭包？为什么要把他们放在一起？\n\n<!--more-->\n\n## 高阶函数\n\n高阶函数是至少满足下列一个条件的函数:\n* 接受一个或多个函数作为输入\n* 输出一个函数\n\n即接受一个或多个函数作为参数或返回值是一个函数的函数，就称为高阶函数。\n\n在JavaScript中，函数是一等对象，如：\n```js\nfunction foo () {}\n      \nfoo.fname = '函数对象'\n\nconsole.log(foo.fname) // => '函数对象'\n```\n\n在JavaScript中，函数是一种数据类型，变量可以指向一个函数，如：\n```js\nconst foo = function () {\n  console.log('foo')\n}\n```\n\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数:\n```js\nfunction A () {\n  console.log('A')\n}\n\nfunction B (fn) {\n  console.log('B')\n  fn()\n}\n\n// 调用\nB(A)\n```\n\n函数可以作为返回值输出：\n```js\nfunction A () {\n  let count = 0;\n  \n  return function () {\n    return count++;\n  }\n}\n\nconst add = A()\n\nadd()\n```\n\n高阶函数在函数式编程中被广泛使用，在JavaScript数组对象中存在很多的使用高阶函数的方法，如：\n* Array.map\n* Array.reduce\n* Array.filter\n* Array.some\n* Array.sort\n* Array.from\n* Array.every\n* Array.forEach\n\n## 理解闭包\n\n什么是闭包？\n\n闭包是定义在一个函数内部且引用了该函数内部变量的函数。闭包是将函数内部和函数外部连接起来的桥梁。\n\n你能判断出那些是闭包函数吗？如下:\n```js\nfunction A () {\n  return function () {\n    let a = 5;\n    return a;\n  }\n}\n\nfunction B () {\n  return function (sum) {\n    return sum;\n  }\n}\n\nfunction C (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nfunction D () {\n  let a = 0;\n  \n  return function () {\n    return a++;\n  }\n}\n\nfunction E () {\n  let a = 0;\n  \n  return (function () {\n    return a++;\n  })()\n}\n\nfunction F () {\n  let a = 0;\n  \n  return (function (sum) {\n    return sum;\n  })(a++)\n}\n```\n其中，A、B、F都没有形成闭包，只有C和D实现了闭包。A、B没有形成闭包是因为它们的返回值函数内部都没有引用相应A、B函数的内部变量，而F没有形成闭包是由于它的返回值是一个立即执行函数且a是通过参数传递的。C能形成闭包环境是因为它的返回值函数引用了C的参数x，在D中，它的返回值函数引用了D的内部变量a，D也是闭包的一般形式，而E是因为它返回的立即执行函数内部直接引用了E的变量a，所以E是闭包。\n\n怎么知道一个函数是不是闭包？\n\n通过debugger在浏览器控制台中查看是否形成闭包环境，如函数D：\n```js\nfunction D () {\n  let a = 0;\n  \n  return function () {\n    debugger\n    return a++;\n  }\n}\n\nvar d = D();\n\nd();\n```\n如果出现红框中的Closure内容，即形成了闭包：\n![调试闭包示意图](/images/debugger_closure.png)\n\n需要注意区分高阶函数和闭包，一个函数内返回函数不一定形成闭包，只能说明这是一个高阶函数，只有当返回的函数体内引用了函数内部变量时，才会形成闭包。闭包的一个重要特征是**函数内引用了外层函数作用域的变量**。\n\n","slug":"2019-08-21-理解高阶函数与闭包","published":1,"updated":"2019-08-22T03:03:27.092Z","layout":"post","photos":[],"link":"","_id":"ck31ar4au001qacqx8sgqthwr","content":"<p>什么是高阶函数？什么是闭包？为什么要把他们放在一起？</p>\n<a id=\"more\"></a>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数是至少满足下列一个条件的函数:</p>\n<ul>\n<li>接受一个或多个函数作为输入</li>\n<li>输出一个函数</li>\n</ul>\n<p>即接受一个或多个函数作为参数或返回值是一个函数的函数，就称为高阶函数。</p>\n<p>在JavaScript中，函数是一等对象，如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">foo.fname = <span class=\"string\">'函数对象'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.fname) <span class=\"comment\">// =&gt; '函数对象'</span></span><br></pre></td></tr></table></figure></p>\n<p>在JavaScript中，函数是一种数据类型，变量可以指向一个函数，如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">B(A)</span><br></pre></td></tr></table></figure></p>\n<p>函数可以作为返回值输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = A()</span><br><span class=\"line\"></span><br><span class=\"line\">add()</span><br></pre></td></tr></table></figure></p>\n<p>高阶函数在函数式编程中被广泛使用，在JavaScript数组对象中存在很多的使用高阶函数的方法，如：</p>\n<ul>\n<li>Array.map</li>\n<li>Array.reduce</li>\n<li>Array.filter</li>\n<li>Array.some</li>\n<li>Array.sort</li>\n<li>Array.from</li>\n<li>Array.every</li>\n<li>Array.forEach</li>\n</ul>\n<h2 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h2><p>什么是闭包？</p>\n<p>闭包是定义在一个函数内部且引用了该函数内部变量的函数。闭包是将函数内部和函数外部连接起来的桥梁。</p>\n<p>你能判断出那些是闭包函数吗？如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sum</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">D</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">E</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sum</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;)(a++)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，A、B、F都没有形成闭包，只有C和D实现了闭包。A、B没有形成闭包是因为它们的返回值函数内部都没有引用相应A、B函数的内部变量，而F没有形成闭包是由于它的返回值是一个立即执行函数且a是通过参数传递的。C能形成闭包环境是因为它的返回值函数引用了C的参数x，在D中，它的返回值函数引用了D的内部变量a，D也是闭包的一般形式，而E是因为它返回的立即执行函数内部直接引用了E的变量a，所以E是闭包。</p>\n<p>怎么知道一个函数是不是闭包？</p>\n<p>通过debugger在浏览器控制台中查看是否形成闭包环境，如函数D：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">D</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">debugger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = D();</span><br><span class=\"line\"></span><br><span class=\"line\">d();</span><br></pre></td></tr></table></figure></p>\n<p>如果出现红框中的Closure内容，即形成了闭包：<br><img src=\"/images/debugger_closure.png\" alt=\"调试闭包示意图\"></p>\n<p>需要注意区分高阶函数和闭包，一个函数内返回函数不一定形成闭包，只能说明这是一个高阶函数，只有当返回的函数体内引用了函数内部变量时，才会形成闭包。闭包的一个重要特征是<strong>函数内引用了外层函数作用域的变量</strong>。</p>\n","site":{"data":{}},"excerpt":"<p>什么是高阶函数？什么是闭包？为什么要把他们放在一起？</p>","more":"<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数是至少满足下列一个条件的函数:</p>\n<ul>\n<li>接受一个或多个函数作为输入</li>\n<li>输出一个函数</li>\n</ul>\n<p>即接受一个或多个函数作为参数或返回值是一个函数的函数，就称为高阶函数。</p>\n<p>在JavaScript中，函数是一等对象，如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">foo.fname = <span class=\"string\">'函数对象'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.fname) <span class=\"comment\">// =&gt; '函数对象'</span></span><br></pre></td></tr></table></figure></p>\n<p>在JavaScript中，函数是一种数据类型，变量可以指向一个函数，如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">  fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">B(A)</span><br></pre></td></tr></table></figure></p>\n<p>函数可以作为返回值输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = A()</span><br><span class=\"line\"></span><br><span class=\"line\">add()</span><br></pre></td></tr></table></figure></p>\n<p>高阶函数在函数式编程中被广泛使用，在JavaScript数组对象中存在很多的使用高阶函数的方法，如：</p>\n<ul>\n<li>Array.map</li>\n<li>Array.reduce</li>\n<li>Array.filter</li>\n<li>Array.some</li>\n<li>Array.sort</li>\n<li>Array.from</li>\n<li>Array.every</li>\n<li>Array.forEach</li>\n</ul>\n<h2 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h2><p>什么是闭包？</p>\n<p>闭包是定义在一个函数内部且引用了该函数内部变量的函数。闭包是将函数内部和函数外部连接起来的桥梁。</p>\n<p>你能判断出那些是闭包函数吗？如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sum</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">D</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">E</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sum</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;)(a++)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，A、B、F都没有形成闭包，只有C和D实现了闭包。A、B没有形成闭包是因为它们的返回值函数内部都没有引用相应A、B函数的内部变量，而F没有形成闭包是由于它的返回值是一个立即执行函数且a是通过参数传递的。C能形成闭包环境是因为它的返回值函数引用了C的参数x，在D中，它的返回值函数引用了D的内部变量a，D也是闭包的一般形式，而E是因为它返回的立即执行函数内部直接引用了E的变量a，所以E是闭包。</p>\n<p>怎么知道一个函数是不是闭包？</p>\n<p>通过debugger在浏览器控制台中查看是否形成闭包环境，如函数D：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">D</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">debugger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = D();</span><br><span class=\"line\"></span><br><span class=\"line\">d();</span><br></pre></td></tr></table></figure></p>\n<p>如果出现红框中的Closure内容，即形成了闭包：<br><img src=\"/images/debugger_closure.png\" alt=\"调试闭包示意图\"></p>\n<p>需要注意区分高阶函数和闭包，一个函数内返回函数不一定形成闭包，只能说明这是一个高阶函数，只有当返回的函数体内引用了函数内部变量时，才会形成闭包。闭包的一个重要特征是<strong>函数内引用了外层函数作用域的变量</strong>。</p>"},{"title":"CSS计数器及其应用","date":"2019-08-26T16:00:00.000Z","toc":false,"comments":0,"_content":"\n假设您有一个未知数量的 div 元素，并且(出于某种原因)您想要计算它们的数量，并自动为它们彼此编号——您将如何做到这一点？您的第一个想法可能是使用Javascript来处理DOM。其实你完全可以用CSS来做。\n\n<!--more-->\n\n## CSS计数器\n\nCSS 计数器通过一个变量来设置，根据规则递增变量。CSS 计数器使用到以下几个属性：\n* counter-reset - 创建或者重置计数器\n* counter-increment - 递增变量\n* content - 插入生成的内容\n* counter() 或 counters() 函数 - 将计数器的值添加到元素\n\n## 自动编号HTML元素\n\n要使用 CSS 计数器，得先用 counter-reset 创建计数器，如下：\n```css\n.demo {\n  counter-reset: section;\n}\n\n.demo div:before {\n  counter-increment: section;\n  content: \"section \" counter(section);\n}\n```\n```html\n<div class=\"demo\">\n  <div></div>\n  <div></div>\n  <div></div>\n</div>\n```\n渲染结果如下：\n> section 1\n> section 2\n> section 3\n\n可以在计数器名称后面使用指定初始编号，如下：\n```css\n.demo {\n  counter-reset: section -1;\n}\n\n.demo div:before {\n  counter-increment: section;\n  content: \"section \" counter(section);\n}\n```\n此时，渲染结果如下：\n> section 0\n> section 1\n> section 2\n\n\n## 嵌套计数器\n\n以下实例在页面创建一个计数器，在每一个 h1 元素前添加计数值 \"Section <主标题计数值>.\", 嵌套的计数值则放在 h2 元素的前面，内容为 \"<主标题计数值>.<副标题计数值>\":\n```css\nbody {\n  counter-reset: section;\n}\n\nh1 {\n  counter-reset: subsection;\n}\n\nh1::before {\n  counter-increment: section;\n  content: \"Section \"counter(section)\" - \";\n}\n\nh2::before {\n  counter-increment: subsection;\n  content: counter(section)\".\"counter(subsection)\"、\";\n}\n```\n```html\n<h1>HTML教程</h1>\n<h2>简介</h2>\n<h2>编辑器</h2>\n\n<h1>CSS教程</h1>\n<h2>简介</h2>\n<h2>语法</h2>\n\n<h1>JavaScript教程</h1>\n<h2>简介</h2>\n<h2>用法</h2>\n```\n渲染结果如下：\n> ** Section 1 - HTML教程 **\n> 1.1、简介\n> 1.2、编辑器\n> ** Section 2 - CSS教程 **\n> 2.1、简介\n> 2.2、语法\n> ** Section 3 - JavaScript教程 **\n> 3.1、简介\n> 3.2、用法\n\n计数器也可用于列表中，列表的子元素会自动创建。这里我们需要使用 counters() 函数在不同的嵌套层级中插入字符串:\n```css\nol {\n  counter-reset: section;\n  list-style-type: none;\n}\n\nli::before {\n  counter-increment: section;\n  content: counters(section,\".\") \" \";\n}\n```\n```html\n<ol>\n  <li>item</li>\n  <li>item   \n    <ol>\n      <li>item</li>\n      <li>item</li>\n      <li>item\n        <ol>\n          <li>item</li>\n          <li>item</li>\n          <li>item</li>\n        </ol>\n      </li>\n      <li>item</li>\n    </ol>\n  </li>\n  <li>item</li>\n  <li>item</li>\n</ol>\n```\n渲染结果如下：\n> 1 item\n> 2 item\n>> 2.1 item\n>> 2.2 item\n>> 2.3 item\n>>> 2.3.1 item\n>>> 2.3.2 item\n>>> 2.3.3 item\n>>>\n>> 2.4 item\n>>\n> 3 item\n> 4 item","source":"_posts/2019-08-27-CSS计数器及其应用.md","raw":"---\ntitle: CSS计数器及其应用\ndate: 2019-08-27\ntoc: false\ncomments: false\ntags:\n    - CSS计数器\ncategories:\n    - CSS\n---\n\n假设您有一个未知数量的 div 元素，并且(出于某种原因)您想要计算它们的数量，并自动为它们彼此编号——您将如何做到这一点？您的第一个想法可能是使用Javascript来处理DOM。其实你完全可以用CSS来做。\n\n<!--more-->\n\n## CSS计数器\n\nCSS 计数器通过一个变量来设置，根据规则递增变量。CSS 计数器使用到以下几个属性：\n* counter-reset - 创建或者重置计数器\n* counter-increment - 递增变量\n* content - 插入生成的内容\n* counter() 或 counters() 函数 - 将计数器的值添加到元素\n\n## 自动编号HTML元素\n\n要使用 CSS 计数器，得先用 counter-reset 创建计数器，如下：\n```css\n.demo {\n  counter-reset: section;\n}\n\n.demo div:before {\n  counter-increment: section;\n  content: \"section \" counter(section);\n}\n```\n```html\n<div class=\"demo\">\n  <div></div>\n  <div></div>\n  <div></div>\n</div>\n```\n渲染结果如下：\n> section 1\n> section 2\n> section 3\n\n可以在计数器名称后面使用指定初始编号，如下：\n```css\n.demo {\n  counter-reset: section -1;\n}\n\n.demo div:before {\n  counter-increment: section;\n  content: \"section \" counter(section);\n}\n```\n此时，渲染结果如下：\n> section 0\n> section 1\n> section 2\n\n\n## 嵌套计数器\n\n以下实例在页面创建一个计数器，在每一个 h1 元素前添加计数值 \"Section <主标题计数值>.\", 嵌套的计数值则放在 h2 元素的前面，内容为 \"<主标题计数值>.<副标题计数值>\":\n```css\nbody {\n  counter-reset: section;\n}\n\nh1 {\n  counter-reset: subsection;\n}\n\nh1::before {\n  counter-increment: section;\n  content: \"Section \"counter(section)\" - \";\n}\n\nh2::before {\n  counter-increment: subsection;\n  content: counter(section)\".\"counter(subsection)\"、\";\n}\n```\n```html\n<h1>HTML教程</h1>\n<h2>简介</h2>\n<h2>编辑器</h2>\n\n<h1>CSS教程</h1>\n<h2>简介</h2>\n<h2>语法</h2>\n\n<h1>JavaScript教程</h1>\n<h2>简介</h2>\n<h2>用法</h2>\n```\n渲染结果如下：\n> ** Section 1 - HTML教程 **\n> 1.1、简介\n> 1.2、编辑器\n> ** Section 2 - CSS教程 **\n> 2.1、简介\n> 2.2、语法\n> ** Section 3 - JavaScript教程 **\n> 3.1、简介\n> 3.2、用法\n\n计数器也可用于列表中，列表的子元素会自动创建。这里我们需要使用 counters() 函数在不同的嵌套层级中插入字符串:\n```css\nol {\n  counter-reset: section;\n  list-style-type: none;\n}\n\nli::before {\n  counter-increment: section;\n  content: counters(section,\".\") \" \";\n}\n```\n```html\n<ol>\n  <li>item</li>\n  <li>item   \n    <ol>\n      <li>item</li>\n      <li>item</li>\n      <li>item\n        <ol>\n          <li>item</li>\n          <li>item</li>\n          <li>item</li>\n        </ol>\n      </li>\n      <li>item</li>\n    </ol>\n  </li>\n  <li>item</li>\n  <li>item</li>\n</ol>\n```\n渲染结果如下：\n> 1 item\n> 2 item\n>> 2.1 item\n>> 2.2 item\n>> 2.3 item\n>>> 2.3.1 item\n>>> 2.3.2 item\n>>> 2.3.3 item\n>>>\n>> 2.4 item\n>>\n> 3 item\n> 4 item","slug":"2019-08-27-CSS计数器及其应用","published":1,"updated":"2019-08-30T03:24:23.574Z","layout":"post","photos":[],"link":"","_id":"ck31ar4aw001uacqxs0303z5n","content":"<p>假设您有一个未知数量的 div 元素，并且(出于某种原因)您想要计算它们的数量，并自动为它们彼此编号——您将如何做到这一点？您的第一个想法可能是使用Javascript来处理DOM。其实你完全可以用CSS来做。</p>\n<a id=\"more\"></a>\n<h2 id=\"CSS计数器\"><a href=\"#CSS计数器\" class=\"headerlink\" title=\"CSS计数器\"></a>CSS计数器</h2><p>CSS 计数器通过一个变量来设置，根据规则递增变量。CSS 计数器使用到以下几个属性：</p>\n<ul>\n<li>counter-reset - 创建或者重置计数器</li>\n<li>counter-increment - 递增变量</li>\n<li>content - 插入生成的内容</li>\n<li>counter() 或 counters() 函数 - 将计数器的值添加到元素</li>\n</ul>\n<h2 id=\"自动编号HTML元素\"><a href=\"#自动编号HTML元素\" class=\"headerlink\" title=\"自动编号HTML元素\"></a>自动编号HTML元素</h2><p>要使用 CSS 计数器，得先用 counter-reset 创建计数器，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"section \"</span> <span class=\"built_in\">counter</span>(section);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p>section 1<br>section 2<br>section 3</p>\n</blockquote>\n<p>可以在计数器名称后面使用指定初始编号，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"section \"</span> <span class=\"built_in\">counter</span>(section);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，渲染结果如下：</p>\n<blockquote>\n<p>section 0<br>section 1<br>section 2</p>\n</blockquote>\n<h2 id=\"嵌套计数器\"><a href=\"#嵌套计数器\" class=\"headerlink\" title=\"嵌套计数器\"></a>嵌套计数器</h2><p>以下实例在页面创建一个计数器，在每一个 h1 元素前添加计数值 “Section &lt;主标题计数值&gt;.”, 嵌套的计数值则放在 h2 元素的前面，内容为 “&lt;主标题计数值&gt;.&lt;副标题计数值&gt;”:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: subsection;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Section \"</span><span class=\"built_in\">counter</span>(section)<span class=\"string\">\" - \"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h2</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: subsection;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">counter</span>(section)<span class=\"string\">\".\"</span><span class=\"built_in\">counter</span>(subsection)<span class=\"string\">\"、\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>HTML教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>编辑器<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>CSS教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>语法<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>JavaScript教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用法<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p><strong> Section 1 - HTML教程 </strong><br>1.1、简介<br>1.2、编辑器<br><strong> Section 2 - CSS教程 </strong><br>2.1、简介<br>2.2、语法<br><strong> Section 3 - JavaScript教程 </strong><br>3.1、简介<br>3.2、用法</p>\n</blockquote>\n<p>计数器也可用于列表中，列表的子元素会自动创建。这里我们需要使用 counters() 函数在不同的嵌套层级中插入字符串:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">counters</span>(section,<span class=\"string\">\".\"</span>) <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item   </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p>1 item<br>2 item</p>\n<blockquote>\n<p>2.1 item<br>2.2 item<br>2.3 item</p>\n<blockquote>\n<p>2.3.1 item<br>2.3.2 item<br>2.3.3 item</p>\n</blockquote>\n<p>2.4 item</p>\n</blockquote>\n<p>3 item<br>4 item</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>假设您有一个未知数量的 div 元素，并且(出于某种原因)您想要计算它们的数量，并自动为它们彼此编号——您将如何做到这一点？您的第一个想法可能是使用Javascript来处理DOM。其实你完全可以用CSS来做。</p>","more":"<h2 id=\"CSS计数器\"><a href=\"#CSS计数器\" class=\"headerlink\" title=\"CSS计数器\"></a>CSS计数器</h2><p>CSS 计数器通过一个变量来设置，根据规则递增变量。CSS 计数器使用到以下几个属性：</p>\n<ul>\n<li>counter-reset - 创建或者重置计数器</li>\n<li>counter-increment - 递增变量</li>\n<li>content - 插入生成的内容</li>\n<li>counter() 或 counters() 函数 - 将计数器的值添加到元素</li>\n</ul>\n<h2 id=\"自动编号HTML元素\"><a href=\"#自动编号HTML元素\" class=\"headerlink\" title=\"自动编号HTML元素\"></a>自动编号HTML元素</h2><p>要使用 CSS 计数器，得先用 counter-reset 创建计数器，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"section \"</span> <span class=\"built_in\">counter</span>(section);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p>section 1<br>section 2<br>section 3</p>\n</blockquote>\n<p>可以在计数器名称后面使用指定初始编号，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"section \"</span> <span class=\"built_in\">counter</span>(section);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，渲染结果如下：</p>\n<blockquote>\n<p>section 0<br>section 1<br>section 2</p>\n</blockquote>\n<h2 id=\"嵌套计数器\"><a href=\"#嵌套计数器\" class=\"headerlink\" title=\"嵌套计数器\"></a>嵌套计数器</h2><p>以下实例在页面创建一个计数器，在每一个 h1 元素前添加计数值 “Section &lt;主标题计数值&gt;.”, 嵌套的计数值则放在 h2 元素的前面，内容为 “&lt;主标题计数值&gt;.&lt;副标题计数值&gt;”:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: subsection;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Section \"</span><span class=\"built_in\">counter</span>(section)<span class=\"string\">\" - \"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h2</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: subsection;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">counter</span>(section)<span class=\"string\">\".\"</span><span class=\"built_in\">counter</span>(subsection)<span class=\"string\">\"、\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>HTML教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>编辑器<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>CSS教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>语法<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>JavaScript教程<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>简介<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用法<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p><strong> Section 1 - HTML教程 </strong><br>1.1、简介<br>1.2、编辑器<br><strong> Section 2 - CSS教程 </strong><br>2.1、简介<br>2.2、语法<br><strong> Section 3 - JavaScript教程 </strong><br>3.1、简介<br>3.2、用法</p>\n</blockquote>\n<p>计数器也可用于列表中，列表的子元素会自动创建。这里我们需要使用 counters() 函数在不同的嵌套层级中插入字符串:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-reset</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">counter-increment</span>: section;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"built_in\">counters</span>(section,<span class=\"string\">\".\"</span>) <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item   </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>item<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>渲染结果如下：</p>\n<blockquote>\n<p>1 item<br>2 item</p>\n<blockquote>\n<p>2.1 item<br>2.2 item<br>2.3 item</p>\n<blockquote>\n<p>2.3.1 item<br>2.3.2 item<br>2.3.3 item</p>\n</blockquote>\n<p>2.4 item</p>\n</blockquote>\n<p>3 item<br>4 item</p>\n</blockquote>"},{"title":"数据结构与开发应用之栈","date":"2019-08-27T16:00:00.000Z","toc":false,"comments":0,"_content":"\n栈（stack）又名堆栈，是一种遵从后进先出（LIFO）原则的有序集合。新添加的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n<!--more-->\n\n## 理解栈\n\n栈，要搞清楚这个概念，首先要明白“栈”原来的意思，如此才能把握本质。“栈”者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。\n\n栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。\n\n栈顶、栈底如下图所示：\n\n![栈顶、栈底示意图](/images/2-1Q201204153P8.gif)\n\n出栈、入栈如下图所示：\n\n![出栈、入栈示意图](/images/2-1Q201203Q5110.gif)\n\n入栈顺序如下：\n```\n1 -> 2 -> 3 -> 4\n```\n1最先入栈，4最后入栈。\n\n出栈顺序如下：\n```\n4 -> 3 -> 2 -> 1\n```\n4最先出栈，1最后出栈。\n\n## 栈的实现\n\n基于栈的特性，可以用数组做线性表进行存储。\n\n一个简单的Stack类实现如下：\n```js\nclass Stack {\n  constructor () {\n    this.data = []\n  }\n  \n  push (val) {\n    this.data.push(val)\n  }\n  \n  pop () {\n    return this.data.pop()\n  }\n  \n  clear () {\n    this.data = []\n  }\n  \n  size () {\n    return this.data.length\n  }\n  \n  isEmpty () {\n    return this.data.length === 0\n  }\n}\n```\n上面Stack类实现了下面的基本功能：\n* push：入栈函数\n* pop：出栈函数\n* clear：清空栈\n* size：获取栈的大小\n* isEmpty：是否为空栈\n\n## 栈的应用\n\n栈是一种简单的数据结构，和数组结构较为相似，是一种常见且应用广泛的结构。\n\n## 反转字符串\n\n字符串反转实现如下：\n```js\nfunction reverse (string) {\n  const stack = new Stack()\n  \n  for (var i = 0, len = string.length; i < len; i++) {\n    stack.push(string.charAt(i))\n  }\n\n  let result = ''\n\n  while(!stack.isEmpty()) {\n    result += stack.pop()\n  }\n  \n  return result\n}\n```\n测试结果如下：\n```js\nvar str = 'abc';\n\nreverse(str) // => 'cba'\n```\n\n## 校验字符串中的括号是否合法\n\n有些特殊符号必须成对出现，如：（）、《》、“”等，以括号为例使用栈辅助检验其合法性的步骤如下：\n* 遍历字符串\n* 遇到左括号“(”时，将其压入栈内\n* 遇到右括号“)”时，如果栈为空则不合法返回false，如果栈不为空执行退栈操作\n* 遍历结束后，如果栈为空则合法返回true，反之不合法返回false\n\n校验字符串中的括号是否合法，实现如下\n```js\nfunction isLegalString (string) {\n  const stack = new Stack()\n  \n  for (var i = 0, len = string.length; i < len; i++) {\n    const letter = string.charAt(i)\n    \n    // 遇到左括号'('时，压栈\n    if (letter === '(') {\n      stack.push(letter)\n    }\n    \n    // 遇到右括号'('时，如果栈为空则不合法，如果栈不为空则出栈\n    if (letter === ')') {\n      if (stack.isEmpty()) {\n        return false\n      } else {\n        stack.pop()\n      }\n    }\n  }\n  \n  // 最后，如果栈为空则合法，反之不合法\n  return stack.isEmpty()\n}\n\nvar a = '()';\nvar b = '(()';\nvar c = '(()())';\n\nisLegalString(a) // => true\nisLegalString(b) // => false\nisLegalString(c) // => true\n```\n\n","source":"_posts/2019-08-28-数据结构与开发应用之栈.md","raw":"---\ntitle: 数据结构与开发应用之栈\ndate: 2019-08-28\ntoc: false\ncomments: false\ntags:\n    - 栈\ncategories:\n    - 数据结构\n---\n\n栈（stack）又名堆栈，是一种遵从后进先出（LIFO）原则的有序集合。新添加的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n<!--more-->\n\n## 理解栈\n\n栈，要搞清楚这个概念，首先要明白“栈”原来的意思，如此才能把握本质。“栈”者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。\n\n栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。\n\n栈顶、栈底如下图所示：\n\n![栈顶、栈底示意图](/images/2-1Q201204153P8.gif)\n\n出栈、入栈如下图所示：\n\n![出栈、入栈示意图](/images/2-1Q201203Q5110.gif)\n\n入栈顺序如下：\n```\n1 -> 2 -> 3 -> 4\n```\n1最先入栈，4最后入栈。\n\n出栈顺序如下：\n```\n4 -> 3 -> 2 -> 1\n```\n4最先出栈，1最后出栈。\n\n## 栈的实现\n\n基于栈的特性，可以用数组做线性表进行存储。\n\n一个简单的Stack类实现如下：\n```js\nclass Stack {\n  constructor () {\n    this.data = []\n  }\n  \n  push (val) {\n    this.data.push(val)\n  }\n  \n  pop () {\n    return this.data.pop()\n  }\n  \n  clear () {\n    this.data = []\n  }\n  \n  size () {\n    return this.data.length\n  }\n  \n  isEmpty () {\n    return this.data.length === 0\n  }\n}\n```\n上面Stack类实现了下面的基本功能：\n* push：入栈函数\n* pop：出栈函数\n* clear：清空栈\n* size：获取栈的大小\n* isEmpty：是否为空栈\n\n## 栈的应用\n\n栈是一种简单的数据结构，和数组结构较为相似，是一种常见且应用广泛的结构。\n\n## 反转字符串\n\n字符串反转实现如下：\n```js\nfunction reverse (string) {\n  const stack = new Stack()\n  \n  for (var i = 0, len = string.length; i < len; i++) {\n    stack.push(string.charAt(i))\n  }\n\n  let result = ''\n\n  while(!stack.isEmpty()) {\n    result += stack.pop()\n  }\n  \n  return result\n}\n```\n测试结果如下：\n```js\nvar str = 'abc';\n\nreverse(str) // => 'cba'\n```\n\n## 校验字符串中的括号是否合法\n\n有些特殊符号必须成对出现，如：（）、《》、“”等，以括号为例使用栈辅助检验其合法性的步骤如下：\n* 遍历字符串\n* 遇到左括号“(”时，将其压入栈内\n* 遇到右括号“)”时，如果栈为空则不合法返回false，如果栈不为空执行退栈操作\n* 遍历结束后，如果栈为空则合法返回true，反之不合法返回false\n\n校验字符串中的括号是否合法，实现如下\n```js\nfunction isLegalString (string) {\n  const stack = new Stack()\n  \n  for (var i = 0, len = string.length; i < len; i++) {\n    const letter = string.charAt(i)\n    \n    // 遇到左括号'('时，压栈\n    if (letter === '(') {\n      stack.push(letter)\n    }\n    \n    // 遇到右括号'('时，如果栈为空则不合法，如果栈不为空则出栈\n    if (letter === ')') {\n      if (stack.isEmpty()) {\n        return false\n      } else {\n        stack.pop()\n      }\n    }\n  }\n  \n  // 最后，如果栈为空则合法，反之不合法\n  return stack.isEmpty()\n}\n\nvar a = '()';\nvar b = '(()';\nvar c = '(()())';\n\nisLegalString(a) // => true\nisLegalString(b) // => false\nisLegalString(c) // => true\n```\n\n","slug":"2019-08-28-数据结构与开发应用之栈","published":1,"updated":"2019-08-30T01:52:28.377Z","layout":"post","photos":[],"link":"","_id":"ck31ar4ay001xacqxl8m4gid7","content":"<p>栈（stack）又名堆栈，是一种遵从后进先出（LIFO）原则的有序集合。新添加的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>\n<a id=\"more\"></a>\n<h2 id=\"理解栈\"><a href=\"#理解栈\" class=\"headerlink\" title=\"理解栈\"></a>理解栈</h2><p>栈，要搞清楚这个概念，首先要明白“栈”原来的意思，如此才能把握本质。“栈”者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。</p>\n<p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>\n<p>栈顶、栈底如下图所示：</p>\n<p><img src=\"/images/2-1Q201204153P8.gif\" alt=\"栈顶、栈底示意图\"></p>\n<p>出栈、入栈如下图所示：</p>\n<p><img src=\"/images/2-1Q201203Q5110.gif\" alt=\"出栈、入栈示意图\"></p>\n<p>入栈顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 -&gt; 2 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure></p>\n<p>1最先入栈，4最后入栈。</p>\n<p>出栈顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 -&gt; 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure></p>\n<p>4最先出栈，1最后出栈。</p>\n<h2 id=\"栈的实现\"><a href=\"#栈的实现\" class=\"headerlink\" title=\"栈的实现\"></a>栈的实现</h2><p>基于栈的特性，可以用数组做线性表进行存储。</p>\n<p>一个简单的Stack类实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  push (val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data.push(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  pop () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.pop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  clear () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  size () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  isEmpty () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面Stack类实现了下面的基本功能：</p>\n<ul>\n<li>push：入栈函数</li>\n<li>pop：出栈函数</li>\n<li>clear：清空栈</li>\n<li>size：获取栈的大小</li>\n<li>isEmpty：是否为空栈</li>\n</ul>\n<h2 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h2><p>栈是一种简单的数据结构，和数组结构较为相似，是一种常见且应用广泛的结构。</p>\n<h2 id=\"反转字符串\"><a href=\"#反转字符串\" class=\"headerlink\" title=\"反转字符串\"></a>反转字符串</h2><p>字符串反转实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverse</span> (<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = string.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    stack.push(string.charAt(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">    result += stack.pop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">reverse(str) <span class=\"comment\">// =&gt; 'cba'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"校验字符串中的括号是否合法\"><a href=\"#校验字符串中的括号是否合法\" class=\"headerlink\" title=\"校验字符串中的括号是否合法\"></a>校验字符串中的括号是否合法</h2><p>有些特殊符号必须成对出现，如：（）、《》、“”等，以括号为例使用栈辅助检验其合法性的步骤如下：</p>\n<ul>\n<li>遍历字符串</li>\n<li>遇到左括号“(”时，将其压入栈内</li>\n<li>遇到右括号“)”时，如果栈为空则不合法返回false，如果栈不为空执行退栈操作</li>\n<li>遍历结束后，如果栈为空则合法返回true，反之不合法返回false</li>\n</ul>\n<p>校验字符串中的括号是否合法，实现如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isLegalString</span> (<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = string.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> letter = string.charAt(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到左括号'('时，压栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letter === <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">      stack.push(letter)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到右括号'('时，如果栈为空则不合法，如果栈不为空则出栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letter === <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack.pop()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 最后，如果栈为空则合法，反之不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack.isEmpty()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'()'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'(()'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'(()())'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isLegalString(a) <span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\">isLegalString(b) <span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\">isLegalString(c) <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>栈（stack）又名堆栈，是一种遵从后进先出（LIFO）原则的有序集合。新添加的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>","more":"<h2 id=\"理解栈\"><a href=\"#理解栈\" class=\"headerlink\" title=\"理解栈\"></a>理解栈</h2><p>栈，要搞清楚这个概念，首先要明白“栈”原来的意思，如此才能把握本质。“栈”者，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。</p>\n<p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>\n<p>栈顶、栈底如下图所示：</p>\n<p><img src=\"/images/2-1Q201204153P8.gif\" alt=\"栈顶、栈底示意图\"></p>\n<p>出栈、入栈如下图所示：</p>\n<p><img src=\"/images/2-1Q201203Q5110.gif\" alt=\"出栈、入栈示意图\"></p>\n<p>入栈顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 -&gt; 2 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure></p>\n<p>1最先入栈，4最后入栈。</p>\n<p>出栈顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 -&gt; 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure></p>\n<p>4最先出栈，1最后出栈。</p>\n<h2 id=\"栈的实现\"><a href=\"#栈的实现\" class=\"headerlink\" title=\"栈的实现\"></a>栈的实现</h2><p>基于栈的特性，可以用数组做线性表进行存储。</p>\n<p>一个简单的Stack类实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  push (val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data.push(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  pop () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.pop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  clear () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  size () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  isEmpty () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面Stack类实现了下面的基本功能：</p>\n<ul>\n<li>push：入栈函数</li>\n<li>pop：出栈函数</li>\n<li>clear：清空栈</li>\n<li>size：获取栈的大小</li>\n<li>isEmpty：是否为空栈</li>\n</ul>\n<h2 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h2><p>栈是一种简单的数据结构，和数组结构较为相似，是一种常见且应用广泛的结构。</p>\n<h2 id=\"反转字符串\"><a href=\"#反转字符串\" class=\"headerlink\" title=\"反转字符串\"></a>反转字符串</h2><p>字符串反转实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverse</span> (<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = string.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    stack.push(string.charAt(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">    result += stack.pop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">reverse(str) <span class=\"comment\">// =&gt; 'cba'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"校验字符串中的括号是否合法\"><a href=\"#校验字符串中的括号是否合法\" class=\"headerlink\" title=\"校验字符串中的括号是否合法\"></a>校验字符串中的括号是否合法</h2><p>有些特殊符号必须成对出现，如：（）、《》、“”等，以括号为例使用栈辅助检验其合法性的步骤如下：</p>\n<ul>\n<li>遍历字符串</li>\n<li>遇到左括号“(”时，将其压入栈内</li>\n<li>遇到右括号“)”时，如果栈为空则不合法返回false，如果栈不为空执行退栈操作</li>\n<li>遍历结束后，如果栈为空则合法返回true，反之不合法返回false</li>\n</ul>\n<p>校验字符串中的括号是否合法，实现如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isLegalString</span> (<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = string.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> letter = string.charAt(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到左括号'('时，压栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letter === <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">      stack.push(letter)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遇到右括号'('时，如果栈为空则不合法，如果栈不为空则出栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letter === <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack.pop()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 最后，如果栈为空则合法，反之不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack.isEmpty()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'()'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">'(()'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">'(()())'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isLegalString(a) <span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\">isLegalString(b) <span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\">isLegalString(c) <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>"},{"title":"数据结构与开发应用之队列","date":"2019-08-30T16:00:00.000Z","toc":false,"comments":0,"_content":"\n队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出线性表。\n\n<!--more-->\n\n## 理解队列\n\n队列和栈非常类似，但是使用了不同的原则，而非后进先出。在现实中，最常见的队列的例子就是排队：\n\n![排队图片](/images/u=3435190451,3701028142&fm=15&gp=0.jpg)\n\n在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。\n\n队列通常可分为：\n* 顺序队列\n* 循环队列\n\n## 顺序队列\n\n使用顺序存储结构的队列称为顺序队列。如下图：\n\n![顺序队列示意图](/images/u=794894107,1623881092&fm=15&gp=0.jpg)\n\n顺序队列中的溢出现象：\n* \"下溢\"现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。\n* \"真上溢\"现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。\n* \"假上溢\"现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为\"假上溢\"现象。\n\n## 循环队列\n\n循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。即将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。结构如下图所示：\n\n![循环队列示意图](/images/u=3791572623,1286246317&fm=26&gp=0.jpg)\n\n## 队列的基本实现\n\n创建一个队列，首先需要一个用于存储队列中元素的数据结构。我们可以使用数组实现一个 Queue 类：\n```js\nclass Queue {\n  constructor () {\n    this.items = []\n  }\n\n  push (...elems) {\n    this.items = [...this.items, ...elems]\n  }\n\n  shift () {\n    return this.items.shift()\n  }\n\n  get (index = 0) {\n    return this.items[index]\n  }\n\n  isEmpty () {\n    return this.items.length === 0\n  }\n\n  size () {\n    return this.items.length\n  }\n\n  clear () {\n    this.items = []\n  }\n}\n```\n其中：\n* push：向队列尾部添加一个（或多个）新的项。\n* shift：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。\n* get：访问队列元素。\n* isEmpty：如果队列中不包含任何元素，返回 true ，否则返回 false 。\n* size：返回队列包含的元素个数，与数组的 length 属性类似。\n* clear：清空队列。\n\n\n","source":"_posts/2019-08-31-数据结构与开发应用之队列.md","raw":"---\ntitle: 数据结构与开发应用之队列\ndate: 2019-08-31\ntoc: false\ncomments: false\ntags:\n    - 队列\ncategories:\n    - 数据结构\n---\n\n队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出线性表。\n\n<!--more-->\n\n## 理解队列\n\n队列和栈非常类似，但是使用了不同的原则，而非后进先出。在现实中，最常见的队列的例子就是排队：\n\n![排队图片](/images/u=3435190451,3701028142&fm=15&gp=0.jpg)\n\n在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。\n\n队列通常可分为：\n* 顺序队列\n* 循环队列\n\n## 顺序队列\n\n使用顺序存储结构的队列称为顺序队列。如下图：\n\n![顺序队列示意图](/images/u=794894107,1623881092&fm=15&gp=0.jpg)\n\n顺序队列中的溢出现象：\n* \"下溢\"现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。\n* \"真上溢\"现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。\n* \"假上溢\"现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为\"假上溢\"现象。\n\n## 循环队列\n\n循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。即将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。结构如下图所示：\n\n![循环队列示意图](/images/u=3791572623,1286246317&fm=26&gp=0.jpg)\n\n## 队列的基本实现\n\n创建一个队列，首先需要一个用于存储队列中元素的数据结构。我们可以使用数组实现一个 Queue 类：\n```js\nclass Queue {\n  constructor () {\n    this.items = []\n  }\n\n  push (...elems) {\n    this.items = [...this.items, ...elems]\n  }\n\n  shift () {\n    return this.items.shift()\n  }\n\n  get (index = 0) {\n    return this.items[index]\n  }\n\n  isEmpty () {\n    return this.items.length === 0\n  }\n\n  size () {\n    return this.items.length\n  }\n\n  clear () {\n    this.items = []\n  }\n}\n```\n其中：\n* push：向队列尾部添加一个（或多个）新的项。\n* shift：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。\n* get：访问队列元素。\n* isEmpty：如果队列中不包含任何元素，返回 true ，否则返回 false 。\n* size：返回队列包含的元素个数，与数组的 length 属性类似。\n* clear：清空队列。\n\n\n","slug":"2019-08-31-数据结构与开发应用之队列","published":1,"updated":"2019-08-30T10:29:15.087Z","layout":"post","photos":[],"link":"","_id":"ck31ar4az0020acqxqqy578ss","content":"<p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出线性表。</p>\n<a id=\"more\"></a>\n<h2 id=\"理解队列\"><a href=\"#理解队列\" class=\"headerlink\" title=\"理解队列\"></a>理解队列</h2><p>队列和栈非常类似，但是使用了不同的原则，而非后进先出。在现实中，最常见的队列的例子就是排队：</p>\n<p><img src=\"/images/u=3435190451,3701028142&amp;fm=15&amp;gp=0.jpg\" alt=\"排队图片\"></p>\n<p>在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。</p>\n<p>队列通常可分为：</p>\n<ul>\n<li>顺序队列</li>\n<li>循环队列</li>\n</ul>\n<h2 id=\"顺序队列\"><a href=\"#顺序队列\" class=\"headerlink\" title=\"顺序队列\"></a>顺序队列</h2><p>使用顺序存储结构的队列称为顺序队列。如下图：</p>\n<p><img src=\"/images/u=794894107,1623881092&amp;fm=15&amp;gp=0.jpg\" alt=\"顺序队列示意图\"></p>\n<p>顺序队列中的溢出现象：</p>\n<ul>\n<li>“下溢”现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。</li>\n<li>“真上溢”现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。</li>\n<li>“假上溢”现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为”假上溢”现象。</li>\n</ul>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。即将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。结构如下图所示：</p>\n<p><img src=\"/images/u=3791572623,1286246317&amp;fm=26&amp;gp=0.jpg\" alt=\"循环队列示意图\"></p>\n<h2 id=\"队列的基本实现\"><a href=\"#队列的基本实现\" class=\"headerlink\" title=\"队列的基本实现\"></a>队列的基本实现</h2><p>创建一个队列，首先需要一个用于存储队列中元素的数据结构。我们可以使用数组实现一个 Queue 类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push (...elems) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = [...this.items, ...elems]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shift () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.shift()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> (index = 0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items[index]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li>push：向队列尾部添加一个（或多个）新的项。</li>\n<li>shift：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li>\n<li>get：访问队列元素。</li>\n<li>isEmpty：如果队列中不包含任何元素，返回 true ，否则返回 false 。</li>\n<li>size：返回队列包含的元素个数，与数组的 length 属性类似。</li>\n<li>clear：清空队列。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出线性表。</p>","more":"<h2 id=\"理解队列\"><a href=\"#理解队列\" class=\"headerlink\" title=\"理解队列\"></a>理解队列</h2><p>队列和栈非常类似，但是使用了不同的原则，而非后进先出。在现实中，最常见的队列的例子就是排队：</p>\n<p><img src=\"/images/u=3435190451,3701028142&amp;fm=15&amp;gp=0.jpg\" alt=\"排队图片\"></p>\n<p>在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。</p>\n<p>队列通常可分为：</p>\n<ul>\n<li>顺序队列</li>\n<li>循环队列</li>\n</ul>\n<h2 id=\"顺序队列\"><a href=\"#顺序队列\" class=\"headerlink\" title=\"顺序队列\"></a>顺序队列</h2><p>使用顺序存储结构的队列称为顺序队列。如下图：</p>\n<p><img src=\"/images/u=794894107,1623881092&amp;fm=15&amp;gp=0.jpg\" alt=\"顺序队列示意图\"></p>\n<p>顺序队列中的溢出现象：</p>\n<ul>\n<li>“下溢”现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。</li>\n<li>“真上溢”现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。</li>\n<li>“假上溢”现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为”假上溢”现象。</li>\n</ul>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。即将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。结构如下图所示：</p>\n<p><img src=\"/images/u=3791572623,1286246317&amp;fm=26&amp;gp=0.jpg\" alt=\"循环队列示意图\"></p>\n<h2 id=\"队列的基本实现\"><a href=\"#队列的基本实现\" class=\"headerlink\" title=\"队列的基本实现\"></a>队列的基本实现</h2><p>创建一个队列，首先需要一个用于存储队列中元素的数据结构。我们可以使用数组实现一个 Queue 类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push (...elems) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = [...this.items, ...elems]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shift () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.shift()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> (index = 0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items[index]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li>push：向队列尾部添加一个（或多个）新的项。</li>\n<li>shift：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li>\n<li>get：访问队列元素。</li>\n<li>isEmpty：如果队列中不包含任何元素，返回 true ，否则返回 false 。</li>\n<li>size：返回队列包含的元素个数，与数组的 length 属性类似。</li>\n<li>clear：清空队列。</li>\n</ul>"},{"title":"深入理解new运算符","date":"2019-08-25T16:00:00.000Z","toc":false,"comments":0,"_content":"\n在JavaScript中，new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。创建一个对象很简单，为什么我们还要多此一举使用 new 运算符呢？它到底有什么样的魔力？\n\n<!--more-->\n\n## 认识 new 运算符\n\n通过下面的例子理解 new 运算符：\n```js\nfunction Person (name) {\n  this.name = name\n}\n\nPerson.prototype.getName = function () {\n  console.log(this.name)\n}\n\nvar joe = new Person('joe')\n\njoe.sayHello = function () {\n  console.log('Hello!')\n}\n\njoe.getName() // joe\njoe.sayHello() // Hello!\n\nPerson.sayHello() // Uncaught TypeError: Person.sayHello is not a function\n```\nPerson是一个普通的函数，当它与 new 运算符一起使用时，Person就是一个构造函数。通过 new 得到的对象 joe 继承了 Person 的属性，同时，this 也指向 joe 实例。为 joe 添加的属性 sayHello 不会影响 Person，即 joe 是区别与 Person 的一个新对象。\n\n**因此，通过 new 创建的实例对象和构造函数之间建立了一条原型链，并通过原型链赋予实例对象继承的能力**。\n\n## new 的原理和实现\n\n通过上面的分析，new 运算符大概做了如下的操作：\n* 创建一个空的简单JavaScript对象（即{}）；\n* 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n* 将新创建的对象作为this的上下文 ；\n* 返回新创建的对象。\n\nnew 的实现如下：\n```js\nfunction _new (ctor, ...args) {\n  var obj = {};\n  \n  obj.__proto__ = ctor.prototype\n  ctor.apply(obj, args)\n  return obj;\n}\n```\n即：\n* 创建新对象{}\n* 将新对象的原型__proto__指向构造函数的prototype\n* 修改this的上下文（可以使用call或apply函数）\n* 返回新对象\n\n使用 _new 函数测试上面 Person 的例子：\n```js\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype.getName = function () {\n  console.log(this.name)\n}\n\nvar joe = _new(Person, 'joe')\n\njoe.sayHello = function () {\n  console.log('Hello!')\n}\n\njoe.getName() // joe\njoe.sayHello() // Hello!\n\nPerson.sayHello() // Uncaught TypeError: Person.sayHello is not a function\n```\n结果是一致的。\n","source":"_posts/2019-08-26-深入理解new运算符.md","raw":"---\ntitle: 深入理解new运算符\ndate: 2019-08-26\ntoc: false\ncomments: false\ntags:\n    - new运算符\ncategories:\n    - JavaScript\n---\n\n在JavaScript中，new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。创建一个对象很简单，为什么我们还要多此一举使用 new 运算符呢？它到底有什么样的魔力？\n\n<!--more-->\n\n## 认识 new 运算符\n\n通过下面的例子理解 new 运算符：\n```js\nfunction Person (name) {\n  this.name = name\n}\n\nPerson.prototype.getName = function () {\n  console.log(this.name)\n}\n\nvar joe = new Person('joe')\n\njoe.sayHello = function () {\n  console.log('Hello!')\n}\n\njoe.getName() // joe\njoe.sayHello() // Hello!\n\nPerson.sayHello() // Uncaught TypeError: Person.sayHello is not a function\n```\nPerson是一个普通的函数，当它与 new 运算符一起使用时，Person就是一个构造函数。通过 new 得到的对象 joe 继承了 Person 的属性，同时，this 也指向 joe 实例。为 joe 添加的属性 sayHello 不会影响 Person，即 joe 是区别与 Person 的一个新对象。\n\n**因此，通过 new 创建的实例对象和构造函数之间建立了一条原型链，并通过原型链赋予实例对象继承的能力**。\n\n## new 的原理和实现\n\n通过上面的分析，new 运算符大概做了如下的操作：\n* 创建一个空的简单JavaScript对象（即{}）；\n* 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n* 将新创建的对象作为this的上下文 ；\n* 返回新创建的对象。\n\nnew 的实现如下：\n```js\nfunction _new (ctor, ...args) {\n  var obj = {};\n  \n  obj.__proto__ = ctor.prototype\n  ctor.apply(obj, args)\n  return obj;\n}\n```\n即：\n* 创建新对象{}\n* 将新对象的原型__proto__指向构造函数的prototype\n* 修改this的上下文（可以使用call或apply函数）\n* 返回新对象\n\n使用 _new 函数测试上面 Person 的例子：\n```js\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype.getName = function () {\n  console.log(this.name)\n}\n\nvar joe = _new(Person, 'joe')\n\njoe.sayHello = function () {\n  console.log('Hello!')\n}\n\njoe.getName() // joe\njoe.sayHello() // Hello!\n\nPerson.sayHello() // Uncaught TypeError: Person.sayHello is not a function\n```\n结果是一致的。\n","slug":"2019-08-26-深入理解new运算符","published":1,"updated":"2019-08-30T01:52:28.376Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fc004bacqxo69dlb9x","content":"<p>在JavaScript中，new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。创建一个对象很简单，为什么我们还要多此一举使用 new 运算符呢？它到底有什么样的魔力？</p>\n<a id=\"more\"></a>\n<h2 id=\"认识-new-运算符\"><a href=\"#认识-new-运算符\" class=\"headerlink\" title=\"认识 new 运算符\"></a>认识 new 运算符</h2><p>通过下面的例子理解 new 运算符：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'joe'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">joe.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getName() <span class=\"comment\">// joe</span></span><br><span class=\"line\">joe.sayHello() <span class=\"comment\">// Hello!</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.sayHello() <span class=\"comment\">// Uncaught TypeError: Person.sayHello is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>Person是一个普通的函数，当它与 new 运算符一起使用时，Person就是一个构造函数。通过 new 得到的对象 joe 继承了 Person 的属性，同时，this 也指向 joe 实例。为 joe 添加的属性 sayHello 不会影响 Person，即 joe 是区别与 Person 的一个新对象。</p>\n<p><strong>因此，通过 new 创建的实例对象和构造函数之间建立了一条原型链，并通过原型链赋予实例对象继承的能力</strong>。</p>\n<h2 id=\"new-的原理和实现\"><a href=\"#new-的原理和实现\" class=\"headerlink\" title=\"new 的原理和实现\"></a>new 的原理和实现</h2><p>通过上面的分析，new 运算符大概做了如下的操作：</p>\n<ul>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将新创建的对象作为this的上下文 ；</li>\n<li>返回新创建的对象。</li>\n</ul>\n<p>new 的实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new</span> (<span class=\"params\">ctor, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  obj.__proto__ = ctor.prototype</span><br><span class=\"line\">  ctor.apply(obj, args)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即：</p>\n<ul>\n<li>创建新对象{}</li>\n<li>将新对象的原型<strong>proto</strong>指向构造函数的prototype</li>\n<li>修改this的上下文（可以使用call或apply函数）</li>\n<li>返回新对象</li>\n</ul>\n<p>使用 _new 函数测试上面 Person 的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = _new(Person, <span class=\"string\">'joe'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">joe.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getName() <span class=\"comment\">// joe</span></span><br><span class=\"line\">joe.sayHello() <span class=\"comment\">// Hello!</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.sayHello() <span class=\"comment\">// Uncaught TypeError: Person.sayHello is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>结果是一致的。</p>\n","site":{"data":{}},"excerpt":"<p>在JavaScript中，new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。创建一个对象很简单，为什么我们还要多此一举使用 new 运算符呢？它到底有什么样的魔力？</p>","more":"<h2 id=\"认识-new-运算符\"><a href=\"#认识-new-运算符\" class=\"headerlink\" title=\"认识 new 运算符\"></a>认识 new 运算符</h2><p>通过下面的例子理解 new 运算符：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'joe'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">joe.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getName() <span class=\"comment\">// joe</span></span><br><span class=\"line\">joe.sayHello() <span class=\"comment\">// Hello!</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.sayHello() <span class=\"comment\">// Uncaught TypeError: Person.sayHello is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>Person是一个普通的函数，当它与 new 运算符一起使用时，Person就是一个构造函数。通过 new 得到的对象 joe 继承了 Person 的属性，同时，this 也指向 joe 实例。为 joe 添加的属性 sayHello 不会影响 Person，即 joe 是区别与 Person 的一个新对象。</p>\n<p><strong>因此，通过 new 创建的实例对象和构造函数之间建立了一条原型链，并通过原型链赋予实例对象继承的能力</strong>。</p>\n<h2 id=\"new-的原理和实现\"><a href=\"#new-的原理和实现\" class=\"headerlink\" title=\"new 的原理和实现\"></a>new 的原理和实现</h2><p>通过上面的分析，new 运算符大概做了如下的操作：</p>\n<ul>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将新创建的对象作为this的上下文 ；</li>\n<li>返回新创建的对象。</li>\n</ul>\n<p>new 的实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new</span> (<span class=\"params\">ctor, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  obj.__proto__ = ctor.prototype</span><br><span class=\"line\">  ctor.apply(obj, args)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即：</p>\n<ul>\n<li>创建新对象{}</li>\n<li>将新对象的原型<strong>proto</strong>指向构造函数的prototype</li>\n<li>修改this的上下文（可以使用call或apply函数）</li>\n<li>返回新对象</li>\n</ul>\n<p>使用 _new 函数测试上面 Person 的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> joe = _new(Person, <span class=\"string\">'joe'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">joe.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">joe.getName() <span class=\"comment\">// joe</span></span><br><span class=\"line\">joe.sayHello() <span class=\"comment\">// Hello!</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.sayHello() <span class=\"comment\">// Uncaught TypeError: Person.sayHello is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>结果是一致的。</p>"},{"title":"使用Jest进行单元测试","date":"2019-07-24T16:00:00.000Z","toc":false,"comments":0,"_content":"\nJest 是 facebook 开源的基于node.js的单元测试框架，Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。使用 Jest, 可以有效降低编写单元测试的难度。\n\n<!--more-->\n\n## 安装及基本配置\n\n使用yarn安装：\n```\nyarn add --dev jest\n```\n或npm安装：\n```\nnpm install --save-dev jest\n```\n\n在package.json文件的scripts选项配置下面的测试命令：\n```js\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\n在项目根目录新建一个test文件夹，用来管理测试文件，然后在package.json文件里加入下面的配置项：\n```js\n{\n  \"jest\": {\n    \"testRegex\": \"/test/.*.test.js$\"\n  }\n}\n```\n其中，testRegex是匹配测试文件路径的正则表达式。\n\n编写一个添加两个数字的假设函数的测试。首先，在src目录创建一个sum.js文件：\n```js\nfunction sum(a, b) {\n  return a + b;\n}\n\nmodule.exports = sum;\n```\n\n然后，在test目录创建一个名为的文件sum.test.js。这将包含的实际测试代码：\n```js\nconst sum = require('../src/sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n最后，运行yarn test或npm run test，将打印下面这个消息：\n```\nPASS  test/sum.test.js\n✓ adds 1 + 2 to equal 3 (5ms)\n```\n\n## 使用Babel\n\n如果需要使用Babel，可以通过yarn来安装所需的依赖:\n```\nyarn add --dev babel-jest @babel/core @babel/preset-env\n```\n或npm安装：\n```\nnpm install --save-dev babel-jest @babel/core @babel/preset-env\n```\n\n在工程的根目录下创建一个babel.config.js文件用于配置与当前node版本兼容的Babel：\n```js\n// babel.config.js\nmodule.exports = {\n  presets: [\n    [\n      '@babel/preset-env',\n      {\n        targets: {\n          node: 'current',\n        },\n      },\n    ],\n  ],\n};\n```\n\n如果，项目已经配置过es6开发环境，只需要安装babel-jest即可。\n\n## 使用ESLint检测\n\n安装ESLint：\n```\nnpm install eslint --save-dev\n```\n\n在eslint配置文件.eslintrc中加入以下代码：\n```js\n\"env\": {\n  \"jest\": true\n}\n```\n\n## 生成测试覆盖率报告\n\n只需要在jest命令后加入 --coverage即可：\n```js\n{\n  \"scripts\": {\n    \"test\": \"jest --coverage\"\n  }\n}\n```\n\n生成的测试报告如下：\n```\nPASS test/sum.test.js\n  ✓ adds 1 + 2 to equal 3 (5ms)\n\n----------|----------|----------|----------|----------|-------------------|\nFile      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n----------|----------|----------|----------|----------|-------------------|\nAll files |      100 |      100 |      100 |      100 |                   |\n sum.js   |      100 |      100 |      100 |      100 |                   |\n----------|----------|----------|----------|----------|-------------------|\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        2.948s, estimated 3s\nRan all test suites.\n```\n\n## 附录\n\n更多关于Jest的内容请移步官网：[Jest文档](https://jestjs.io/docs/zh-Hans/getting-started)","source":"_posts/2019-07-25-使用Jest进行单元测试.md","raw":"---\ntitle: 使用Jest进行单元测试\ndate: 2019-07-25\ntoc: false\ncomments: false\ntags:\n    - Jest\n    - Babel\n    - ESLint\ncategories:\n    - 单元测试\n---\n\nJest 是 facebook 开源的基于node.js的单元测试框架，Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。使用 Jest, 可以有效降低编写单元测试的难度。\n\n<!--more-->\n\n## 安装及基本配置\n\n使用yarn安装：\n```\nyarn add --dev jest\n```\n或npm安装：\n```\nnpm install --save-dev jest\n```\n\n在package.json文件的scripts选项配置下面的测试命令：\n```js\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\n在项目根目录新建一个test文件夹，用来管理测试文件，然后在package.json文件里加入下面的配置项：\n```js\n{\n  \"jest\": {\n    \"testRegex\": \"/test/.*.test.js$\"\n  }\n}\n```\n其中，testRegex是匹配测试文件路径的正则表达式。\n\n编写一个添加两个数字的假设函数的测试。首先，在src目录创建一个sum.js文件：\n```js\nfunction sum(a, b) {\n  return a + b;\n}\n\nmodule.exports = sum;\n```\n\n然后，在test目录创建一个名为的文件sum.test.js。这将包含的实际测试代码：\n```js\nconst sum = require('../src/sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n最后，运行yarn test或npm run test，将打印下面这个消息：\n```\nPASS  test/sum.test.js\n✓ adds 1 + 2 to equal 3 (5ms)\n```\n\n## 使用Babel\n\n如果需要使用Babel，可以通过yarn来安装所需的依赖:\n```\nyarn add --dev babel-jest @babel/core @babel/preset-env\n```\n或npm安装：\n```\nnpm install --save-dev babel-jest @babel/core @babel/preset-env\n```\n\n在工程的根目录下创建一个babel.config.js文件用于配置与当前node版本兼容的Babel：\n```js\n// babel.config.js\nmodule.exports = {\n  presets: [\n    [\n      '@babel/preset-env',\n      {\n        targets: {\n          node: 'current',\n        },\n      },\n    ],\n  ],\n};\n```\n\n如果，项目已经配置过es6开发环境，只需要安装babel-jest即可。\n\n## 使用ESLint检测\n\n安装ESLint：\n```\nnpm install eslint --save-dev\n```\n\n在eslint配置文件.eslintrc中加入以下代码：\n```js\n\"env\": {\n  \"jest\": true\n}\n```\n\n## 生成测试覆盖率报告\n\n只需要在jest命令后加入 --coverage即可：\n```js\n{\n  \"scripts\": {\n    \"test\": \"jest --coverage\"\n  }\n}\n```\n\n生成的测试报告如下：\n```\nPASS test/sum.test.js\n  ✓ adds 1 + 2 to equal 3 (5ms)\n\n----------|----------|----------|----------|----------|-------------------|\nFile      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n----------|----------|----------|----------|----------|-------------------|\nAll files |      100 |      100 |      100 |      100 |                   |\n sum.js   |      100 |      100 |      100 |      100 |                   |\n----------|----------|----------|----------|----------|-------------------|\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        2.948s, estimated 3s\nRan all test suites.\n```\n\n## 附录\n\n更多关于Jest的内容请移步官网：[Jest文档](https://jestjs.io/docs/zh-Hans/getting-started)","slug":"2019-07-25-使用Jest进行单元测试","published":1,"updated":"2019-07-26T10:28:42.353Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fe004cacqxsoepahur","content":"<p>Jest 是 facebook 开源的基于node.js的单元测试框架，Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。使用 Jest, 可以有效降低编写单元测试的难度。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装及基本配置\"><a href=\"#安装及基本配置\" class=\"headerlink\" title=\"安装及基本配置\"></a>安装及基本配置</h2><p>使用yarn安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev jest</span><br></pre></td></tr></table></figure></p>\n<p>或npm安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest</span><br></pre></td></tr></table></figure></p>\n<p>在package.json文件的scripts选项配置下面的测试命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在项目根目录新建一个test文件夹，用来管理测试文件，然后在package.json文件里加入下面的配置项：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"jest\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"testRegex\"</span>: <span class=\"string\">\"/test/.*.test.js$\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，testRegex是匹配测试文件路径的正则表达式。</p>\n<p>编写一个添加两个数字的假设函数的测试。首先，在src目录创建一个sum.js文件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = sum;</span><br></pre></td></tr></table></figure></p>\n<p>然后，在test目录创建一个名为的文件sum.test.js。这将包含的实际测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = <span class=\"built_in\">require</span>(<span class=\"string\">'../src/sum'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;</span><br><span class=\"line\">  expect(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>最后，运行yarn test或npm run test，将打印下面这个消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  test/sum.test.js</span><br><span class=\"line\">✓ adds 1 + 2 to equal 3 (5ms)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用Babel\"><a href=\"#使用Babel\" class=\"headerlink\" title=\"使用Babel\"></a>使用Babel</h2><p>如果需要使用Babel，可以通过yarn来安装所需的依赖:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev babel-jest @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>或npm安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev babel-jest @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>在工程的根目录下创建一个babel.config.js文件用于配置与当前node版本兼容的Babel：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  presets: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">'@babel/preset-env'</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        targets: &#123;</span><br><span class=\"line\">          node: <span class=\"string\">'current'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果，项目已经配置过es6开发环境，只需要安装babel-jest即可。</p>\n<h2 id=\"使用ESLint检测\"><a href=\"#使用ESLint检测\" class=\"headerlink\" title=\"使用ESLint检测\"></a>使用ESLint检测</h2><p>安装ESLint：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>在eslint配置文件.eslintrc中加入以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"jest\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生成测试覆盖率报告\"><a href=\"#生成测试覆盖率报告\" class=\"headerlink\" title=\"生成测试覆盖率报告\"></a>生成测试覆盖率报告</h2><p>只需要在jest命令后加入 –coverage即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"jest --coverage\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>生成的测试报告如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS test/sum.test.js</span><br><span class=\"line\">  ✓ adds 1 + 2 to equal 3 (5ms)</span><br><span class=\"line\"></span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |</span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">All files |      100 |      100 |      100 |      100 |                   |</span><br><span class=\"line\"> sum.js   |      100 |      100 |      100 |      100 |                   |</span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       2 passed, 2 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        2.948s, estimated 3s</span><br><span class=\"line\">Ran all test suites.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>更多关于Jest的内容请移步官网：<a href=\"https://jestjs.io/docs/zh-Hans/getting-started\" target=\"_blank\" rel=\"noopener\">Jest文档</a></p>\n","site":{"data":{}},"excerpt":"<p>Jest 是 facebook 开源的基于node.js的单元测试框架，Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。使用 Jest, 可以有效降低编写单元测试的难度。</p>","more":"<h2 id=\"安装及基本配置\"><a href=\"#安装及基本配置\" class=\"headerlink\" title=\"安装及基本配置\"></a>安装及基本配置</h2><p>使用yarn安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev jest</span><br></pre></td></tr></table></figure></p>\n<p>或npm安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest</span><br></pre></td></tr></table></figure></p>\n<p>在package.json文件的scripts选项配置下面的测试命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在项目根目录新建一个test文件夹，用来管理测试文件，然后在package.json文件里加入下面的配置项：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"jest\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"testRegex\"</span>: <span class=\"string\">\"/test/.*.test.js$\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，testRegex是匹配测试文件路径的正则表达式。</p>\n<p>编写一个添加两个数字的假设函数的测试。首先，在src目录创建一个sum.js文件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = sum;</span><br></pre></td></tr></table></figure></p>\n<p>然后，在test目录创建一个名为的文件sum.test.js。这将包含的实际测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = <span class=\"built_in\">require</span>(<span class=\"string\">'../src/sum'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;</span><br><span class=\"line\">  expect(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>最后，运行yarn test或npm run test，将打印下面这个消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  test/sum.test.js</span><br><span class=\"line\">✓ adds 1 + 2 to equal 3 (5ms)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用Babel\"><a href=\"#使用Babel\" class=\"headerlink\" title=\"使用Babel\"></a>使用Babel</h2><p>如果需要使用Babel，可以通过yarn来安装所需的依赖:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev babel-jest @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>或npm安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev babel-jest @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>\n<p>在工程的根目录下创建一个babel.config.js文件用于配置与当前node版本兼容的Babel：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  presets: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">'@babel/preset-env'</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        targets: &#123;</span><br><span class=\"line\">          node: <span class=\"string\">'current'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果，项目已经配置过es6开发环境，只需要安装babel-jest即可。</p>\n<h2 id=\"使用ESLint检测\"><a href=\"#使用ESLint检测\" class=\"headerlink\" title=\"使用ESLint检测\"></a>使用ESLint检测</h2><p>安装ESLint：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>在eslint配置文件.eslintrc中加入以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"jest\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生成测试覆盖率报告\"><a href=\"#生成测试覆盖率报告\" class=\"headerlink\" title=\"生成测试覆盖率报告\"></a>生成测试覆盖率报告</h2><p>只需要在jest命令后加入 –coverage即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"jest --coverage\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>生成的测试报告如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS test/sum.test.js</span><br><span class=\"line\">  ✓ adds 1 + 2 to equal 3 (5ms)</span><br><span class=\"line\"></span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |</span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">All files |      100 |      100 |      100 |      100 |                   |</span><br><span class=\"line\"> sum.js   |      100 |      100 |      100 |      100 |                   |</span><br><span class=\"line\">----------|----------|----------|----------|----------|-------------------|</span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       2 passed, 2 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        2.948s, estimated 3s</span><br><span class=\"line\">Ran all test suites.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>更多关于Jest的内容请移步官网：<a href=\"https://jestjs.io/docs/zh-Hans/getting-started\" target=\"_blank\" rel=\"noopener\">Jest文档</a></p>"},{"title":"初次接触CSS变量","date":"2018-07-02T16:00:00.000Z","toc":false,"comments":0,"_content":"\n本文的目的主要是展示CSS变量是如何工作的。随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，在良好的上下文中使用CSS变量，为您提供重用和轻松更改重复出现的CSS属性的机制。\n\n在“纯粹的”CSS支持变量之前，我们有像Less和Sass这样的预处理器。但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。\n\n<!--more-->\n\n## 如何定义和使用CSS变量\n\n从我们最熟悉的语言JavaScript开始：在JavaScript中定义变量使用vars。\n\n要声明一个简单的JavaScript var，如下内容：\n\n```js\nvar mainColor = 'red';\n```\n\n要声明一个CSS变量，您必须在该var的名称前添加一个双短划线。例如：\n\n```css\nbody {\n  --color:red;\n}\n```\n\n现在，为了使用CSS变量的值，我们可以使用var（...）函数。如下：\n\n```css\n.demo {\n  background:var(--color);\n}\n```\n\n管理CSS变量的最简单方法是将它们声明为：root伪类。鉴于CSS变量遵循规则，就像任何其他CSS定义一样，将它们放在：root中将确保所有选择器都可以访问这些变量。\n\n```css\n:root {\n  --color:red;\n}\n            \n.demo {\n  background:var(--color);\n}\n            \np {\n  color:var(--color);\n}\n```\n\n## 浏览器支持CSS变量？\n\n浏览器对CSS变量的支持还算不错的。只是IE浏览器不支持。想查看浏览器兼容性的可以点击这里，那么您将看到所有主流浏览器都支持开箱即用的CSS变量。无论是手机还是台式机。\n\n## CSS变量的实质应用\n\n### 示例1 - 管理颜色\n\n到目前为止，使用CSS变量的最佳候选者之一是管理网页的颜色。我们可以将它们放在变量中，而不是一遍又一遍地复制和粘贴相同的颜色。如果有人要求我们更新特定的绿色阴影或使所有按钮变为红色而不是蓝色，那么只需更改该CSS变量的值，就是这样。您不必搜索和替换该颜色的所有实例。\n\n列如：\n\nCSS代码:\n```css\n/*css_vars.css*/\n:root {\n  --primary-color: #ed6564;\n  --accent-color: #388287;\n}\n\nhtml {\n  background-color: var(--primary-color);\n}\n\nh3 {\n  border-bottom: 2px solid var(--primary-color);\n}\n\nbutton {\n  color: var(--accent-color);\n  border: 1px solid var(--accent-color);\n}\n\np {\n  color: var(--accent-color);\n}\n\n\n/*base.css*/\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  padding: 30px;\n  font: normal 13px/1.5 sans-serif;\n  color: #546567;\n  background-color: var(--primary-color);\n}\n\n.container {\n  background: #fff;\n  padding: 20px;\n}\n\nh3 {\n  padding-bottom: 10px;\n  margin-bottom: 15px;\n}\n\np {\n  background-color: #fff;\n  margin: 15px 0;\n}\n\nbutton {\n  margin:0 5px;\n  font-size: 13px;\n  padding: 8px 12px;\n  background-color: #fff;\n  border-radius: 3px;\n  box-shadow: none;\n  text-transform: uppercase;\n  font-weight: bold;\n  cursor: pointer;\n  opacity: 0.8;\n  outline: 0;\n}\n\nbutton:hover {\n  opacity: 1;\n}\n\n.center {\n  text-align: center;\n}\n```\n\nHTML代码:\n```html\n<div class=\"container\">\n  <h3>就业协议书</h3>\n  <p>就业协议书，全称是《全国普通高等学校毕业生就业协议书》，是由教育部高校学生司统一制订的。根据国家规定，在达成就业意向后，毕业生、用人单位、学校三方必须签订《全国普通高等学校毕业生就业协议书》。就业协议书是具有一定的广泛性和权威性，是学校制订就业方案派遣毕业生、用人单位申请用人指标的主要依据，对签约的三方都有约束力。</p>\n  <div class=\"center\">\n    <button>查看详情</button><button>取消</button>\n  </div>\n</div>\n```\n\n[查看运行结果](http://jsrun.net/WvgKp/edit){:target=\"_blank\"} \n\n### 示例2 - 删除重复的代码\n\n通常，您需要构建一些不同的组件变体。相同的基本样式，略有不同。让我们使用一些颜色不同的按钮。典型的解决方案是创建一个基类，比如.btn并添加变体类。\n```css\n.btn {\n  border: 2px solid black;\n}\n\n.btn:hover {\n  background: black;\n}\n\n.btn.red {\n  border-color: red\n}\n\n.btn.red:hover {\n  background: red\n}\n```\n\n现在使用它们像这样：\n```html\n<button class=\"btn\">Hello</button>\n<button class=\"btn red\">Hello</button>\n```\n但是，这会添加一些代码重复。在.red变体上，我们必须将border-color和background设置为红色。\n\n这中情况可以使用CSS变量轻松修复。如下：\n\nCSS代码：\n```css\n.btn {\n  border-radius:4px;\n  text-align:center;\n  padding:.5em;\n  margin-bottom:0.5em;\n  background:#fff;\n  border:1px solid var(--color, black);\n}\n\n.btn:hover {\n  color:#fff;\n  cursor:pointer;\n  background:var(--color, black);\n}\n\n.btn.red {\n  --color:red;\n}\n\n.btn.green {\n  --color:green;\n}\n\n.btn.blue {\n  --color:blue;\n}\n```\n\nHTML代码：\n```html\n<div class=\"btn\">HMOE</div>\n<div class=\"btn red\">HMOE</div>\n<div class=\"btn green\">HMOE</div>\n<div class=\"btn blue\">HMOE</div>\n```\n\n### 示例3 - 增强可读性\n\n如果我们想要创建更复杂的属性值的快捷方式，CSS vars非常适合使用，因此我们不必记住它。CSS属性，如box-shadow，transform和font或其他带有多个参数的CSS规则就是完美的例子。我们可以将属性放在变量中，以便我们可以通过更易读的格式重用它。\n\n例如：\n```css\n:root {\n  --tiny-shadow: 4px 4px 2px 0 rgba(0, 0, 0, 0.8);\n  --animate-right: translateX(20px);\n}\n\nli {\n  box-shadow: var(--tiny-shadow);\n}\n\nli:hover {\n  transform: var(--animate-right);\n}\n```\n\n### 例4 - 级联变量\n\n标准级联规则也适用于CSS变量。因此，如果多次声明自定义属性，则css文件中最低的定义将覆盖其上方的定义。下面的示例演示了动态操作用户操作的属性是多么容易，同时仍然保持代码清晰简洁。\n\nCSS_var.css文件：\n```css\n.orange-container {\n  --main-text: 18px;\n}\n\n\n.orange-container:hover {\n  --main-text: 22px;\n}\n\n\n.red-container:hover {\n  --main-text: 26px;\n}\n\n\n.title {\n  font-size: var(--title-text);\n}\n\n\n.content {\n  font-size: var(--main-text);\n}\n\n.container:hover {\n  --main-text: 18px;\n}\n```\n\nbase.css文件：\n```css\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #eee;\n  padding: 30px;\n  font: 500 14px sans-serif;\n  color: #333;\n  line-height: 1.5;\n}\n\n.orange-container {\n  background: orange;\n}\n\n.red-container {\n  background: red;\n}\n\n.red-container,\n.orange-container {\n  padding-top: 10px;\n  padding-left: 50px;\n}\n\n.container {\n  background: blue;\n  padding: 20px;\n  color: white;\n}\n\np {\n  transition: 0.4s;\n}\n\n.title {\n  font-weight: bold;\n}\n```\n\nindex.html文件：\n```html\n<html>\n  <head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"base.css\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css_vars.css\">\n  </head>\n  <body>\n    <div class=\"orange-container\">\n      Hover orange to make blue bigger.\n      <div class=\"red-container\">\n        Hover red to make blue even bigger.\n        <div class=\"container\">\n          <p class=\"content\">Hover on the different color areas to change the size of this text and the title.</p>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n[查看运行结果](http://jsrun.net/LvgKp/edit){:target=\"_blank\"} \n\n### 示例5 - 具有CSS变量的主题切换器\n\nCSS变量的一个好处是它的反应性。一旦我们更新它，任何具有CSS变量值的属性也会更新。因此，只需几行Javascript和CSS变量的智能使用，我们就可以制作一个主题切换器机制。\n\n例如：\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n      <meta charset=\"UTF-8\">\n      <title>具有CSS变量的主题切换器</title>    \n      <style>\n          \n        body {\n          background-color: var(--bg, #b3e5fc);\n          color: var(--bg-text, #37474f);\n          font-family: sans-serif;\n          line-height: 1.3;\n        }\n        \n        .toolbar {\n          text-align: center;\n        }\n          \n      </style>\n    </head>\n    <body>\n        \n      <div class=\"toolbar\">\n        <button value=\"dark\">dark</button>\n        <button value=\"calm\">calm</button>\n        <button value=\"light\">light</button>\n      </div>\n    \n      <h2>Stackoverflow Question</h2>\n      <p>I would like to use an external javascript file in another javascript file. For example, I could store all my global variables\n      in a globals.js file and then call then from the website logic logic.js. Then in the index.html, i would insert the tag.\n      How do I use the globals.js inside the logic.js?\n      </p>\n      \n      <script>\n        var root = document.documentElement;\n        var themeBtns = document.querySelectorAll(\".toolbar > button\");\n        \n        themeBtns.forEach(function (btn){\n          btn.addEventListener(\"click\", handleThemeUpdate);\n        });\n        \n        function handleThemeUpdate(e) {\n          switch (e.target.value) {\n            case \"dark\":\n              root.style.setProperty(\"--bg\", \"black\");\n              root.style.setProperty(\"--bg-text\", \"white\");\n              break;\n            case \"calm\":\n              root.style.setProperty(\"--bg\", \"#B3E5FC\");\n              root.style.setProperty(\"--bg-text\", \"#37474F\");\n              break;\n            case \"light\":\n              root.style.setProperty(\"--bg\", \"white\");\n              root.style.setProperty(\"--bg-text\", \"black\");\n              break;\n          }\n        }\n      </script>\n\n    </body>\n</html>\n```\n\n[查看运行结果](http://jsrun.net/wvgKp/edit){:target=\"_blank\"} \n\n## CSS变量的使用提示\n\n像CSS中几乎所有的东西一样，变量也非常简单易用。以下是一些未包含在示例中的提示，但在某些情况下仍然非常有用：\n\n1）css变量区分大小写。下面的示例是两个不同的变量：\n```css\n:root {\n  --color: blue;\n  --COLOR: red;\n}\n```\n\n2）当您使用var（）函数时，您可以使用第二个参数。如果找不到自定义属性，将使用第二个参数为默认值：\n```css\nwidth: var(--custom-width, 50%);\n```\n\n3）可以直接将CSS变量用于HTML：\n```html\n<!--HTML-->\n<html style=\"--size: 600px\">\n\n<!--CSS-->\nbody {\n  max-width: var(--size)\n}\n```\n\n4) 可以在其他CSS var中使用CSS变量：\n```css\n--base-red-color: #f00;\n--background-gradient: linear-gradient(to top, var(--base-red-color), #222);\n```\n\n5) 可以使用媒体查询使CSS变量成为条件。例如，以下代码根据屏幕大小更改填充的值：\n```css\n:root {\n  --padding: 15px \n}\n\n@media screen and (min-width: 750px) {\n  --padding: 30px\n}\n```\n\n6) 不要害怕在 clac() 函数中使用CSS变量:\n```css\n--text-input-width: 5000px;\nmax-width: calc(var(--text-input-width) / 2);\n```\n\n当然，CSS变量不是灵丹妙药。不会解决你在CSS领域遇到的每一个问题。但是，使用它使您的代码更具可读性和可维护性。此外，它极大地改善了大型文档的易变性。只需将所有常量设置在一个单独的文件中，当您只想对变量进行更改时，就不必跳过数千行代码。","source":"_posts/2018-07-03-初次接触CSS变量.md","raw":"---\ntitle: 初次接触CSS变量\ndate: 2018-07-03\ntoc: false\ncomments: false\ntags:\n    - CSS变量\ncategories:\n    - CSS\n---\n\n本文的目的主要是展示CSS变量是如何工作的。随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，在良好的上下文中使用CSS变量，为您提供重用和轻松更改重复出现的CSS属性的机制。\n\n在“纯粹的”CSS支持变量之前，我们有像Less和Sass这样的预处理器。但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。\n\n<!--more-->\n\n## 如何定义和使用CSS变量\n\n从我们最熟悉的语言JavaScript开始：在JavaScript中定义变量使用vars。\n\n要声明一个简单的JavaScript var，如下内容：\n\n```js\nvar mainColor = 'red';\n```\n\n要声明一个CSS变量，您必须在该var的名称前添加一个双短划线。例如：\n\n```css\nbody {\n  --color:red;\n}\n```\n\n现在，为了使用CSS变量的值，我们可以使用var（...）函数。如下：\n\n```css\n.demo {\n  background:var(--color);\n}\n```\n\n管理CSS变量的最简单方法是将它们声明为：root伪类。鉴于CSS变量遵循规则，就像任何其他CSS定义一样，将它们放在：root中将确保所有选择器都可以访问这些变量。\n\n```css\n:root {\n  --color:red;\n}\n            \n.demo {\n  background:var(--color);\n}\n            \np {\n  color:var(--color);\n}\n```\n\n## 浏览器支持CSS变量？\n\n浏览器对CSS变量的支持还算不错的。只是IE浏览器不支持。想查看浏览器兼容性的可以点击这里，那么您将看到所有主流浏览器都支持开箱即用的CSS变量。无论是手机还是台式机。\n\n## CSS变量的实质应用\n\n### 示例1 - 管理颜色\n\n到目前为止，使用CSS变量的最佳候选者之一是管理网页的颜色。我们可以将它们放在变量中，而不是一遍又一遍地复制和粘贴相同的颜色。如果有人要求我们更新特定的绿色阴影或使所有按钮变为红色而不是蓝色，那么只需更改该CSS变量的值，就是这样。您不必搜索和替换该颜色的所有实例。\n\n列如：\n\nCSS代码:\n```css\n/*css_vars.css*/\n:root {\n  --primary-color: #ed6564;\n  --accent-color: #388287;\n}\n\nhtml {\n  background-color: var(--primary-color);\n}\n\nh3 {\n  border-bottom: 2px solid var(--primary-color);\n}\n\nbutton {\n  color: var(--accent-color);\n  border: 1px solid var(--accent-color);\n}\n\np {\n  color: var(--accent-color);\n}\n\n\n/*base.css*/\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  padding: 30px;\n  font: normal 13px/1.5 sans-serif;\n  color: #546567;\n  background-color: var(--primary-color);\n}\n\n.container {\n  background: #fff;\n  padding: 20px;\n}\n\nh3 {\n  padding-bottom: 10px;\n  margin-bottom: 15px;\n}\n\np {\n  background-color: #fff;\n  margin: 15px 0;\n}\n\nbutton {\n  margin:0 5px;\n  font-size: 13px;\n  padding: 8px 12px;\n  background-color: #fff;\n  border-radius: 3px;\n  box-shadow: none;\n  text-transform: uppercase;\n  font-weight: bold;\n  cursor: pointer;\n  opacity: 0.8;\n  outline: 0;\n}\n\nbutton:hover {\n  opacity: 1;\n}\n\n.center {\n  text-align: center;\n}\n```\n\nHTML代码:\n```html\n<div class=\"container\">\n  <h3>就业协议书</h3>\n  <p>就业协议书，全称是《全国普通高等学校毕业生就业协议书》，是由教育部高校学生司统一制订的。根据国家规定，在达成就业意向后，毕业生、用人单位、学校三方必须签订《全国普通高等学校毕业生就业协议书》。就业协议书是具有一定的广泛性和权威性，是学校制订就业方案派遣毕业生、用人单位申请用人指标的主要依据，对签约的三方都有约束力。</p>\n  <div class=\"center\">\n    <button>查看详情</button><button>取消</button>\n  </div>\n</div>\n```\n\n[查看运行结果](http://jsrun.net/WvgKp/edit){:target=\"_blank\"} \n\n### 示例2 - 删除重复的代码\n\n通常，您需要构建一些不同的组件变体。相同的基本样式，略有不同。让我们使用一些颜色不同的按钮。典型的解决方案是创建一个基类，比如.btn并添加变体类。\n```css\n.btn {\n  border: 2px solid black;\n}\n\n.btn:hover {\n  background: black;\n}\n\n.btn.red {\n  border-color: red\n}\n\n.btn.red:hover {\n  background: red\n}\n```\n\n现在使用它们像这样：\n```html\n<button class=\"btn\">Hello</button>\n<button class=\"btn red\">Hello</button>\n```\n但是，这会添加一些代码重复。在.red变体上，我们必须将border-color和background设置为红色。\n\n这中情况可以使用CSS变量轻松修复。如下：\n\nCSS代码：\n```css\n.btn {\n  border-radius:4px;\n  text-align:center;\n  padding:.5em;\n  margin-bottom:0.5em;\n  background:#fff;\n  border:1px solid var(--color, black);\n}\n\n.btn:hover {\n  color:#fff;\n  cursor:pointer;\n  background:var(--color, black);\n}\n\n.btn.red {\n  --color:red;\n}\n\n.btn.green {\n  --color:green;\n}\n\n.btn.blue {\n  --color:blue;\n}\n```\n\nHTML代码：\n```html\n<div class=\"btn\">HMOE</div>\n<div class=\"btn red\">HMOE</div>\n<div class=\"btn green\">HMOE</div>\n<div class=\"btn blue\">HMOE</div>\n```\n\n### 示例3 - 增强可读性\n\n如果我们想要创建更复杂的属性值的快捷方式，CSS vars非常适合使用，因此我们不必记住它。CSS属性，如box-shadow，transform和font或其他带有多个参数的CSS规则就是完美的例子。我们可以将属性放在变量中，以便我们可以通过更易读的格式重用它。\n\n例如：\n```css\n:root {\n  --tiny-shadow: 4px 4px 2px 0 rgba(0, 0, 0, 0.8);\n  --animate-right: translateX(20px);\n}\n\nli {\n  box-shadow: var(--tiny-shadow);\n}\n\nli:hover {\n  transform: var(--animate-right);\n}\n```\n\n### 例4 - 级联变量\n\n标准级联规则也适用于CSS变量。因此，如果多次声明自定义属性，则css文件中最低的定义将覆盖其上方的定义。下面的示例演示了动态操作用户操作的属性是多么容易，同时仍然保持代码清晰简洁。\n\nCSS_var.css文件：\n```css\n.orange-container {\n  --main-text: 18px;\n}\n\n\n.orange-container:hover {\n  --main-text: 22px;\n}\n\n\n.red-container:hover {\n  --main-text: 26px;\n}\n\n\n.title {\n  font-size: var(--title-text);\n}\n\n\n.content {\n  font-size: var(--main-text);\n}\n\n.container:hover {\n  --main-text: 18px;\n}\n```\n\nbase.css文件：\n```css\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #eee;\n  padding: 30px;\n  font: 500 14px sans-serif;\n  color: #333;\n  line-height: 1.5;\n}\n\n.orange-container {\n  background: orange;\n}\n\n.red-container {\n  background: red;\n}\n\n.red-container,\n.orange-container {\n  padding-top: 10px;\n  padding-left: 50px;\n}\n\n.container {\n  background: blue;\n  padding: 20px;\n  color: white;\n}\n\np {\n  transition: 0.4s;\n}\n\n.title {\n  font-weight: bold;\n}\n```\n\nindex.html文件：\n```html\n<html>\n  <head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"base.css\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css_vars.css\">\n  </head>\n  <body>\n    <div class=\"orange-container\">\n      Hover orange to make blue bigger.\n      <div class=\"red-container\">\n        Hover red to make blue even bigger.\n        <div class=\"container\">\n          <p class=\"content\">Hover on the different color areas to change the size of this text and the title.</p>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n[查看运行结果](http://jsrun.net/LvgKp/edit){:target=\"_blank\"} \n\n### 示例5 - 具有CSS变量的主题切换器\n\nCSS变量的一个好处是它的反应性。一旦我们更新它，任何具有CSS变量值的属性也会更新。因此，只需几行Javascript和CSS变量的智能使用，我们就可以制作一个主题切换器机制。\n\n例如：\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n      <meta charset=\"UTF-8\">\n      <title>具有CSS变量的主题切换器</title>    \n      <style>\n          \n        body {\n          background-color: var(--bg, #b3e5fc);\n          color: var(--bg-text, #37474f);\n          font-family: sans-serif;\n          line-height: 1.3;\n        }\n        \n        .toolbar {\n          text-align: center;\n        }\n          \n      </style>\n    </head>\n    <body>\n        \n      <div class=\"toolbar\">\n        <button value=\"dark\">dark</button>\n        <button value=\"calm\">calm</button>\n        <button value=\"light\">light</button>\n      </div>\n    \n      <h2>Stackoverflow Question</h2>\n      <p>I would like to use an external javascript file in another javascript file. For example, I could store all my global variables\n      in a globals.js file and then call then from the website logic logic.js. Then in the index.html, i would insert the tag.\n      How do I use the globals.js inside the logic.js?\n      </p>\n      \n      <script>\n        var root = document.documentElement;\n        var themeBtns = document.querySelectorAll(\".toolbar > button\");\n        \n        themeBtns.forEach(function (btn){\n          btn.addEventListener(\"click\", handleThemeUpdate);\n        });\n        \n        function handleThemeUpdate(e) {\n          switch (e.target.value) {\n            case \"dark\":\n              root.style.setProperty(\"--bg\", \"black\");\n              root.style.setProperty(\"--bg-text\", \"white\");\n              break;\n            case \"calm\":\n              root.style.setProperty(\"--bg\", \"#B3E5FC\");\n              root.style.setProperty(\"--bg-text\", \"#37474F\");\n              break;\n            case \"light\":\n              root.style.setProperty(\"--bg\", \"white\");\n              root.style.setProperty(\"--bg-text\", \"black\");\n              break;\n          }\n        }\n      </script>\n\n    </body>\n</html>\n```\n\n[查看运行结果](http://jsrun.net/wvgKp/edit){:target=\"_blank\"} \n\n## CSS变量的使用提示\n\n像CSS中几乎所有的东西一样，变量也非常简单易用。以下是一些未包含在示例中的提示，但在某些情况下仍然非常有用：\n\n1）css变量区分大小写。下面的示例是两个不同的变量：\n```css\n:root {\n  --color: blue;\n  --COLOR: red;\n}\n```\n\n2）当您使用var（）函数时，您可以使用第二个参数。如果找不到自定义属性，将使用第二个参数为默认值：\n```css\nwidth: var(--custom-width, 50%);\n```\n\n3）可以直接将CSS变量用于HTML：\n```html\n<!--HTML-->\n<html style=\"--size: 600px\">\n\n<!--CSS-->\nbody {\n  max-width: var(--size)\n}\n```\n\n4) 可以在其他CSS var中使用CSS变量：\n```css\n--base-red-color: #f00;\n--background-gradient: linear-gradient(to top, var(--base-red-color), #222);\n```\n\n5) 可以使用媒体查询使CSS变量成为条件。例如，以下代码根据屏幕大小更改填充的值：\n```css\n:root {\n  --padding: 15px \n}\n\n@media screen and (min-width: 750px) {\n  --padding: 30px\n}\n```\n\n6) 不要害怕在 clac() 函数中使用CSS变量:\n```css\n--text-input-width: 5000px;\nmax-width: calc(var(--text-input-width) / 2);\n```\n\n当然，CSS变量不是灵丹妙药。不会解决你在CSS领域遇到的每一个问题。但是，使用它使您的代码更具可读性和可维护性。此外，它极大地改善了大型文档的易变性。只需将所有常量设置在一个单独的文件中，当您只想对变量进行更改时，就不必跳过数千行代码。","slug":"2018-07-03-初次接触CSS变量","published":1,"updated":"2019-07-26T02:59:54.968Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fg004eacqx94tg62h8","content":"<p>本文的目的主要是展示CSS变量是如何工作的。随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，在良好的上下文中使用CSS变量，为您提供重用和轻松更改重复出现的CSS属性的机制。</p>\n<p>在“纯粹的”CSS支持变量之前，我们有像Less和Sass这样的预处理器。但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。</p>\n<a id=\"more\"></a>\n<h2 id=\"如何定义和使用CSS变量\"><a href=\"#如何定义和使用CSS变量\" class=\"headerlink\" title=\"如何定义和使用CSS变量\"></a>如何定义和使用CSS变量</h2><p>从我们最熟悉的语言JavaScript开始：在JavaScript中定义变量使用vars。</p>\n<p>要声明一个简单的JavaScript var，如下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mainColor = <span class=\"string\">'red'</span>;</span><br></pre></td></tr></table></figure>\n<p>要声明一个CSS变量，您必须在该var的名称前添加一个双短划线。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，为了使用CSS变量的值，我们可以使用var（…）函数。如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>管理CSS变量的最简单方法是将它们声明为：root伪类。鉴于CSS变量遵循规则，就像任何其他CSS定义一样，将它们放在：root中将确保所有选择器都可以访问这些变量。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器支持CSS变量？\"><a href=\"#浏览器支持CSS变量？\" class=\"headerlink\" title=\"浏览器支持CSS变量？\"></a>浏览器支持CSS变量？</h2><p>浏览器对CSS变量的支持还算不错的。只是IE浏览器不支持。想查看浏览器兼容性的可以点击这里，那么您将看到所有主流浏览器都支持开箱即用的CSS变量。无论是手机还是台式机。</p>\n<h2 id=\"CSS变量的实质应用\"><a href=\"#CSS变量的实质应用\" class=\"headerlink\" title=\"CSS变量的实质应用\"></a>CSS变量的实质应用</h2><h3 id=\"示例1-管理颜色\"><a href=\"#示例1-管理颜色\" class=\"headerlink\" title=\"示例1 - 管理颜色\"></a>示例1 - 管理颜色</h3><p>到目前为止，使用CSS变量的最佳候选者之一是管理网页的颜色。我们可以将它们放在变量中，而不是一遍又一遍地复制和粘贴相同的颜色。如果有人要求我们更新特定的绿色阴影或使所有按钮变为红色而不是蓝色，那么只需更改该CSS变量的值，就是这样。您不必搜索和替换该颜色的所有实例。</p>\n<p>列如：</p>\n<p>CSS代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*css_vars.css*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--primary-color</span>: <span class=\"number\">#ed6564</span>;</span><br><span class=\"line\">  <span class=\"attribute\">--accent-color</span>: <span class=\"number\">#388287</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*base.css*/</span></span><br><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: normal <span class=\"number\">13px</span>/<span class=\"number\">1.5</span> sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#546567</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">15px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span> <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">13px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">8px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">text-transform</span>: uppercase;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.center</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML代码:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>就业协议书<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>就业协议书，全称是《全国普通高等学校毕业生就业协议书》，是由教育部高校学生司统一制订的。根据国家规定，在达成就业意向后，毕业生、用人单位、学校三方必须签订《全国普通高等学校毕业生就业协议书》。就业协议书是具有一定的广泛性和权威性，是学校制订就业方案派遣毕业生、用人单位申请用人指标的主要依据，对签约的三方都有约束力。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"center\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>查看详情<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/WvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h3 id=\"示例2-删除重复的代码\"><a href=\"#示例2-删除重复的代码\" class=\"headerlink\" title=\"示例2 - 删除重复的代码\"></a>示例2 - 删除重复的代码</h3><p>通常，您需要构建一些不同的组件变体。相同的基本样式，略有不同。让我们使用一些颜色不同的按钮。典型的解决方案是创建一个基类，比如.btn并添加变体类。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用它们像这样：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn red\"</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是，这会添加一些代码重复。在.red变体上，我们必须将border-color和background设置为红色。</p>\n<p>这中情况可以使用CSS变量轻松修复。如下：</p>\n<p>CSS代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>:<span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>:<span class=\"number\">0.5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"built_in\">var</span>(--color, black);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>:pointer;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color, black);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.green</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.blue</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn red\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn green\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn blue\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例3-增强可读性\"><a href=\"#示例3-增强可读性\" class=\"headerlink\" title=\"示例3 - 增强可读性\"></a>示例3 - 增强可读性</h3><p>如果我们想要创建更复杂的属性值的快捷方式，CSS vars非常适合使用，因此我们不必记住它。CSS属性，如box-shadow，transform和font或其他带有多个参数的CSS规则就是完美的例子。我们可以将属性放在变量中，以便我们可以通过更易读的格式重用它。</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--tiny-shadow</span>: <span class=\"number\">4px</span> <span class=\"number\">4px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.8);</span><br><span class=\"line\">  <span class=\"attribute\">--animate-right</span>: <span class=\"built_in\">translateX</span>(20px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"built_in\">var</span>(--tiny-shadow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">var</span>(--animate-right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例4-级联变量\"><a href=\"#例4-级联变量\" class=\"headerlink\" title=\"例4 - 级联变量\"></a>例4 - 级联变量</h3><p>标准级联规则也适用于CSS变量。因此，如果多次声明自定义属性，则css文件中最低的定义将覆盖其上方的定义。下面的示例演示了动态操作用户操作的属性是多么容易，同时仍然保持代码清晰简洁。</p>\n<p>CSS_var.css文件：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">18px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">26px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"built_in\">var</span>(--title-text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"built_in\">var</span>(--main-text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">18px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>base.css文件：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">500</span> <span class=\"number\">14px</span> sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">1.5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: orange;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>index.html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"base.css\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css_vars.css\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"orange-container\"</span>&gt;</span></span><br><span class=\"line\">      Hover orange to make blue bigger.</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-container\"</span>&gt;</span></span><br><span class=\"line\">        Hover red to make blue even bigger.</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span>Hover on the different color areas to change the size of this text and the title.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/LvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h3 id=\"示例5-具有CSS变量的主题切换器\"><a href=\"#示例5-具有CSS变量的主题切换器\" class=\"headerlink\" title=\"示例5 - 具有CSS变量的主题切换器\"></a>示例5 - 具有CSS变量的主题切换器</h3><p>CSS变量的一个好处是它的反应性。一旦我们更新它，任何具有CSS变量值的属性也会更新。因此，只需几行Javascript和CSS变量的智能使用，我们就可以制作一个主题切换器机制。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>具有CSS变量的主题切换器<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>    </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">background-color</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--bg</span>, <span class=\"selector-id\">#b3e5fc</span>);</span></span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--bg-text</span>, <span class=\"selector-id\">#37474f</span>);</span></span><br><span class=\"line\">          font-family: sans-serif;</span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">line-height</span>: 1<span class=\"selector-class\">.3</span>;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"css\">        <span class=\"selector-class\">.toolbar</span> &#123;</span></span><br><span class=\"line\">          text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toolbar\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"dark\"</span>&gt;</span>dark<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"calm\"</span>&gt;</span>calm<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"light\"</span>&gt;</span>light<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Stackoverflow Question<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I would like to use an external javascript file in another javascript file. For example, I could store all my global variables</span><br><span class=\"line\">      in a globals.js file and then call then from the website logic logic.js. Then in the index.html, i would insert the tag.</span><br><span class=\"line\">      How do I use the globals.js inside the logic.js?</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> root = <span class=\"built_in\">document</span>.documentElement;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> themeBtns = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\".toolbar &gt; button\"</span>);</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        themeBtns.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">btn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          btn.addEventListener(<span class=\"string\">\"click\"</span>, handleThemeUpdate);</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleThemeUpdate</span>(<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">switch</span> (e.target.value) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"dark\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"black\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"white\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"calm\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"#B3E5FC\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"#37474F\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"light\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"white\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"black\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/wvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h2 id=\"CSS变量的使用提示\"><a href=\"#CSS变量的使用提示\" class=\"headerlink\" title=\"CSS变量的使用提示\"></a>CSS变量的使用提示</h2><p>像CSS中几乎所有的东西一样，变量也非常简单易用。以下是一些未包含在示例中的提示，但在某些情况下仍然非常有用：</p>\n<p>1）css变量区分大小写。下面的示例是两个不同的变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">--COLOR</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2）当您使用var（）函数时，您可以使用第二个参数。如果找不到自定义属性，将使用第二个参数为默认值：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--custom-width</span>, 50%);</span><br></pre></td></tr></table></figure></p>\n<p>3）可以直接将CSS变量用于HTML：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">style</span>=<span class=\"string\">\"--size: 600px\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--CSS--&gt;</span></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  max-width: var(--size)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4) 可以在其他CSS var中使用CSS变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">--base-red-color</span>: <span class=\"selector-id\">#f00</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">--background-gradient</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">top</span>, <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--base-red-color</span>), <span class=\"selector-id\">#222</span>);</span><br></pre></td></tr></table></figure></p>\n<p>5) 可以使用媒体查询使CSS变量成为条件。例如，以下代码根据屏幕大小更改填充的值：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--padding</span>: <span class=\"number\">15px</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width: <span class=\"number\">750px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">--padding</span>: 30<span class=\"selector-tag\">px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6) 不要害怕在 clac() 函数中使用CSS变量:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">--text-input-width</span>: 5000<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">max-width: calc(var(--text-input-width) / 2);</span><br></pre></td></tr></table></figure></p>\n<p>当然，CSS变量不是灵丹妙药。不会解决你在CSS领域遇到的每一个问题。但是，使用它使您的代码更具可读性和可维护性。此外，它极大地改善了大型文档的易变性。只需将所有常量设置在一个单独的文件中，当您只想对变量进行更改时，就不必跳过数千行代码。</p>\n","site":{"data":{}},"excerpt":"<p>本文的目的主要是展示CSS变量是如何工作的。随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，在良好的上下文中使用CSS变量，为您提供重用和轻松更改重复出现的CSS属性的机制。</p>\n<p>在“纯粹的”CSS支持变量之前，我们有像Less和Sass这样的预处理器。但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。</p>","more":"<h2 id=\"如何定义和使用CSS变量\"><a href=\"#如何定义和使用CSS变量\" class=\"headerlink\" title=\"如何定义和使用CSS变量\"></a>如何定义和使用CSS变量</h2><p>从我们最熟悉的语言JavaScript开始：在JavaScript中定义变量使用vars。</p>\n<p>要声明一个简单的JavaScript var，如下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mainColor = <span class=\"string\">'red'</span>;</span><br></pre></td></tr></table></figure>\n<p>要声明一个CSS变量，您必须在该var的名称前添加一个双短划线。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，为了使用CSS变量的值，我们可以使用var（…）函数。如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>管理CSS变量的最简单方法是将它们声明为：root伪类。鉴于CSS变量遵循规则，就像任何其他CSS定义一样，将它们放在：root中将确保所有选择器都可以访问这些变量。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"built_in\">var</span>(--color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器支持CSS变量？\"><a href=\"#浏览器支持CSS变量？\" class=\"headerlink\" title=\"浏览器支持CSS变量？\"></a>浏览器支持CSS变量？</h2><p>浏览器对CSS变量的支持还算不错的。只是IE浏览器不支持。想查看浏览器兼容性的可以点击这里，那么您将看到所有主流浏览器都支持开箱即用的CSS变量。无论是手机还是台式机。</p>\n<h2 id=\"CSS变量的实质应用\"><a href=\"#CSS变量的实质应用\" class=\"headerlink\" title=\"CSS变量的实质应用\"></a>CSS变量的实质应用</h2><h3 id=\"示例1-管理颜色\"><a href=\"#示例1-管理颜色\" class=\"headerlink\" title=\"示例1 - 管理颜色\"></a>示例1 - 管理颜色</h3><p>到目前为止，使用CSS变量的最佳候选者之一是管理网页的颜色。我们可以将它们放在变量中，而不是一遍又一遍地复制和粘贴相同的颜色。如果有人要求我们更新特定的绿色阴影或使所有按钮变为红色而不是蓝色，那么只需更改该CSS变量的值，就是这样。您不必搜索和替换该颜色的所有实例。</p>\n<p>列如：</p>\n<p>CSS代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*css_vars.css*/</span></span><br><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--primary-color</span>: <span class=\"number\">#ed6564</span>;</span><br><span class=\"line\">  <span class=\"attribute\">--accent-color</span>: <span class=\"number\">#388287</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--accent-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*base.css*/</span></span><br><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: normal <span class=\"number\">13px</span>/<span class=\"number\">1.5</span> sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#546567</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"built_in\">var</span>(--primary-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">15px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span> <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">13px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">8px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">text-transform</span>: uppercase;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.center</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML代码:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>就业协议书<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>就业协议书，全称是《全国普通高等学校毕业生就业协议书》，是由教育部高校学生司统一制订的。根据国家规定，在达成就业意向后，毕业生、用人单位、学校三方必须签订《全国普通高等学校毕业生就业协议书》。就业协议书是具有一定的广泛性和权威性，是学校制订就业方案派遣毕业生、用人单位申请用人指标的主要依据，对签约的三方都有约束力。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"center\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>查看详情<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/WvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h3 id=\"示例2-删除重复的代码\"><a href=\"#示例2-删除重复的代码\" class=\"headerlink\" title=\"示例2 - 删除重复的代码\"></a>示例2 - 删除重复的代码</h3><p>通常，您需要构建一些不同的组件变体。相同的基本样式，略有不同。让我们使用一些颜色不同的按钮。典型的解决方案是创建一个基类，比如.btn并添加变体类。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用它们像这样：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn red\"</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是，这会添加一些代码重复。在.red变体上，我们必须将border-color和background设置为红色。</p>\n<p>这中情况可以使用CSS变量轻松修复。如下：</p>\n<p>CSS代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>:<span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>:<span class=\"number\">0.5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"built_in\">var</span>(--color, black);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>:pointer;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"built_in\">var</span>(--color, black);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.red</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.green</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-class\">.blue</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>:blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HTML代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn red\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn green\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn blue\"</span>&gt;</span>HMOE<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例3-增强可读性\"><a href=\"#示例3-增强可读性\" class=\"headerlink\" title=\"示例3 - 增强可读性\"></a>示例3 - 增强可读性</h3><p>如果我们想要创建更复杂的属性值的快捷方式，CSS vars非常适合使用，因此我们不必记住它。CSS属性，如box-shadow，transform和font或其他带有多个参数的CSS规则就是完美的例子。我们可以将属性放在变量中，以便我们可以通过更易读的格式重用它。</p>\n<p>例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--tiny-shadow</span>: <span class=\"number\">4px</span> <span class=\"number\">4px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.8);</span><br><span class=\"line\">  <span class=\"attribute\">--animate-right</span>: <span class=\"built_in\">translateX</span>(20px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"built_in\">var</span>(--tiny-shadow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">var</span>(--animate-right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例4-级联变量\"><a href=\"#例4-级联变量\" class=\"headerlink\" title=\"例4 - 级联变量\"></a>例4 - 级联变量</h3><p>标准级联规则也适用于CSS变量。因此，如果多次声明自定义属性，则css文件中最低的定义将覆盖其上方的定义。下面的示例演示了动态操作用户操作的属性是多么容易，同时仍然保持代码清晰简洁。</p>\n<p>CSS_var.css文件：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">18px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">26px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"built_in\">var</span>(--title-text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"built_in\">var</span>(--main-text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--main-text</span>: <span class=\"number\">18px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>base.css文件：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">500</span> <span class=\"number\">14px</span> sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">1.5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: orange;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.red-container</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.orange-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>index.html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"base.css\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css_vars.css\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"orange-container\"</span>&gt;</span></span><br><span class=\"line\">      Hover orange to make blue bigger.</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red-container\"</span>&gt;</span></span><br><span class=\"line\">        Hover red to make blue even bigger.</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span>Hover on the different color areas to change the size of this text and the title.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/LvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h3 id=\"示例5-具有CSS变量的主题切换器\"><a href=\"#示例5-具有CSS变量的主题切换器\" class=\"headerlink\" title=\"示例5 - 具有CSS变量的主题切换器\"></a>示例5 - 具有CSS变量的主题切换器</h3><p>CSS变量的一个好处是它的反应性。一旦我们更新它，任何具有CSS变量值的属性也会更新。因此，只需几行Javascript和CSS变量的智能使用，我们就可以制作一个主题切换器机制。</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>具有CSS变量的主题切换器<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>    </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">background-color</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--bg</span>, <span class=\"selector-id\">#b3e5fc</span>);</span></span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--bg-text</span>, <span class=\"selector-id\">#37474f</span>);</span></span><br><span class=\"line\">          font-family: sans-serif;</span><br><span class=\"line\"><span class=\"css\">          <span class=\"selector-tag\">line-height</span>: 1<span class=\"selector-class\">.3</span>;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"css\">        <span class=\"selector-class\">.toolbar</span> &#123;</span></span><br><span class=\"line\">          text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toolbar\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"dark\"</span>&gt;</span>dark<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"calm\"</span>&gt;</span>calm<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">\"light\"</span>&gt;</span>light<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Stackoverflow Question<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I would like to use an external javascript file in another javascript file. For example, I could store all my global variables</span><br><span class=\"line\">      in a globals.js file and then call then from the website logic logic.js. Then in the index.html, i would insert the tag.</span><br><span class=\"line\">      How do I use the globals.js inside the logic.js?</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> root = <span class=\"built_in\">document</span>.documentElement;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> themeBtns = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\".toolbar &gt; button\"</span>);</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        themeBtns.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">btn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          btn.addEventListener(<span class=\"string\">\"click\"</span>, handleThemeUpdate);</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleThemeUpdate</span>(<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">switch</span> (e.target.value) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"dark\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"black\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"white\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"calm\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"#B3E5FC\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"#37474F\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">case</span> <span class=\"string\">\"light\"</span>:</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg\"</span>, <span class=\"string\">\"white\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              root.style.setProperty(<span class=\"string\">\"--bg-text\"</span>, <span class=\"string\">\"black\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"keyword\">break</span>;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsrun.net/wvgKp/edit\" target=\"_blank\" rel=\"noopener\">查看运行结果</a>{:target=”_blank”} </p>\n<h2 id=\"CSS变量的使用提示\"><a href=\"#CSS变量的使用提示\" class=\"headerlink\" title=\"CSS变量的使用提示\"></a>CSS变量的使用提示</h2><p>像CSS中几乎所有的东西一样，变量也非常简单易用。以下是一些未包含在示例中的提示，但在某些情况下仍然非常有用：</p>\n<p>1）css变量区分大小写。下面的示例是两个不同的变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--color</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">--COLOR</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2）当您使用var（）函数时，您可以使用第二个参数。如果找不到自定义属性，将使用第二个参数为默认值：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--custom-width</span>, 50%);</span><br></pre></td></tr></table></figure></p>\n<p>3）可以直接将CSS变量用于HTML：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--HTML--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">style</span>=<span class=\"string\">\"--size: 600px\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--CSS--&gt;</span></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  max-width: var(--size)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4) 可以在其他CSS var中使用CSS变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">--base-red-color</span>: <span class=\"selector-id\">#f00</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">--background-gradient</span>: <span class=\"selector-tag\">linear-gradient</span>(<span class=\"selector-tag\">to</span> <span class=\"selector-tag\">top</span>, <span class=\"selector-tag\">var</span>(<span class=\"selector-tag\">--base-red-color</span>), <span class=\"selector-id\">#222</span>);</span><br></pre></td></tr></table></figure></p>\n<p>5) 可以使用媒体查询使CSS变量成为条件。例如，以下代码根据屏幕大小更改填充的值：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">--padding</span>: <span class=\"number\">15px</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width: <span class=\"number\">750px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">--padding</span>: 30<span class=\"selector-tag\">px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6) 不要害怕在 clac() 函数中使用CSS变量:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">--text-input-width</span>: 5000<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">max-width: calc(var(--text-input-width) / 2);</span><br></pre></td></tr></table></figure></p>\n<p>当然，CSS变量不是灵丹妙药。不会解决你在CSS领域遇到的每一个问题。但是，使用它使您的代码更具可读性和可维护性。此外，它极大地改善了大型文档的易变性。只需将所有常量设置在一个单独的文件中，当您只想对变量进行更改时，就不必跳过数千行代码。</p>"},{"title":"理解递归及其应用","date":"2018-04-05T16:00:00.000Z","toc":false,"comments":0,"_content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n什么是递归算法？什么是递归函数？如何理解递归算法？如何理解递归函数及其应用？\n\n<!--more-->\n\n**递归算法**在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在程序语言中，程序调用自身的编程技巧称为**递归**。**递归函数**是指在运行的过程中函数直接或间接调用函数自身。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。\n\n## 理解递归\n\n递归函数是指函数直接或间接调用函数本身。\n\n这句话理解起来并不难，从概念上出发，理解递归函数：\n```js\nfunction foo(){\n  console.log(\"函数 foo 是递归函数。\");\n  foo();\n}\n```\n这里的 foo 函数就是一个递归函数。\n\n当你把这个函数拿到浏览器上运行的时候，你会发现内存溢出了，为什么呢？因为这个递归函数没有停止处理或运算的出口，因此这个递归函数就演变为一个死循环，即函数永无休止的调用自身。\n\n因此，使用递归函数必须要符合两个条件：\n* **递归表达式(规律)**\n* **递归出口(终止递归的条件)**\n\n递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。\n\n例如：求1+2+3+...+n的和。\n\n分析：\n* 当n=1时，和就是1\n* 当n>1时，和就是1+2+3+...+(n-1)的和加上n。\n\n于是得到了上面求和的数学定义：\n$$\nf(n) =\n\\begin{cases}\n1,  & \\text{$n$ = 1} \\\\\\\\\nf(n-1)+n, & \\text{$n$ > 1}\n\\end{cases}\n$$\n\n使用for循环来实现求和1+2+3+....+n，那是很简单的：\n```js\nvar sum = function (n) {\n  var result = 0;\n  for (var i = 1; i <= n; i++) {\n    result = result + i;\n  }\n  return result\n}\n```\n前面说过，循环都可以使用递归来进行改写，递归实现如下：\n```js\nvar sum = function (n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return sum(n - 1) + n;\n  }\n}\n```\n\n## 递归的应用\n\n**递归算法**解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在**递归调用**的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成**栈溢出**等。\n\n**数组中的最大值**\n\n使用用递归求数组中的最大值，那怎么用呢？首先还是先要找到**递归表达式(规律)**和**递归出口**。\n\n1、找递归表达式(规律)：\n* 将数组第一个元素->2与数组后面的数->[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]进行切割，将数组后面的数看成是一个整体X=[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]，那么我们就可以看成是第一个数2和一个整体X进行比较。\n* 找出整体X的最大值又是和我们的初始目的(找出最大值)是一样的\n\n2、找递归出口：\n* 如果数组只有1个元素时，那么这个数组最大值就是数组的第一个元素。\n\n技巧：在递归中常常是将问题**切割成两个部分(1和整体的思想)**，这能够让我们快速找到递归表达式(规律)\n\n那么递归的实现如下：\n```js\nvar findMax = function (arr) {\n  if (arr.length === 1) {\n    return arr[0];\n  }\n  var a = arr[0];\n  var b = findMax(arr.slice(1));\n  \n  return Math.max(a, b)\n}\n```\n\n**斐波那契数列**\n\n斐波那契数列（1，1，2，3，5，8，13，21，34，55，.....，n）是递归的典型应用案例。斐波那契数列的规律是：**前两项之和等于第三项**。\n\n如：\n```\n1 + 1 = 2\n1 + 2 = 3\n2 + 3 = 5\n...\n```\n那么第n项是多少？第n项时第n-1和第n-2项的和，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)。递归出口有两个，因为它是前两项加起来才得出第三项的值。\n\n用递归实现求斐波那契数列第n项的值，如下：\n```js\nvar fibonacci = function (n) {\n  if (n === 1) {\n    return 1;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n}\n```\n\n## 递归优化——尾递归\n\n递归和循环相比运行效率较低，即递归的性能不如循环。一般的递归容易造成**栈溢出**，即内存泄漏（内存不足）。\n\n为什么递归运行效率较低？容易造成**栈溢出**？看下递归实现1+2+3+...+n求和的例子：\n```js\nvar sum = function (n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return n + sum(n - 1);\n  }\n}\n```\n当n=5时：\n```js\nsum(5)\n```\n递归过程如下:\n```js\n{5 + sum(4)}\n\n{5 + {4 + sum(3)}}\n\n{5 + {4 + {3 + sum(2)}}}\n\n{5 + {4 + {3 + {2 + sum(1)}}}}\n\n{5 + {4 + {3 + {2 + 1}}}}\n\n{5 + {4 + {3 + 3}}}\n\n{5 + {4 + 6}}\n\n{5 + 10}\n\n15\n```\n可以看出：当n=5时，因为要先求得sum(4)的结果，于是sum(4)就被压栈，内存无法释放；当求sum(4)时，同样的，要先求的sum(3)的结果，于是sum(3)也被压栈。以此类推，一直到递归的出口n=1时，被压住的栈帧才被逐步释放。\n\n当n足够大时，就会造成栈溢出。经测试当运行sum(100000)时，Chrome浏览器的内存就被爆了，抛出错误：\n```\nUncaught RangeError: Maximum call stack size exceeded\n```\n\n因此，需要对递归进行优化，其中**尾递归**是常用的一种方法。如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。\n\n要理解尾递归一定是尾调用，所以要理解尾递归就要先理解**尾调用**。\n\n**尾调用**就是指某个函数的最后一步是调用另一个函数。尾调用是函数式编程的一个重要概念。\n\n一个尾调用的例子：\n```js\nfunction f(x){\n  return g(x);\n}\n```\n以下两种情况，都不属于尾调用：\n```js\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n```\n上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。如：\n```js\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n\n*注意：**尾递归一定是尾调用，反之不成立**。*\n\n现在，用尾递归改写sum函数：\n```js\nvar sum = function (n, total = 1) {\n  if (n == 1) {\n    return total;\n  } else {\n    return sum(n - 1, total + n);\n  }\n}\n```\n当n=5时：\n```js\nsum(5)\n```\n递归过程如下:\n```js\nsum(5, 1)\n\nsum(4, 5)\n\nsum(3, 9)\n\nsum(2, 12)\n\nsum(1, 14)\n\n15\n```\n上面尾递归的运行原理是：把递归顺序中**倒数第一步**的结果先求出来，当作参数传进递归函数中，最后返回求递归顺序中**倒数第二步**的结果，以此类推，直到递归出口。又因为，每次递归都只**返回一个函数**。因此，每次递归，递归函数的运算只依赖于自身的参数，即每次递归完成后内存都可以得到释放，不存在压栈的问题。\n\n于是，尾递归可以定义为：**最后一步只调用自身的递归函数**。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n\n**尾调用优化**对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署\"尾调用优化\"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n*注意：ES6的尾调用优化只在**严格模式**下开启，正常模式是无效的。*\n\n目前，大多数浏览器都没有尾递归优化功能，即使是node.js这项功能默认都是关闭的状态。因此，在开发过程中，除非是无法避免的情况，否则，尽量使用循环替代递归。","source":"_posts/2018-04-06-理解递归及其应用.md","raw":"---\ntitle: 理解递归及其应用\ndate: 2018-04-06\ntoc: false\ncomments: false\ntags:\n    - 递归算法\n    - 递归函数\n    - 尾递归优化\ncategories:\n    - 算法\n---\n<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n什么是递归算法？什么是递归函数？如何理解递归算法？如何理解递归函数及其应用？\n\n<!--more-->\n\n**递归算法**在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在程序语言中，程序调用自身的编程技巧称为**递归**。**递归函数**是指在运行的过程中函数直接或间接调用函数自身。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。\n\n## 理解递归\n\n递归函数是指函数直接或间接调用函数本身。\n\n这句话理解起来并不难，从概念上出发，理解递归函数：\n```js\nfunction foo(){\n  console.log(\"函数 foo 是递归函数。\");\n  foo();\n}\n```\n这里的 foo 函数就是一个递归函数。\n\n当你把这个函数拿到浏览器上运行的时候，你会发现内存溢出了，为什么呢？因为这个递归函数没有停止处理或运算的出口，因此这个递归函数就演变为一个死循环，即函数永无休止的调用自身。\n\n因此，使用递归函数必须要符合两个条件：\n* **递归表达式(规律)**\n* **递归出口(终止递归的条件)**\n\n递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。\n\n例如：求1+2+3+...+n的和。\n\n分析：\n* 当n=1时，和就是1\n* 当n>1时，和就是1+2+3+...+(n-1)的和加上n。\n\n于是得到了上面求和的数学定义：\n$$\nf(n) =\n\\begin{cases}\n1,  & \\text{$n$ = 1} \\\\\\\\\nf(n-1)+n, & \\text{$n$ > 1}\n\\end{cases}\n$$\n\n使用for循环来实现求和1+2+3+....+n，那是很简单的：\n```js\nvar sum = function (n) {\n  var result = 0;\n  for (var i = 1; i <= n; i++) {\n    result = result + i;\n  }\n  return result\n}\n```\n前面说过，循环都可以使用递归来进行改写，递归实现如下：\n```js\nvar sum = function (n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return sum(n - 1) + n;\n  }\n}\n```\n\n## 递归的应用\n\n**递归算法**解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在**递归调用**的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成**栈溢出**等。\n\n**数组中的最大值**\n\n使用用递归求数组中的最大值，那怎么用呢？首先还是先要找到**递归表达式(规律)**和**递归出口**。\n\n1、找递归表达式(规律)：\n* 将数组第一个元素->2与数组后面的数->[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]进行切割，将数组后面的数看成是一个整体X=[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]，那么我们就可以看成是第一个数2和一个整体X进行比较。\n* 找出整体X的最大值又是和我们的初始目的(找出最大值)是一样的\n\n2、找递归出口：\n* 如果数组只有1个元素时，那么这个数组最大值就是数组的第一个元素。\n\n技巧：在递归中常常是将问题**切割成两个部分(1和整体的思想)**，这能够让我们快速找到递归表达式(规律)\n\n那么递归的实现如下：\n```js\nvar findMax = function (arr) {\n  if (arr.length === 1) {\n    return arr[0];\n  }\n  var a = arr[0];\n  var b = findMax(arr.slice(1));\n  \n  return Math.max(a, b)\n}\n```\n\n**斐波那契数列**\n\n斐波那契数列（1，1，2，3，5，8，13，21，34，55，.....，n）是递归的典型应用案例。斐波那契数列的规律是：**前两项之和等于第三项**。\n\n如：\n```\n1 + 1 = 2\n1 + 2 = 3\n2 + 3 = 5\n...\n```\n那么第n项是多少？第n项时第n-1和第n-2项的和，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)。递归出口有两个，因为它是前两项加起来才得出第三项的值。\n\n用递归实现求斐波那契数列第n项的值，如下：\n```js\nvar fibonacci = function (n) {\n  if (n === 1) {\n    return 1;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n}\n```\n\n## 递归优化——尾递归\n\n递归和循环相比运行效率较低，即递归的性能不如循环。一般的递归容易造成**栈溢出**，即内存泄漏（内存不足）。\n\n为什么递归运行效率较低？容易造成**栈溢出**？看下递归实现1+2+3+...+n求和的例子：\n```js\nvar sum = function (n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return n + sum(n - 1);\n  }\n}\n```\n当n=5时：\n```js\nsum(5)\n```\n递归过程如下:\n```js\n{5 + sum(4)}\n\n{5 + {4 + sum(3)}}\n\n{5 + {4 + {3 + sum(2)}}}\n\n{5 + {4 + {3 + {2 + sum(1)}}}}\n\n{5 + {4 + {3 + {2 + 1}}}}\n\n{5 + {4 + {3 + 3}}}\n\n{5 + {4 + 6}}\n\n{5 + 10}\n\n15\n```\n可以看出：当n=5时，因为要先求得sum(4)的结果，于是sum(4)就被压栈，内存无法释放；当求sum(4)时，同样的，要先求的sum(3)的结果，于是sum(3)也被压栈。以此类推，一直到递归的出口n=1时，被压住的栈帧才被逐步释放。\n\n当n足够大时，就会造成栈溢出。经测试当运行sum(100000)时，Chrome浏览器的内存就被爆了，抛出错误：\n```\nUncaught RangeError: Maximum call stack size exceeded\n```\n\n因此，需要对递归进行优化，其中**尾递归**是常用的一种方法。如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。\n\n要理解尾递归一定是尾调用，所以要理解尾递归就要先理解**尾调用**。\n\n**尾调用**就是指某个函数的最后一步是调用另一个函数。尾调用是函数式编程的一个重要概念。\n\n一个尾调用的例子：\n```js\nfunction f(x){\n  return g(x);\n}\n```\n以下两种情况，都不属于尾调用：\n```js\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n```\n上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。如：\n```js\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n\n*注意：**尾递归一定是尾调用，反之不成立**。*\n\n现在，用尾递归改写sum函数：\n```js\nvar sum = function (n, total = 1) {\n  if (n == 1) {\n    return total;\n  } else {\n    return sum(n - 1, total + n);\n  }\n}\n```\n当n=5时：\n```js\nsum(5)\n```\n递归过程如下:\n```js\nsum(5, 1)\n\nsum(4, 5)\n\nsum(3, 9)\n\nsum(2, 12)\n\nsum(1, 14)\n\n15\n```\n上面尾递归的运行原理是：把递归顺序中**倒数第一步**的结果先求出来，当作参数传进递归函数中，最后返回求递归顺序中**倒数第二步**的结果，以此类推，直到递归出口。又因为，每次递归都只**返回一个函数**。因此，每次递归，递归函数的运算只依赖于自身的参数，即每次递归完成后内存都可以得到释放，不存在压栈的问题。\n\n于是，尾递归可以定义为：**最后一步只调用自身的递归函数**。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n\n**尾调用优化**对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署\"尾调用优化\"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n*注意：ES6的尾调用优化只在**严格模式**下开启，正常模式是无效的。*\n\n目前，大多数浏览器都没有尾递归优化功能，即使是node.js这项功能默认都是关闭的状态。因此，在开发过程中，除非是无法避免的情况，否则，尽量使用循环替代递归。","slug":"2018-04-06-理解递归及其应用","published":1,"updated":"2019-08-21T10:23:56.575Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fi004gacqx4m4zk5g8","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<p>什么是递归算法？什么是递归函数？如何理解递归算法？如何理解递归函数及其应用？</p>\n<a id=\"more\"></a>\n<p><strong>递归算法</strong>在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在程序语言中，程序调用自身的编程技巧称为<strong>递归</strong>。<strong>递归函数</strong>是指在运行的过程中函数直接或间接调用函数自身。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。</p>\n<h2 id=\"理解递归\"><a href=\"#理解递归\" class=\"headerlink\" title=\"理解递归\"></a>理解递归</h2><p>递归函数是指函数直接或间接调用函数本身。</p>\n<p>这句话理解起来并不难，从概念上出发，理解递归函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"函数 foo 是递归函数。\"</span>);</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 foo 函数就是一个递归函数。</p>\n<p>当你把这个函数拿到浏览器上运行的时候，你会发现内存溢出了，为什么呢？因为这个递归函数没有停止处理或运算的出口，因此这个递归函数就演变为一个死循环，即函数永无休止的调用自身。</p>\n<p>因此，使用递归函数必须要符合两个条件：</p>\n<ul>\n<li><strong>递归表达式(规律)</strong></li>\n<li><strong>递归出口(终止递归的条件)</strong></li>\n</ul>\n<p>递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。</p>\n<p>例如：求1+2+3+…+n的和。</p>\n<p>分析：</p>\n<ul>\n<li>当n=1时，和就是1</li>\n<li>当n&gt;1时，和就是1+2+3+…+(n-1)的和加上n。</li>\n</ul>\n<p>于是得到了上面求和的数学定义：<br>$$<br>f(n) =<br>\\begin{cases}<br>1,  &amp; \\text{$n$ = 1} \\\\<br>f(n-1)+n, &amp; \\text{$n$ &gt; 1}<br>\\end{cases}<br>$$</p>\n<p>使用for循环来实现求和1+2+3+….+n，那是很简单的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    result = result + i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前面说过，循环都可以使用递归来进行改写，递归实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(n - <span class=\"number\">1</span>) + n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归的应用\"><a href=\"#递归的应用\" class=\"headerlink\" title=\"递归的应用\"></a>递归的应用</h2><p><strong>递归算法</strong>解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在<strong>递归调用</strong>的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成<strong>栈溢出</strong>等。</p>\n<p><strong>数组中的最大值</strong></p>\n<p>使用用递归求数组中的最大值，那怎么用呢？首先还是先要找到<strong>递归表达式(规律)</strong>和<strong>递归出口</strong>。</p>\n<p>1、找递归表达式(规律)：</p>\n<ul>\n<li>将数组第一个元素-&gt;2与数组后面的数-&gt;[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]进行切割，将数组后面的数看成是一个整体X=[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]，那么我们就可以看成是第一个数2和一个整体X进行比较。</li>\n<li>找出整体X的最大值又是和我们的初始目的(找出最大值)是一样的</li>\n</ul>\n<p>2、找递归出口：</p>\n<ul>\n<li>如果数组只有1个元素时，那么这个数组最大值就是数组的第一个元素。</li>\n</ul>\n<p>技巧：在递归中常常是将问题<strong>切割成两个部分(1和整体的思想)</strong>，这能够让我们快速找到递归表达式(规律)</p>\n<p>那么递归的实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = findMax(arr.slice(<span class=\"number\">1</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>斐波那契数列</strong></p>\n<p>斐波那契数列（1，1，2，3，5，8，13，21，34，55，…..，n）是递归的典型应用案例。斐波那契数列的规律是：<strong>前两项之和等于第三项</strong>。</p>\n<p>如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + 1 = 2</span><br><span class=\"line\">1 + 2 = 3</span><br><span class=\"line\">2 + 3 = 5</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>那么第n项是多少？第n项时第n-1和第n-2项的和，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)。递归出口有两个，因为它是前两项加起来才得出第三项的值。</p>\n<p>用递归实现求斐波那契数列第n项的值，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fibonacci = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归优化——尾递归\"><a href=\"#递归优化——尾递归\" class=\"headerlink\" title=\"递归优化——尾递归\"></a>递归优化——尾递归</h2><p>递归和循环相比运行效率较低，即递归的性能不如循环。一般的递归容易造成<strong>栈溢出</strong>，即内存泄漏（内存不足）。</p>\n<p>为什么递归运行效率较低？容易造成<strong>栈溢出</strong>？看下递归实现1+2+3+…+n求和的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + sum(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当n=5时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>递归过程如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"number\">5</span> + sum(<span class=\"number\">4</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + sum(<span class=\"number\">3</span>)&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + sum(<span class=\"number\">2</span>)&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + &#123;<span class=\"number\">2</span> + sum(<span class=\"number\">1</span>)&#125;&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + &#123;<span class=\"number\">2</span> + <span class=\"number\">1</span>&#125;&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + <span class=\"number\">3</span>&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + <span class=\"number\">6</span>&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + <span class=\"number\">10</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看出：当n=5时，因为要先求得sum(4)的结果，于是sum(4)就被压栈，内存无法释放；当求sum(4)时，同样的，要先求的sum(3)的结果，于是sum(3)也被压栈。以此类推，一直到递归的出口n=1时，被压住的栈帧才被逐步释放。</p>\n<p>当n足够大时，就会造成栈溢出。经测试当运行sum(100000)时，Chrome浏览器的内存就被爆了，抛出错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p>\n<p>因此，需要对递归进行优化，其中<strong>尾递归</strong>是常用的一种方法。如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</p>\n<p>要理解尾递归一定是尾调用，所以要理解尾递归就要先理解<strong>尾调用</strong>。</p>\n<p><strong>尾调用</strong>就是指某个函数的最后一步是调用另一个函数。尾调用是函数式编程的一个重要概念。</p>\n<p>一个尾调用的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以下两种情况，都不属于尾调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 情况一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>\n<p><em>注意：<strong>尾递归一定是尾调用，反之不成立</strong>。</em></p>\n<p>现在，用尾递归改写sum函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(n - <span class=\"number\">1</span>, total + n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当n=5时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>递归过程如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">3</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">2</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">14</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure></p>\n<p>上面尾递归的运行原理是：把递归顺序中<strong>倒数第一步</strong>的结果先求出来，当作参数传进递归函数中，最后返回求递归顺序中<strong>倒数第二步</strong>的结果，以此类推，直到递归出口。又因为，每次递归都只<strong>返回一个函数</strong>。因此，每次递归，递归函数的运算只依赖于自身的参数，即每次递归完成后内存都可以得到释放，不存在压栈的问题。</p>\n<p>于是，尾递归可以定义为：<strong>最后一步只调用自身的递归函数</strong>。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<p><strong>尾调用优化</strong>对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<p><em>注意：ES6的尾调用优化只在<strong>严格模式</strong>下开启，正常模式是无效的。</em></p>\n<p>目前，大多数浏览器都没有尾递归优化功能，即使是node.js这项功能默认都是关闭的状态。因此，在开发过程中，除非是无法避免的情况，否则，尽量使用循环替代递归。</p>\n","site":{"data":{}},"excerpt":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<p>什么是递归算法？什么是递归函数？如何理解递归算法？如何理解递归函数及其应用？</p>","more":"<p><strong>递归算法</strong>在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。在程序语言中，程序调用自身的编程技巧称为<strong>递归</strong>。<strong>递归函数</strong>是指在运行的过程中函数直接或间接调用函数自身。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。</p>\n<h2 id=\"理解递归\"><a href=\"#理解递归\" class=\"headerlink\" title=\"理解递归\"></a>理解递归</h2><p>递归函数是指函数直接或间接调用函数本身。</p>\n<p>这句话理解起来并不难，从概念上出发，理解递归函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"函数 foo 是递归函数。\"</span>);</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 foo 函数就是一个递归函数。</p>\n<p>当你把这个函数拿到浏览器上运行的时候，你会发现内存溢出了，为什么呢？因为这个递归函数没有停止处理或运算的出口，因此这个递归函数就演变为一个死循环，即函数永无休止的调用自身。</p>\n<p>因此，使用递归函数必须要符合两个条件：</p>\n<ul>\n<li><strong>递归表达式(规律)</strong></li>\n<li><strong>递归出口(终止递归的条件)</strong></li>\n</ul>\n<p>递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。</p>\n<p>例如：求1+2+3+…+n的和。</p>\n<p>分析：</p>\n<ul>\n<li>当n=1时，和就是1</li>\n<li>当n&gt;1时，和就是1+2+3+…+(n-1)的和加上n。</li>\n</ul>\n<p>于是得到了上面求和的数学定义：<br>$$<br>f(n) =<br>\\begin{cases}<br>1,  &amp; \\text{$n$ = 1} \\\\<br>f(n-1)+n, &amp; \\text{$n$ &gt; 1}<br>\\end{cases}<br>$$</p>\n<p>使用for循环来实现求和1+2+3+….+n，那是很简单的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    result = result + i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前面说过，循环都可以使用递归来进行改写，递归实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(n - <span class=\"number\">1</span>) + n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归的应用\"><a href=\"#递归的应用\" class=\"headerlink\" title=\"递归的应用\"></a>递归的应用</h2><p><strong>递归算法</strong>解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在<strong>递归调用</strong>的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成<strong>栈溢出</strong>等。</p>\n<p><strong>数组中的最大值</strong></p>\n<p>使用用递归求数组中的最大值，那怎么用呢？首先还是先要找到<strong>递归表达式(规律)</strong>和<strong>递归出口</strong>。</p>\n<p>1、找递归表达式(规律)：</p>\n<ul>\n<li>将数组第一个元素-&gt;2与数组后面的数-&gt;[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]进行切割，将数组后面的数看成是一个整体X=[3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2]，那么我们就可以看成是第一个数2和一个整体X进行比较。</li>\n<li>找出整体X的最大值又是和我们的初始目的(找出最大值)是一样的</li>\n</ul>\n<p>2、找递归出口：</p>\n<ul>\n<li>如果数组只有1个元素时，那么这个数组最大值就是数组的第一个元素。</li>\n</ul>\n<p>技巧：在递归中常常是将问题<strong>切割成两个部分(1和整体的思想)</strong>，这能够让我们快速找到递归表达式(规律)</p>\n<p>那么递归的实现如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = findMax(arr.slice(<span class=\"number\">1</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>斐波那契数列</strong></p>\n<p>斐波那契数列（1，1，2，3，5，8，13，21，34，55，…..，n）是递归的典型应用案例。斐波那契数列的规律是：<strong>前两项之和等于第三项</strong>。</p>\n<p>如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + 1 = 2</span><br><span class=\"line\">1 + 2 = 3</span><br><span class=\"line\">2 + 3 = 5</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>那么第n项是多少？第n项时第n-1和第n-2项的和，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)。递归出口有两个，因为它是前两项加起来才得出第三项的值。</p>\n<p>用递归实现求斐波那契数列第n项的值，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fibonacci = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归优化——尾递归\"><a href=\"#递归优化——尾递归\" class=\"headerlink\" title=\"递归优化——尾递归\"></a>递归优化——尾递归</h2><p>递归和循环相比运行效率较低，即递归的性能不如循环。一般的递归容易造成<strong>栈溢出</strong>，即内存泄漏（内存不足）。</p>\n<p>为什么递归运行效率较低？容易造成<strong>栈溢出</strong>？看下递归实现1+2+3+…+n求和的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + sum(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当n=5时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>递归过程如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"number\">5</span> + sum(<span class=\"number\">4</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + sum(<span class=\"number\">3</span>)&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + sum(<span class=\"number\">2</span>)&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + &#123;<span class=\"number\">2</span> + sum(<span class=\"number\">1</span>)&#125;&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + &#123;<span class=\"number\">2</span> + <span class=\"number\">1</span>&#125;&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + &#123;<span class=\"number\">3</span> + <span class=\"number\">3</span>&#125;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + &#123;<span class=\"number\">4</span> + <span class=\"number\">6</span>&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"number\">5</span> + <span class=\"number\">10</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看出：当n=5时，因为要先求得sum(4)的结果，于是sum(4)就被压栈，内存无法释放；当求sum(4)时，同样的，要先求的sum(3)的结果，于是sum(3)也被压栈。以此类推，一直到递归的出口n=1时，被压住的栈帧才被逐步释放。</p>\n<p>当n足够大时，就会造成栈溢出。经测试当运行sum(100000)时，Chrome浏览器的内存就被爆了，抛出错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p>\n<p>因此，需要对递归进行优化，其中<strong>尾递归</strong>是常用的一种方法。如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</p>\n<p>要理解尾递归一定是尾调用，所以要理解尾递归就要先理解<strong>尾调用</strong>。</p>\n<p><strong>尾调用</strong>就是指某个函数的最后一步是调用另一个函数。尾调用是函数式编程的一个重要概念。</p>\n<p>一个尾调用的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以下两种情况，都不属于尾调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 情况一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>\n<p><em>注意：<strong>尾递归一定是尾调用，反之不成立</strong>。</em></p>\n<p>现在，用尾递归改写sum函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(n - <span class=\"number\">1</span>, total + n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当n=5时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>递归过程如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">5</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">3</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">2</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">14</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure></p>\n<p>上面尾递归的运行原理是：把递归顺序中<strong>倒数第一步</strong>的结果先求出来，当作参数传进递归函数中，最后返回求递归顺序中<strong>倒数第二步</strong>的结果，以此类推，直到递归出口。又因为，每次递归都只<strong>返回一个函数</strong>。因此，每次递归，递归函数的运算只依赖于自身的参数，即每次递归完成后内存都可以得到释放，不存在压栈的问题。</p>\n<p>于是，尾递归可以定义为：<strong>最后一步只调用自身的递归函数</strong>。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<p><strong>尾调用优化</strong>对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<p><em>注意：ES6的尾调用优化只在<strong>严格模式</strong>下开启，正常模式是无效的。</em></p>\n<p>目前，大多数浏览器都没有尾递归优化功能，即使是node.js这项功能默认都是关闭的状态。因此，在开发过程中，除非是无法避免的情况，否则，尽量使用循环替代递归。</p>"},{"title":"使用custom elements创建自定义元素","date":"2019-06-04T16:00:00.000Z","toc":false,"comments":0,"_content":"\nWeb Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。这篇文章将会介绍如何使用HTML的custom elements。\n\n<!--more-->\n\n## 注册新的元素\n\n自定义元素（Custom Elements）就是用户自定义的HTML元素，可以使用CustomElementRegistry定义自定义元素。如果你想注册新的元素，只需通过window.customElements获得registry的实例，然后调用其define方法：\n```js\nwindow.customElements.define('my-element', MyElement);\n```\n\ndefine方法的第一个参数是要创建的新元素的标签名称。接下来，你可以像使用元素html元素一样，只需要下面的html代码就可以使用该元素：\n```html\n<my-element></my-element> \n```\n或者使用document.createElement创建后再插入文档中：\n```js\nvar elem = document.createElement('my-element');\ndocument.body.appendChild(elem);\n```\n\n注意：名称中的横线（-）是必须的，这是为了避免与原生HTML元素的命名冲突。\n\nMyElement构造函数必须是ES6类，然而很不幸的是，由于Javascript类不同于传统的OOP语言的类，这很容易造成混乱。而且，因为这里可以使用Object，所以Proxy也是可行的，这样就能在自定义元素上实现简单的数据绑定。但是，如果想实现对原生HTML元素的扩展，这个限制是必须的，这样才能保证你的元素能够继承整个DOM API。\n\n下面我们来为自定义元素写一个类：\n```js\nclass MyElement extends HTMLElement {\n  \n constructor () {\n    super();\n  }\n  \n  connectedCallback () {\n    // here the element has been inserted into the DOM\n    console.log('元素创建成功！')\n  }\n}\n```\n我们自定义元素的类只是普通的JavaScript类，它扩展了原生的HTMLElement。除了构造函数之外，它还有个方法叫做connectedCallback，当元素被插入到DOM树之后该方法会被调用。\n\n一般来说，组件的设置应当尽可能低推迟到connectdedCallback中进行，因为这是唯一一个能够确保所有属性和子元素都存在的地方。一般来说，构造函数应该仅初始化状态，以及设置影子DOM（Shadow DOM）。\n\n你也可以通过customElements.get('my-element')来获取自定义元素的构造函数的引用，通过该方法来创建元素，假设该元素已经通过customElements.define()注册过了的话。然后可以通过new element()而不是document.createElement()来初始化元素：\n```js\ncustomElements.define('my-element', class extends HTMLElement {...});\n...\nconst el = customElements.get('my-element');\nconst myElement = new el();  // same as document.createElement('my-element');\ndocument.body.appendChild(myElement);\n```\n\n示例：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <script>\n      \n      customElements.define('my-element', class extends HTMLElement {\n        constructor () {\n          super();\n        }\n      \n        connectedCallback () {\n          console.log('注册元素')\n        }\n      });\n      \n      const el = customElements.get('my-element');\n      const myElement = new el();  // 等同于 document.createElement('my-element');\n      myElement.innerHTML = '自定义元素'\n      document.body.appendChild(myElement); // 此时，调用connectedCallback回调函数\n      \n    </script>\n  </body>\n</html>\n```\n\n## 生命周期\n\n你是否注意到上面的代码中使用了connectedCallback函数——当元素被插入到DOM树之后该方法会被调用。这是自定义元素中的一个生命周期回调函数。\n\n在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：\n\n* connectedCallback：当 custom element首次被插入文档DOM时，被调用。\n* disconnectedCallback：当 custom element从文档DOM中删除时，被调用。\n* adoptedCallback：当 custom element被移动到新的文档时，被调用。\n* attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。\n\n元素的constructor和connectedCallback的区别在于，constructor在元素被创建时调用（例如通过调用document.createElement创建），而connectedCallback是在元素真正被插入到DOM中时调用，例如当元素所在的文档被解析时，或者通过document.body.appendChild添加元素时。\n\n与connectedCallback相对的就是disconnectedCallback，当元素从DOM中移除时会调用该方法。在这个方法中可以进行必要的清理工作，但要记住这个方法不一定会被调用，比如用户关闭浏览器或关闭浏览器标签页的时候。\n\n另一个常用的生命周期方法是attributeChangedCallback。当属性被添加到observedAttributes数组时该方法会被调用。该方法调用时的参数为属性的名称、属性的旧值和新值：\n```js\nclass MyElement extends HTMLElement {\n  static get observedAttributes() {\n    return ['foo', 'bar'];\n  }\n\n  attributeChangedCallback(attr, oldVal, newVal) {\n    switch(attr) {\n      case 'foo':\n        // do something with 'foo' attribute\n\n      case 'bar':\n        // do something with 'bar' attribute\n\n    }\n  }\n}\n```\n该回调函数仅在属性存在于observedAttributes数组中时才会被调用，在上例中为foo和bar。任何其他属性的变化不会调用该回调函数。\n\n注意：使用observedAttributes监听属性时，必须要使用setAttribute函数设置属性才有效，并且attributeChangedCallback监听到的值（newVal）都是字符串。\n\n修改组件代码，如下：\n```js\nclass MyElement extends HTMLElement {  \n  static get observedAttributes () {    \n    return ['disabled'];  \n  }\n\n  constructor () {\n    super();\n    console.log('constructor')\n  }\n\n  attributeChangedCallback (attr, oldVal, newVal) {  \n    console.log('attributeChangedCallback')\n  }\n  \n  connectedCallback () {\n    console.log('connectedCallback')\n  }\n}\n```\n\n运行发现，生命周期方法的执行顺序为：\n```\nconstructor -> attributeChangedCallback -> connectedCallback\n```\n\n为什么attributeChangedCallback会在connectedCallback之前被调用？\n\n回忆一下，Web组件的属性的主要目的是初始化配置。也就是说，当组件被插入到DOM中时，配置应当已经被初始化过了，所以attributeChangedCallback应当在connectedCallback之前被调用。\n\n也就是说，如果想根据特定属性的值，在影子DOM中配置任何结点，那就需要在constructor中引用属性，而不能在connectedCallback中进行。\n\n例如，如果组件中有个id=\"container\"元素，而你需要在属性disabled发生改变时，将这个元素设置为灰色背景，那么需要在constructor中引用该属性，这样它才能出现在attributeChangedCallback中：\n```js\nclass MyElement extends HTMLElement {  \n  static get observedAttributes () {    \n    return ['disabled'];  \n  }\n\n  constructor () {\n    super();\n    ...\n    this.container = this.shadowRoot.querySelector('#container');\n  }\n\n  attributeChangedCallback (attr, oldVal, newVal) {  \n    if(attr === 'disabled') {\n      this.container.style.background = this.hasAttribute('disabled') ? '#808080' : '#ffffff';\n    }\n  }\n}\n```\n\n如果不得不等到connectedCallback中才能创建this.container，那么可能在第一次attributeChangedCallback被调用时，this.container不存在。所以，尽管你应当尽量将组件的设置推迟到connectedCallback中进行，但这是个例外情况。\n\n另一点很重要的是，要意识到你可以在通过customElements.define()注册Web组件之前就使用它。当元素存在于DOM中，或者被插入到DOM中时，如果它还没有被注册，那么它将成为HTMLUnknownElement的实例。浏览器会对于任何它不认识的HTML元素的处理方法是，你依然可以像使用其他元素那样使用它，只是它没有任何方法，也没有默认的样式。\n\n在通过customElements.define()注册之后，该元素就会通过类定义得到增强。该过程称为“升级”（upgrading）。可以在元素被升级时通过customElements.whenDefined调用一个回调函数，该方法返回一个Promise，在元素被升级时该Promise得到解决：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <button>注册元素</button>\n    \n    <script>\n      \n      class MyElement extends HTMLElement {\n        constructor () {\n          super();\n        }\n      }\n      \n      customElements.whenDefined('my-element')\n        .then(() => {\n          console.log('注册my-element元素')\n        })\n      \n      document.querySelector('button').onclick = function () {\n        window.customElements.define('my-element', MyElement);\n      }\n      \n    </script>\n  </body>\n</html>\n```\n\n## Web组件的公共API\n\n除了生命周期方法之外，你还可以在元素上定义方法，这些方法可以从外部调用。这个功能是React和Angular等框架无法实现的。例如，你可以定义一个名为doSomething的方法：\n```js\nclass MyElement extends HTMLElement {\n  ...\n\n  doSomething() {\n    // do something in this method\n  }\n}\n```\n\n然后在组件外部像这样调用它：\n```js\nconst el = document.querySelector('my-element');\nel.doSomething();\n```\n\n任何在元素上定义的属性都会成为它的公开JavaScript API的一部分。这样，只需给元素的属性提供setter，就可以实现数据绑定，从而实现类似于在元素的HTML里渲染属性值等功能。因为原生的HTML属性（attribute）值仅支持字符串，因此对象等复杂的值应该作为自定义元素的属性（properties）。\n\n除了定义Web组件的初始状态之外，HTML属性（attribute）还用来反映相应的组件属性（property）的值，因此元素的JavaScript状态可以反映到其DOM表示中。下面的例子演示了input元素的disabled属性：\n```js\n<input name=\"name\">\n\nconst input = document.querySelector('input');\ninput.disabled = true;\n```\n\n在将input的disabled属性（property）设置为true后，这个改动会反映到相应的disabled HTML属性（attribute）中：\n```html\n<input name=\"name\" disabled>\n```\n\n用setter可以很容易实现从属性（property）到HTML属性（attribute）的映射：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <my-element>自定义元素</my-element>\n    <p>\n      <button class=\"btn__set\">设置disabled</button>\n      <button class=\"btn__get\">获取disabled</button>\n    </p>\n    \n    <script>\n      \n      class MyElement extends HTMLElement {\n        constructor () {\n          super();\n        }\n        \n        set disabled (val) {\n          this.setAttribute('disabled', val)\n        }\n        \n        get disabled () {\n          return this.getAttribute('disabled')\n        }\n      }\n      \n      window.customElements.define('my-element', MyElement);\n      \n      document.querySelector('.btn__set').onclick = function () {\n        document.querySelector('my-element').disabled = true\n      }\n      \n      document.querySelector('.btn__get').onclick = function () {\n        const disabled = document.querySelector('my-element').disabled\n        console.log(disabled)\n      }\n      \n    </script>\n  </body>\n</html>\n```\n通过这种方式，你可以向属性传递任何类型的值。","source":"_posts/2019-06-05-使用custom elements创建自定义元素.md","raw":"---\ntitle: 使用custom elements创建自定义元素\ndate: 2019-06-05\ntoc: false\ncomments: false\ntags:\n    - 自定义元素\n    - Web组件\n    - Web组件生命周期\ncategories:\n    - Web组件标准\n---\n\nWeb Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。这篇文章将会介绍如何使用HTML的custom elements。\n\n<!--more-->\n\n## 注册新的元素\n\n自定义元素（Custom Elements）就是用户自定义的HTML元素，可以使用CustomElementRegistry定义自定义元素。如果你想注册新的元素，只需通过window.customElements获得registry的实例，然后调用其define方法：\n```js\nwindow.customElements.define('my-element', MyElement);\n```\n\ndefine方法的第一个参数是要创建的新元素的标签名称。接下来，你可以像使用元素html元素一样，只需要下面的html代码就可以使用该元素：\n```html\n<my-element></my-element> \n```\n或者使用document.createElement创建后再插入文档中：\n```js\nvar elem = document.createElement('my-element');\ndocument.body.appendChild(elem);\n```\n\n注意：名称中的横线（-）是必须的，这是为了避免与原生HTML元素的命名冲突。\n\nMyElement构造函数必须是ES6类，然而很不幸的是，由于Javascript类不同于传统的OOP语言的类，这很容易造成混乱。而且，因为这里可以使用Object，所以Proxy也是可行的，这样就能在自定义元素上实现简单的数据绑定。但是，如果想实现对原生HTML元素的扩展，这个限制是必须的，这样才能保证你的元素能够继承整个DOM API。\n\n下面我们来为自定义元素写一个类：\n```js\nclass MyElement extends HTMLElement {\n  \n constructor () {\n    super();\n  }\n  \n  connectedCallback () {\n    // here the element has been inserted into the DOM\n    console.log('元素创建成功！')\n  }\n}\n```\n我们自定义元素的类只是普通的JavaScript类，它扩展了原生的HTMLElement。除了构造函数之外，它还有个方法叫做connectedCallback，当元素被插入到DOM树之后该方法会被调用。\n\n一般来说，组件的设置应当尽可能低推迟到connectdedCallback中进行，因为这是唯一一个能够确保所有属性和子元素都存在的地方。一般来说，构造函数应该仅初始化状态，以及设置影子DOM（Shadow DOM）。\n\n你也可以通过customElements.get('my-element')来获取自定义元素的构造函数的引用，通过该方法来创建元素，假设该元素已经通过customElements.define()注册过了的话。然后可以通过new element()而不是document.createElement()来初始化元素：\n```js\ncustomElements.define('my-element', class extends HTMLElement {...});\n...\nconst el = customElements.get('my-element');\nconst myElement = new el();  // same as document.createElement('my-element');\ndocument.body.appendChild(myElement);\n```\n\n示例：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <script>\n      \n      customElements.define('my-element', class extends HTMLElement {\n        constructor () {\n          super();\n        }\n      \n        connectedCallback () {\n          console.log('注册元素')\n        }\n      });\n      \n      const el = customElements.get('my-element');\n      const myElement = new el();  // 等同于 document.createElement('my-element');\n      myElement.innerHTML = '自定义元素'\n      document.body.appendChild(myElement); // 此时，调用connectedCallback回调函数\n      \n    </script>\n  </body>\n</html>\n```\n\n## 生命周期\n\n你是否注意到上面的代码中使用了connectedCallback函数——当元素被插入到DOM树之后该方法会被调用。这是自定义元素中的一个生命周期回调函数。\n\n在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：\n\n* connectedCallback：当 custom element首次被插入文档DOM时，被调用。\n* disconnectedCallback：当 custom element从文档DOM中删除时，被调用。\n* adoptedCallback：当 custom element被移动到新的文档时，被调用。\n* attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。\n\n元素的constructor和connectedCallback的区别在于，constructor在元素被创建时调用（例如通过调用document.createElement创建），而connectedCallback是在元素真正被插入到DOM中时调用，例如当元素所在的文档被解析时，或者通过document.body.appendChild添加元素时。\n\n与connectedCallback相对的就是disconnectedCallback，当元素从DOM中移除时会调用该方法。在这个方法中可以进行必要的清理工作，但要记住这个方法不一定会被调用，比如用户关闭浏览器或关闭浏览器标签页的时候。\n\n另一个常用的生命周期方法是attributeChangedCallback。当属性被添加到observedAttributes数组时该方法会被调用。该方法调用时的参数为属性的名称、属性的旧值和新值：\n```js\nclass MyElement extends HTMLElement {\n  static get observedAttributes() {\n    return ['foo', 'bar'];\n  }\n\n  attributeChangedCallback(attr, oldVal, newVal) {\n    switch(attr) {\n      case 'foo':\n        // do something with 'foo' attribute\n\n      case 'bar':\n        // do something with 'bar' attribute\n\n    }\n  }\n}\n```\n该回调函数仅在属性存在于observedAttributes数组中时才会被调用，在上例中为foo和bar。任何其他属性的变化不会调用该回调函数。\n\n注意：使用observedAttributes监听属性时，必须要使用setAttribute函数设置属性才有效，并且attributeChangedCallback监听到的值（newVal）都是字符串。\n\n修改组件代码，如下：\n```js\nclass MyElement extends HTMLElement {  \n  static get observedAttributes () {    \n    return ['disabled'];  \n  }\n\n  constructor () {\n    super();\n    console.log('constructor')\n  }\n\n  attributeChangedCallback (attr, oldVal, newVal) {  \n    console.log('attributeChangedCallback')\n  }\n  \n  connectedCallback () {\n    console.log('connectedCallback')\n  }\n}\n```\n\n运行发现，生命周期方法的执行顺序为：\n```\nconstructor -> attributeChangedCallback -> connectedCallback\n```\n\n为什么attributeChangedCallback会在connectedCallback之前被调用？\n\n回忆一下，Web组件的属性的主要目的是初始化配置。也就是说，当组件被插入到DOM中时，配置应当已经被初始化过了，所以attributeChangedCallback应当在connectedCallback之前被调用。\n\n也就是说，如果想根据特定属性的值，在影子DOM中配置任何结点，那就需要在constructor中引用属性，而不能在connectedCallback中进行。\n\n例如，如果组件中有个id=\"container\"元素，而你需要在属性disabled发生改变时，将这个元素设置为灰色背景，那么需要在constructor中引用该属性，这样它才能出现在attributeChangedCallback中：\n```js\nclass MyElement extends HTMLElement {  \n  static get observedAttributes () {    \n    return ['disabled'];  \n  }\n\n  constructor () {\n    super();\n    ...\n    this.container = this.shadowRoot.querySelector('#container');\n  }\n\n  attributeChangedCallback (attr, oldVal, newVal) {  \n    if(attr === 'disabled') {\n      this.container.style.background = this.hasAttribute('disabled') ? '#808080' : '#ffffff';\n    }\n  }\n}\n```\n\n如果不得不等到connectedCallback中才能创建this.container，那么可能在第一次attributeChangedCallback被调用时，this.container不存在。所以，尽管你应当尽量将组件的设置推迟到connectedCallback中进行，但这是个例外情况。\n\n另一点很重要的是，要意识到你可以在通过customElements.define()注册Web组件之前就使用它。当元素存在于DOM中，或者被插入到DOM中时，如果它还没有被注册，那么它将成为HTMLUnknownElement的实例。浏览器会对于任何它不认识的HTML元素的处理方法是，你依然可以像使用其他元素那样使用它，只是它没有任何方法，也没有默认的样式。\n\n在通过customElements.define()注册之后，该元素就会通过类定义得到增强。该过程称为“升级”（upgrading）。可以在元素被升级时通过customElements.whenDefined调用一个回调函数，该方法返回一个Promise，在元素被升级时该Promise得到解决：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <button>注册元素</button>\n    \n    <script>\n      \n      class MyElement extends HTMLElement {\n        constructor () {\n          super();\n        }\n      }\n      \n      customElements.whenDefined('my-element')\n        .then(() => {\n          console.log('注册my-element元素')\n        })\n      \n      document.querySelector('button').onclick = function () {\n        window.customElements.define('my-element', MyElement);\n      }\n      \n    </script>\n  </body>\n</html>\n```\n\n## Web组件的公共API\n\n除了生命周期方法之外，你还可以在元素上定义方法，这些方法可以从外部调用。这个功能是React和Angular等框架无法实现的。例如，你可以定义一个名为doSomething的方法：\n```js\nclass MyElement extends HTMLElement {\n  ...\n\n  doSomething() {\n    // do something in this method\n  }\n}\n```\n\n然后在组件外部像这样调用它：\n```js\nconst el = document.querySelector('my-element');\nel.doSomething();\n```\n\n任何在元素上定义的属性都会成为它的公开JavaScript API的一部分。这样，只需给元素的属性提供setter，就可以实现数据绑定，从而实现类似于在元素的HTML里渲染属性值等功能。因为原生的HTML属性（attribute）值仅支持字符串，因此对象等复杂的值应该作为自定义元素的属性（properties）。\n\n除了定义Web组件的初始状态之外，HTML属性（attribute）还用来反映相应的组件属性（property）的值，因此元素的JavaScript状态可以反映到其DOM表示中。下面的例子演示了input元素的disabled属性：\n```js\n<input name=\"name\">\n\nconst input = document.querySelector('input');\ninput.disabled = true;\n```\n\n在将input的disabled属性（property）设置为true后，这个改动会反映到相应的disabled HTML属性（attribute）中：\n```html\n<input name=\"name\" disabled>\n```\n\n用setter可以很容易实现从属性（property）到HTML属性（attribute）的映射：\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>注册新的元素</title>\n  </head>\n  <body>\n    <my-element>自定义元素</my-element>\n    <p>\n      <button class=\"btn__set\">设置disabled</button>\n      <button class=\"btn__get\">获取disabled</button>\n    </p>\n    \n    <script>\n      \n      class MyElement extends HTMLElement {\n        constructor () {\n          super();\n        }\n        \n        set disabled (val) {\n          this.setAttribute('disabled', val)\n        }\n        \n        get disabled () {\n          return this.getAttribute('disabled')\n        }\n      }\n      \n      window.customElements.define('my-element', MyElement);\n      \n      document.querySelector('.btn__set').onclick = function () {\n        document.querySelector('my-element').disabled = true\n      }\n      \n      document.querySelector('.btn__get').onclick = function () {\n        const disabled = document.querySelector('my-element').disabled\n        console.log(disabled)\n      }\n      \n    </script>\n  </body>\n</html>\n```\n通过这种方式，你可以向属性传递任何类型的值。","slug":"2019-06-05-使用custom elements创建自定义元素","published":1,"updated":"2019-07-26T02:44:48.979Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fk004iacqxebybnms9","content":"<p>Web Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。这篇文章将会介绍如何使用HTML的custom elements。</p>\n<a id=\"more\"></a>\n<h2 id=\"注册新的元素\"><a href=\"#注册新的元素\" class=\"headerlink\" title=\"注册新的元素\"></a>注册新的元素</h2><p>自定义元素（Custom Elements）就是用户自定义的HTML元素，可以使用CustomElementRegistry定义自定义元素。如果你想注册新的元素，只需通过window.customElements获得registry的实例，然后调用其define方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span><br></pre></td></tr></table></figure></p>\n<p>define方法的第一个参数是要创建的新元素的标签名称。接下来，你可以像使用元素html元素一样，只需要下面的html代码就可以使用该元素：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-element</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者使用document.createElement创建后再插入文档中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(elem);</span><br></pre></td></tr></table></figure></p>\n<p>注意：名称中的横线（-）是必须的，这是为了避免与原生HTML元素的命名冲突。</p>\n<p>MyElement构造函数必须是ES6类，然而很不幸的是，由于Javascript类不同于传统的OOP语言的类，这很容易造成混乱。而且，因为这里可以使用Object，所以Proxy也是可行的，这样就能在自定义元素上实现简单的数据绑定。但是，如果想实现对原生HTML元素的扩展，这个限制是必须的，这样才能保证你的元素能够继承整个DOM API。</p>\n<p>下面我们来为自定义元素写一个类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  connectedCallback () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// here the element has been inserted into the DOM</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'元素创建成功！'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们自定义元素的类只是普通的JavaScript类，它扩展了原生的HTMLElement。除了构造函数之外，它还有个方法叫做connectedCallback，当元素被插入到DOM树之后该方法会被调用。</p>\n<p>一般来说，组件的设置应当尽可能低推迟到connectdedCallback中进行，因为这是唯一一个能够确保所有属性和子元素都存在的地方。一般来说，构造函数应该仅初始化状态，以及设置影子DOM（Shadow DOM）。</p>\n<p>你也可以通过customElements.get(‘my-element’)来获取自定义元素的构造函数的引用，通过该方法来创建元素，假设该元素已经通过customElements.define()注册过了的话。然后可以通过new element()而不是document.createElement()来初始化元素：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customElements.define(<span class=\"string\">'my-element'</span>, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;...&#125;);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> el = customElements.get(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myElement = <span class=\"keyword\">new</span> el();  <span class=\"comment\">// same as document.createElement('my-element');</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(myElement);</span><br></pre></td></tr></table></figure></p>\n<p>示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      customElements.define(<span class=\"string\">'my-element'</span>, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        connectedCallback () &#123;</span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册元素'</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> el = customElements.get(<span class=\"string\">'my-element'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> myElement = <span class=\"keyword\">new</span> el();  <span class=\"comment\">// 等同于 document.createElement('my-element');</span></span></span><br><span class=\"line\"><span class=\"javascript\">      myElement.innerHTML = <span class=\"string\">'自定义元素'</span></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.body.appendChild(myElement); <span class=\"comment\">// 此时，调用connectedCallback回调函数</span></span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>你是否注意到上面的代码中使用了connectedCallback函数——当元素被插入到DOM树之后该方法会被调用。这是自定义元素中的一个生命周期回调函数。</p>\n<p>在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：</p>\n<ul>\n<li>connectedCallback：当 custom element首次被插入文档DOM时，被调用。</li>\n<li>disconnectedCallback：当 custom element从文档DOM中删除时，被调用。</li>\n<li>adoptedCallback：当 custom element被移动到新的文档时，被调用。</li>\n<li>attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。</li>\n</ul>\n<p>元素的constructor和connectedCallback的区别在于，constructor在元素被创建时调用（例如通过调用document.createElement创建），而connectedCallback是在元素真正被插入到DOM中时调用，例如当元素所在的文档被解析时，或者通过document.body.appendChild添加元素时。</p>\n<p>与connectedCallback相对的就是disconnectedCallback，当元素从DOM中移除时会调用该方法。在这个方法中可以进行必要的清理工作，但要记住这个方法不一定会被调用，比如用户关闭浏览器或关闭浏览器标签页的时候。</p>\n<p>另一个常用的生命周期方法是attributeChangedCallback。当属性被添加到observedAttributes数组时该方法会被调用。该方法调用时的参数为属性的名称、属性的旧值和新值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback(attr, oldVal, newVal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(attr) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'foo'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// do something with 'foo' attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'bar'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// do something with 'bar' attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该回调函数仅在属性存在于observedAttributes数组中时才会被调用，在上例中为foo和bar。任何其他属性的变化不会调用该回调函数。</p>\n<p>注意：使用observedAttributes监听属性时，必须要使用setAttribute函数设置属性才有效，并且attributeChangedCallback监听到的值（newVal）都是字符串。</p>\n<p>修改组件代码，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes () &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'disabled'</span>];  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'constructor'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback (attr, oldVal, newVal) &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'attributeChangedCallback'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  connectedCallback () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'connectedCallback'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行发现，生命周期方法的执行顺序为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor -&gt; attributeChangedCallback -&gt; connectedCallback</span><br></pre></td></tr></table></figure></p>\n<p>为什么attributeChangedCallback会在connectedCallback之前被调用？</p>\n<p>回忆一下，Web组件的属性的主要目的是初始化配置。也就是说，当组件被插入到DOM中时，配置应当已经被初始化过了，所以attributeChangedCallback应当在connectedCallback之前被调用。</p>\n<p>也就是说，如果想根据特定属性的值，在影子DOM中配置任何结点，那就需要在constructor中引用属性，而不能在connectedCallback中进行。</p>\n<p>例如，如果组件中有个id=”container”元素，而你需要在属性disabled发生改变时，将这个元素设置为灰色背景，那么需要在constructor中引用该属性，这样它才能出现在attributeChangedCallback中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes () &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'disabled'</span>];  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.container = <span class=\"keyword\">this</span>.shadowRoot.querySelector(<span class=\"string\">'#container'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback (attr, oldVal, newVal) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(attr === <span class=\"string\">'disabled'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.container.style.background = <span class=\"keyword\">this</span>.hasAttribute(<span class=\"string\">'disabled'</span>) ? <span class=\"string\">'#808080'</span> : <span class=\"string\">'#ffffff'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果不得不等到connectedCallback中才能创建this.container，那么可能在第一次attributeChangedCallback被调用时，this.container不存在。所以，尽管你应当尽量将组件的设置推迟到connectedCallback中进行，但这是个例外情况。</p>\n<p>另一点很重要的是，要意识到你可以在通过customElements.define()注册Web组件之前就使用它。当元素存在于DOM中，或者被插入到DOM中时，如果它还没有被注册，那么它将成为HTMLUnknownElement的实例。浏览器会对于任何它不认识的HTML元素的处理方法是，你依然可以像使用其他元素那样使用它，只是它没有任何方法，也没有默认的样式。</p>\n<p>在通过customElements.define()注册之后，该元素就会通过类定义得到增强。该过程称为“升级”（upgrading）。可以在元素被升级时通过customElements.whenDefined调用一个回调函数，该方法返回一个Promise，在元素被升级时该Promise得到解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>注册元素<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      customElements.whenDefined(<span class=\"string\">'my-element'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册my-element元素'</span>)</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'button'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Web组件的公共API\"><a href=\"#Web组件的公共API\" class=\"headerlink\" title=\"Web组件的公共API\"></a>Web组件的公共API</h2><p>除了生命周期方法之外，你还可以在元素上定义方法，这些方法可以从外部调用。这个功能是React和Angular等框架无法实现的。例如，你可以定义一个名为doSomething的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something in this method</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在组件外部像这样调用它：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\">el.doSomething();</span><br></pre></td></tr></table></figure></p>\n<p>任何在元素上定义的属性都会成为它的公开JavaScript API的一部分。这样，只需给元素的属性提供setter，就可以实现数据绑定，从而实现类似于在元素的HTML里渲染属性值等功能。因为原生的HTML属性（attribute）值仅支持字符串，因此对象等复杂的值应该作为自定义元素的属性（properties）。</p>\n<p>除了定义Web组件的初始状态之外，HTML属性（attribute）还用来反映相应的组件属性（property）的值，因此元素的JavaScript状态可以反映到其DOM表示中。下面的例子演示了input元素的disabled属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input name=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">input.disabled = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在将input的disabled属性（property）设置为true后，这个改动会反映到相应的disabled HTML属性（attribute）中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">disabled</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>用setter可以很容易实现从属性（property）到HTML属性（attribute）的映射：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-element</span>&gt;</span>自定义元素<span class=\"tag\">&lt;/<span class=\"name\">my-element</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn__set\"</span>&gt;</span>设置disabled<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn__get\"</span>&gt;</span>获取disabled<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">set</span> disabled (val) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">this</span>.setAttribute(<span class=\"string\">'disabled'</span>, val)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">get</span> disabled () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'disabled'</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn__set'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>).disabled = <span class=\"literal\">true</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn__get'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> disabled = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>).disabled</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(disabled)</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过这种方式，你可以向属性传递任何类型的值。</p>\n","site":{"data":{}},"excerpt":"<p>Web Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。这篇文章将会介绍如何使用HTML的custom elements。</p>","more":"<h2 id=\"注册新的元素\"><a href=\"#注册新的元素\" class=\"headerlink\" title=\"注册新的元素\"></a>注册新的元素</h2><p>自定义元素（Custom Elements）就是用户自定义的HTML元素，可以使用CustomElementRegistry定义自定义元素。如果你想注册新的元素，只需通过window.customElements获得registry的实例，然后调用其define方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span><br></pre></td></tr></table></figure></p>\n<p>define方法的第一个参数是要创建的新元素的标签名称。接下来，你可以像使用元素html元素一样，只需要下面的html代码就可以使用该元素：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-element</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者使用document.createElement创建后再插入文档中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(elem);</span><br></pre></td></tr></table></figure></p>\n<p>注意：名称中的横线（-）是必须的，这是为了避免与原生HTML元素的命名冲突。</p>\n<p>MyElement构造函数必须是ES6类，然而很不幸的是，由于Javascript类不同于传统的OOP语言的类，这很容易造成混乱。而且，因为这里可以使用Object，所以Proxy也是可行的，这样就能在自定义元素上实现简单的数据绑定。但是，如果想实现对原生HTML元素的扩展，这个限制是必须的，这样才能保证你的元素能够继承整个DOM API。</p>\n<p>下面我们来为自定义元素写一个类：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  connectedCallback () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// here the element has been inserted into the DOM</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'元素创建成功！'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们自定义元素的类只是普通的JavaScript类，它扩展了原生的HTMLElement。除了构造函数之外，它还有个方法叫做connectedCallback，当元素被插入到DOM树之后该方法会被调用。</p>\n<p>一般来说，组件的设置应当尽可能低推迟到connectdedCallback中进行，因为这是唯一一个能够确保所有属性和子元素都存在的地方。一般来说，构造函数应该仅初始化状态，以及设置影子DOM（Shadow DOM）。</p>\n<p>你也可以通过customElements.get(‘my-element’)来获取自定义元素的构造函数的引用，通过该方法来创建元素，假设该元素已经通过customElements.define()注册过了的话。然后可以通过new element()而不是document.createElement()来初始化元素：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customElements.define(<span class=\"string\">'my-element'</span>, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;...&#125;);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> el = customElements.get(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myElement = <span class=\"keyword\">new</span> el();  <span class=\"comment\">// same as document.createElement('my-element');</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(myElement);</span><br></pre></td></tr></table></figure></p>\n<p>示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      customElements.define(<span class=\"string\">'my-element'</span>, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        connectedCallback () &#123;</span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册元素'</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> el = customElements.get(<span class=\"string\">'my-element'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> myElement = <span class=\"keyword\">new</span> el();  <span class=\"comment\">// 等同于 document.createElement('my-element');</span></span></span><br><span class=\"line\"><span class=\"javascript\">      myElement.innerHTML = <span class=\"string\">'自定义元素'</span></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.body.appendChild(myElement); <span class=\"comment\">// 此时，调用connectedCallback回调函数</span></span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>你是否注意到上面的代码中使用了connectedCallback函数——当元素被插入到DOM树之后该方法会被调用。这是自定义元素中的一个生命周期回调函数。</p>\n<p>在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：</p>\n<ul>\n<li>connectedCallback：当 custom element首次被插入文档DOM时，被调用。</li>\n<li>disconnectedCallback：当 custom element从文档DOM中删除时，被调用。</li>\n<li>adoptedCallback：当 custom element被移动到新的文档时，被调用。</li>\n<li>attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。</li>\n</ul>\n<p>元素的constructor和connectedCallback的区别在于，constructor在元素被创建时调用（例如通过调用document.createElement创建），而connectedCallback是在元素真正被插入到DOM中时调用，例如当元素所在的文档被解析时，或者通过document.body.appendChild添加元素时。</p>\n<p>与connectedCallback相对的就是disconnectedCallback，当元素从DOM中移除时会调用该方法。在这个方法中可以进行必要的清理工作，但要记住这个方法不一定会被调用，比如用户关闭浏览器或关闭浏览器标签页的时候。</p>\n<p>另一个常用的生命周期方法是attributeChangedCallback。当属性被添加到observedAttributes数组时该方法会被调用。该方法调用时的参数为属性的名称、属性的旧值和新值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback(attr, oldVal, newVal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(attr) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'foo'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// do something with 'foo' attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'bar'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// do something with 'bar' attribute</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该回调函数仅在属性存在于observedAttributes数组中时才会被调用，在上例中为foo和bar。任何其他属性的变化不会调用该回调函数。</p>\n<p>注意：使用observedAttributes监听属性时，必须要使用setAttribute函数设置属性才有效，并且attributeChangedCallback监听到的值（newVal）都是字符串。</p>\n<p>修改组件代码，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes () &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'disabled'</span>];  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'constructor'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback (attr, oldVal, newVal) &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'attributeChangedCallback'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  connectedCallback () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'connectedCallback'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行发现，生命周期方法的执行顺序为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor -&gt; attributeChangedCallback -&gt; connectedCallback</span><br></pre></td></tr></table></figure></p>\n<p>为什么attributeChangedCallback会在connectedCallback之前被调用？</p>\n<p>回忆一下，Web组件的属性的主要目的是初始化配置。也就是说，当组件被插入到DOM中时，配置应当已经被初始化过了，所以attributeChangedCallback应当在connectedCallback之前被调用。</p>\n<p>也就是说，如果想根据特定属性的值，在影子DOM中配置任何结点，那就需要在constructor中引用属性，而不能在connectedCallback中进行。</p>\n<p>例如，如果组件中有个id=”container”元素，而你需要在属性disabled发生改变时，将这个元素设置为灰色背景，那么需要在constructor中引用该属性，这样它才能出现在attributeChangedCallback中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes () &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'disabled'</span>];  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.container = <span class=\"keyword\">this</span>.shadowRoot.querySelector(<span class=\"string\">'#container'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  attributeChangedCallback (attr, oldVal, newVal) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(attr === <span class=\"string\">'disabled'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.container.style.background = <span class=\"keyword\">this</span>.hasAttribute(<span class=\"string\">'disabled'</span>) ? <span class=\"string\">'#808080'</span> : <span class=\"string\">'#ffffff'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果不得不等到connectedCallback中才能创建this.container，那么可能在第一次attributeChangedCallback被调用时，this.container不存在。所以，尽管你应当尽量将组件的设置推迟到connectedCallback中进行，但这是个例外情况。</p>\n<p>另一点很重要的是，要意识到你可以在通过customElements.define()注册Web组件之前就使用它。当元素存在于DOM中，或者被插入到DOM中时，如果它还没有被注册，那么它将成为HTMLUnknownElement的实例。浏览器会对于任何它不认识的HTML元素的处理方法是，你依然可以像使用其他元素那样使用它，只是它没有任何方法，也没有默认的样式。</p>\n<p>在通过customElements.define()注册之后，该元素就会通过类定义得到增强。该过程称为“升级”（upgrading）。可以在元素被升级时通过customElements.whenDefined调用一个回调函数，该方法返回一个Promise，在元素被升级时该Promise得到解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>注册元素<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      customElements.whenDefined(<span class=\"string\">'my-element'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册my-element元素'</span>)</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'button'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Web组件的公共API\"><a href=\"#Web组件的公共API\" class=\"headerlink\" title=\"Web组件的公共API\"></a>Web组件的公共API</h2><p>除了生命周期方法之外，你还可以在元素上定义方法，这些方法可以从外部调用。这个功能是React和Angular等框架无法实现的。例如，你可以定义一个名为doSomething的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  doSomething() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something in this method</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在组件外部像这样调用它：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>);</span><br><span class=\"line\">el.doSomething();</span><br></pre></td></tr></table></figure></p>\n<p>任何在元素上定义的属性都会成为它的公开JavaScript API的一部分。这样，只需给元素的属性提供setter，就可以实现数据绑定，从而实现类似于在元素的HTML里渲染属性值等功能。因为原生的HTML属性（attribute）值仅支持字符串，因此对象等复杂的值应该作为自定义元素的属性（properties）。</p>\n<p>除了定义Web组件的初始状态之外，HTML属性（attribute）还用来反映相应的组件属性（property）的值，因此元素的JavaScript状态可以反映到其DOM表示中。下面的例子演示了input元素的disabled属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input name=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">input.disabled = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在将input的disabled属性（property）设置为true后，这个改动会反映到相应的disabled HTML属性（attribute）中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">disabled</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>用setter可以很容易实现从属性（property）到HTML属性（attribute）的映射：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>注册新的元素<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-element</span>&gt;</span>自定义元素<span class=\"tag\">&lt;/<span class=\"name\">my-element</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn__set\"</span>&gt;</span>设置disabled<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn__get\"</span>&gt;</span>获取disabled<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">constructor</span> () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">super</span>();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">set</span> disabled (val) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">this</span>.setAttribute(<span class=\"string\">'disabled'</span>, val)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">get</span> disabled () &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'disabled'</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'my-element'</span>, MyElement);</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn__set'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>).disabled = <span class=\"literal\">true</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn__get'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> disabled = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'my-element'</span>).disabled</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(disabled)</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过这种方式，你可以向属性传递任何类型的值。</p>"},{"title":"浅谈if...else...的优化方式","date":"2019-07-29T16:00:00.000Z","toc":false,"comments":0,"_content":"\nif...else...语句是我们平时写代码时经常用到的，而且使用起来也没啥问题。问题是当业务逻辑比较复杂时，一堆条件判断就看的让人头大了，而且功能迭代时，还有可能在上面进行增量修改，内容越来越长，嵌套越来越深，可读性就变得越来越差。\n\n<!--more-->\n\n在JavaScript逻辑运算中，0、''、null、false、undefined、NaN都会判为false（假），其他都为true（真）:\n```js\nconst a = Boolean('');           // false\nconst b = Boolean(NaN);          // false\nconst c = Boolean(0);            // false\nconst d = Boolean(null);         // false\nconst e = Boolean(undefined);    // false\nconst f = Boolean(false);        // false\n```\n\n## 三元表达式替换if...else...\n\n直接用三元表达式替换简单的if...else...语句。\n\n如：\n```js\nif (this.tagElecs.showMode === 1) {\n  if (type === 2) {\n    await this.$store.dispatch('clientIndustryAnalyzeOne', params)\n  } else {\n    await this.$store.dispatch('clientIndustryAnalyzeTwo', params)\n  }\n} else {\n  if (type === 2) {\n    await this.$store.dispatch('emphasisClientAnalyzeOne', params)\n  } else {\n    await this.$store.dispatch('emphasisClientAnalyzeTwo', params)\n  }\n}\n```\n\n使用三元表达式替换替换内部嵌套的if...else...语句：\n```js\nlet dispatchURL = ''\nif (this.tagElecs.showMode === 1) {\n  dispatchURL = type === 2 ? 'clientIndustryAnalyzeOne' : 'clientIndustryAnalyzeTwo'\n} else {\n  dispatchURL = type === 2 ? 'emphasisClientAnalyzeOne' : 'emphasisClientAnalyzeTwo'\n}\nawait this.$store.dispatch(dispatchURL, params)\n```\n\n当if...else...分支逻辑较复杂时，如下功能：\n```js\nasync detailsList () {\n  // 演示模式\n  if (this.isDemo) {\n    this.elecPredSchemeDetailes = demoData\n    let time = new Date()\n    const year = time.getFullYear()\n    const month = time.getMonth() + 1\n    const day = time.getDate() + 1\n    time = `${year} - ${month} - ${day}`\n    this.runDay = time\n  } else {\n    this.queryStr = ''\n    const data = await axiosApi({ url: `/app/load/eems/elecpredschemedetail/dayAhead`, type: 'get' })\n    this.elecPredSchemeDetailes = data.elecPredSchemeDetailes\n    this.runDay = formatTime(data.runtime, 'yyyy-MM-dd')\n    this.count = data.count\n  }\n}\n```\n\n封装if...else...分支逻辑，再使用三元表达式替换：\n```js\n// 演示模式\nonDemoMode () {\n  this.elecPredSchemeDetailes = demoData\n  let time = new Date()\n  const year = time.getFullYear()\n  const month = time.getMonth() + 1\n  const day = time.getDate() + 1\n  time = `${year} - ${month} - ${day}`\n  this.runDay = time\n}，\n\n// 正常模式\nasync onNormalMode () {\n  this.queryStr = ''\n  const data = await axiosApi({ url: `/app/load/eems/elecpredschemedetail/dayAhead`, type: 'get' })\n  this.elecPredSchemeDetailes = data.elecPredSchemeDetailes\n  this.runDay = formatTime(data.runtime, 'yyyy-MM-dd')\n  this.count = data.count\n}，\n\ndetailsList () {\n  this.isDemo ? this.onDemoMode() : this.onNormalMode()\n}\n```\n\n## &&（与）、||（或）逻辑运算符替换if...else...\n\n```js\nA && B\n```\n当 A 为 true（真）时，执行语句 B，返回语句 B 的结果；当 A 为 false（假）时，不执行语句 B，返回语句 A 的结果。\n\n```js\nA || B\n```\n当 A 为 false（假）时，执行语句 B，返回语句 B 的结果；当 A 为 true（真）时，不执行语句 B，返回语句 A 的结果。\n\n使用 && 运算符替换if语句：\n```js\nif (id) {\n  this.$router.push({\n    path: '/settlementManage/retailSettlement/details',\n    query: { id, time: this.time }\n  })\n}\n```\n等价于：\n```js\nid && this.$router.push({\n  path: '/settlementManage/retailSettlement/details',\n  query: { id, time: this.time }\n})\n```\n\n使用 || 运算符替换if语句：\n```js\nif (!activeQuan) {\n  activeQuan = 0\n}\n```\n等价于：\n```js\nlet quan =  activeQuan || 0\n```\n\n## 依赖注入消除if...else...\n\nA依赖B，但A不控制B的创建和销毁，仅仅使用B，那么B的控制权交给A之外（的容器）处理，这叫控制反转（IOC），而A要依赖B，必然要使用B的接口，那么：\n\n* 通过A的接口，把B传入\n* 通过A的构造，把B传入\n* 通过设置A的属性，把B传入\n\n这个过程叫依赖注入（DI）。\n\n如下功能：\n```js\nfunction checkStatus (val) {\n  if (val === 0) {\n    return '正常'\n  } else if (val === 1) {\n    return '未核对'\n  } else if (val === 2) {\n    return '核对异常'\n  } else return '其他'\n}\n```\n\n数组元素可以通过索引访问，将依赖（或结果）注入数组可以消除if...else...语句：\n```js\nfunction checkStatus (val) {\n  const arr = ['正常', '未核对', '核对异常']\n  return arr[val] || '其他'\n}\n```\n\n另外，对象属性可以通过键名访问，将依赖（或结果）注入对象也可以消除if...else...语句：\n```js\nfunction checkStatus (val) {\n  const o = {\n    v_0: '正常',\n    v_1: '未核对',\n    v_2: '核对异常'\n  }\n  return o[`v_${val}`] || '其他'\n}\n```\n\n## 多态消除if...else...\n\n多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。简单点说：“一个接口，多种实现”，即同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。\n\n如下功能，为了让 renderMap 函数保持一定的弹性， 使用条件分支来让 renderMap 函数同时支持两种地图的接口:\n```js\nvar googleMap = {\n  show: function () {\n    console.log('开始渲染谷歌地图');\n  }\n};\n\nvar bdMap = {\n  show: function () {\n    console.log('开始渲染百度地图');\n  }\n};\n\nvar renderMap = function (type) {\n  if (type === 'google') {\n    googleMap.show();\n  } else if (type === 'bd') {\n    dbMap.show();\n  }\n};\n\nrenderMap('google'); // 输出:开始渲染谷歌地图\nrenderMap( 'baidu' ); // 输出:开始渲染百度地图\n```\n可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成其他的地图接口，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。我们还是先把程序中相同的部分抽象出来，那就是显示某个地图:\n```js\nvar renderMap = function(map){\n  if (map.show instanceof Function){\n    map.show();\n  }\n};\n\nrenderMap( googleMap ); // 输出:开始渲染谷歌地图 \nrenderMap( bdMap ); // 输出:开始渲染百度地图\n```\n现在来找找这段代码中的多态性。当向两种地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。即两种地图有相同的 show 接口，而两种地图 show 接口的表现不一样。对象的多态性表明，“做什么”和“怎么去做”是可以分开的，即使以后增加了其他地图，renderMap 函数仍然不需要做任何改变。\n\n使用多态优化以下功能：\n```js\nif (value.name === 'clientStatus') {\n  this.$refs.clientStatus.getClientStatus()\n} else if (value.name === 'apprStep') {\n  this.$refs.apprStep.init()\n} else if (value.name === 'clientData') {\n  this.$refs.clientData.getClientList()\n} else if (value.name === 'tip') {\n  this.$refs.tip.init()\n} else if (value.name === 'mould') {\n  this.$refs.mould.getList()\n} else if (value.name === 'saleGroup') {\n  this.$refs.saleGroup.initSaleGroup()\n} else if (value.name === 'marketConfig') {\n  this.$refs.marketConfig.init()\n} else if (value.name === 'serviceContent') {\n  this.$refs.serviceContent.init()\n}\n```\n\n将所有ref实例的初始化接口设置为init接口：\n```js\nif (value.name === 'clientStatus') {\n  this.$refs.clientStatus.init()\n} else if (value.name === 'apprStep') {\n  this.$refs.apprStep.init()\n} else if (value.name === 'clientData') {\n  this.$refs.clientData.init()\n} else if (value.name === 'tip') {\n  this.$refs.tip.init()\n} else if (value.name === 'mould') {\n  this.$refs.mould.init()\n} else if (value.name === 'saleGroup') {\n  this.$refs.saleGroup.init()\n} else if (value.name === 'marketConfig') {\n  this.$refs.marketConfig.init()\n} else if (value.name === 'serviceContent') {\n  this.$refs.serviceContent.init()\n}\n```\n\n使用[]读取对象属性，获取ref实例。最后执行ref实例的初始化——init函数：\n```js\nconst ref = this.$refs[value.name] // 获取ref实例\nref.init()\n```\n\n## 策略模式消除if...else...\n\n策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。即定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。主要解决在有多种算法相似的情况下，使用 if...else... 所带来的复杂和难以维护的问题。\n\n如下功能：\n```js\n// 归档合同\nasync archiveContract (id) {\n  try {\n    await this.$store.dispatch('setContractArchive', { id: id })\n    this.$message.success('归档合同成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}，\n\n// 作废合同\nasync handleCancel (row) {\n  try {\n    await this.$store.dispatch('setContractCancel', row.id)\n    this.$message.success('作废合同成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}，\n\n// 删除合同\nasync deleteContract (crtId) {\n  try {\n    await this.$store.dispatch('deleteContract2', crtId)\n    this.$message.success('删除成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n使用if...else...语句简化代码：\n```js\nasync operateContract (id, type = 'archive') {\n  try {\n    if (type === 'archive') {\n      await this.$store.dispatch('setContractArchive', { id: id })\n      this.$message.success('归档合同成功！')\n    } else if (type === 'cancel') {\n      await this.$store.dispatch('setContractCancel', id)\n      this.$message.success('作废合同成功！')\n    } else if (type === 'del') {\n      await this.$store.dispatch('deleteContract2', id)\n      this.$message.success('删除成功！')\n    }\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，该函数称为回调函数。利用高阶函数的这一特性，JavaScript策略模式更简洁。下面将三种合同操作进行函数封装，用作参数传递到operateContract函数内部执行，实现策略模式：\n```js\n// 归档合同\nasync archive (id) {\n  await this.$store.dispatch('setContractArchive', { id: id })\n  return '归档合同成功！'\n}，\n\n// 废除合同\nasync cancel (id) {\n  await this.$store.dispatch('setContractCancel', id)\n  return '作废合同成功！'\n}，\n\n// 删除合同\nasync del (id) {\n  await this.$store.dispatch('deleteContract2', id)\n  return '删除成功！'\n}，\n\n/**\n * 操作合同\n * @param {function} fn - 函数\n */\nasync operateContract (fn) {\n  try {\n    const message = await fn()\n    this.$message.success(message)\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n同样的，也可以使用依赖注入，将函数注入到对象ContractOperation中：\n```js\nconst ContractOperation = {\n  archive: archive，\n  cancel: cancel，\n  del: del\n}\n\n/**\n * 操作合同\n * @param {number} id - 合同id\n * @param {string} [type='archive'] - 操作类型: archive（删除合同）、cancel（废除合同）、delete（删除合同），默认archive\n */\nasync operateContract (id, type = 'archive') {\n  try {\n    const message = await ContractOperation[type].call(this, id)\n    this.$message.success(message)\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n## 总结\n\n综上所述，if...else...的优化方法如下：\n\n* 三元表达式替换if...else...\n* &&（与）、||（或）逻辑运算符替换if...else...\n* 依赖注入消除if...else...\n* 多态消除if...else...\n* 策略模式消除if...else...\n\n","source":"_posts/2019-07-30-浅谈if...else...的优化方法.md","raw":"---\ntitle: 浅谈if...else...的优化方式\ndate: 2019-07-30\ntoc: false\ncomments: false\ntags:\n    - 三元表达式\n    - 依赖注入\n    - 多态\n    - 逻辑运算符\n    - 策略模式\ncategories:\n    - 重构\n---\n\nif...else...语句是我们平时写代码时经常用到的，而且使用起来也没啥问题。问题是当业务逻辑比较复杂时，一堆条件判断就看的让人头大了，而且功能迭代时，还有可能在上面进行增量修改，内容越来越长，嵌套越来越深，可读性就变得越来越差。\n\n<!--more-->\n\n在JavaScript逻辑运算中，0、''、null、false、undefined、NaN都会判为false（假），其他都为true（真）:\n```js\nconst a = Boolean('');           // false\nconst b = Boolean(NaN);          // false\nconst c = Boolean(0);            // false\nconst d = Boolean(null);         // false\nconst e = Boolean(undefined);    // false\nconst f = Boolean(false);        // false\n```\n\n## 三元表达式替换if...else...\n\n直接用三元表达式替换简单的if...else...语句。\n\n如：\n```js\nif (this.tagElecs.showMode === 1) {\n  if (type === 2) {\n    await this.$store.dispatch('clientIndustryAnalyzeOne', params)\n  } else {\n    await this.$store.dispatch('clientIndustryAnalyzeTwo', params)\n  }\n} else {\n  if (type === 2) {\n    await this.$store.dispatch('emphasisClientAnalyzeOne', params)\n  } else {\n    await this.$store.dispatch('emphasisClientAnalyzeTwo', params)\n  }\n}\n```\n\n使用三元表达式替换替换内部嵌套的if...else...语句：\n```js\nlet dispatchURL = ''\nif (this.tagElecs.showMode === 1) {\n  dispatchURL = type === 2 ? 'clientIndustryAnalyzeOne' : 'clientIndustryAnalyzeTwo'\n} else {\n  dispatchURL = type === 2 ? 'emphasisClientAnalyzeOne' : 'emphasisClientAnalyzeTwo'\n}\nawait this.$store.dispatch(dispatchURL, params)\n```\n\n当if...else...分支逻辑较复杂时，如下功能：\n```js\nasync detailsList () {\n  // 演示模式\n  if (this.isDemo) {\n    this.elecPredSchemeDetailes = demoData\n    let time = new Date()\n    const year = time.getFullYear()\n    const month = time.getMonth() + 1\n    const day = time.getDate() + 1\n    time = `${year} - ${month} - ${day}`\n    this.runDay = time\n  } else {\n    this.queryStr = ''\n    const data = await axiosApi({ url: `/app/load/eems/elecpredschemedetail/dayAhead`, type: 'get' })\n    this.elecPredSchemeDetailes = data.elecPredSchemeDetailes\n    this.runDay = formatTime(data.runtime, 'yyyy-MM-dd')\n    this.count = data.count\n  }\n}\n```\n\n封装if...else...分支逻辑，再使用三元表达式替换：\n```js\n// 演示模式\nonDemoMode () {\n  this.elecPredSchemeDetailes = demoData\n  let time = new Date()\n  const year = time.getFullYear()\n  const month = time.getMonth() + 1\n  const day = time.getDate() + 1\n  time = `${year} - ${month} - ${day}`\n  this.runDay = time\n}，\n\n// 正常模式\nasync onNormalMode () {\n  this.queryStr = ''\n  const data = await axiosApi({ url: `/app/load/eems/elecpredschemedetail/dayAhead`, type: 'get' })\n  this.elecPredSchemeDetailes = data.elecPredSchemeDetailes\n  this.runDay = formatTime(data.runtime, 'yyyy-MM-dd')\n  this.count = data.count\n}，\n\ndetailsList () {\n  this.isDemo ? this.onDemoMode() : this.onNormalMode()\n}\n```\n\n## &&（与）、||（或）逻辑运算符替换if...else...\n\n```js\nA && B\n```\n当 A 为 true（真）时，执行语句 B，返回语句 B 的结果；当 A 为 false（假）时，不执行语句 B，返回语句 A 的结果。\n\n```js\nA || B\n```\n当 A 为 false（假）时，执行语句 B，返回语句 B 的结果；当 A 为 true（真）时，不执行语句 B，返回语句 A 的结果。\n\n使用 && 运算符替换if语句：\n```js\nif (id) {\n  this.$router.push({\n    path: '/settlementManage/retailSettlement/details',\n    query: { id, time: this.time }\n  })\n}\n```\n等价于：\n```js\nid && this.$router.push({\n  path: '/settlementManage/retailSettlement/details',\n  query: { id, time: this.time }\n})\n```\n\n使用 || 运算符替换if语句：\n```js\nif (!activeQuan) {\n  activeQuan = 0\n}\n```\n等价于：\n```js\nlet quan =  activeQuan || 0\n```\n\n## 依赖注入消除if...else...\n\nA依赖B，但A不控制B的创建和销毁，仅仅使用B，那么B的控制权交给A之外（的容器）处理，这叫控制反转（IOC），而A要依赖B，必然要使用B的接口，那么：\n\n* 通过A的接口，把B传入\n* 通过A的构造，把B传入\n* 通过设置A的属性，把B传入\n\n这个过程叫依赖注入（DI）。\n\n如下功能：\n```js\nfunction checkStatus (val) {\n  if (val === 0) {\n    return '正常'\n  } else if (val === 1) {\n    return '未核对'\n  } else if (val === 2) {\n    return '核对异常'\n  } else return '其他'\n}\n```\n\n数组元素可以通过索引访问，将依赖（或结果）注入数组可以消除if...else...语句：\n```js\nfunction checkStatus (val) {\n  const arr = ['正常', '未核对', '核对异常']\n  return arr[val] || '其他'\n}\n```\n\n另外，对象属性可以通过键名访问，将依赖（或结果）注入对象也可以消除if...else...语句：\n```js\nfunction checkStatus (val) {\n  const o = {\n    v_0: '正常',\n    v_1: '未核对',\n    v_2: '核对异常'\n  }\n  return o[`v_${val}`] || '其他'\n}\n```\n\n## 多态消除if...else...\n\n多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。简单点说：“一个接口，多种实现”，即同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。\n\n如下功能，为了让 renderMap 函数保持一定的弹性， 使用条件分支来让 renderMap 函数同时支持两种地图的接口:\n```js\nvar googleMap = {\n  show: function () {\n    console.log('开始渲染谷歌地图');\n  }\n};\n\nvar bdMap = {\n  show: function () {\n    console.log('开始渲染百度地图');\n  }\n};\n\nvar renderMap = function (type) {\n  if (type === 'google') {\n    googleMap.show();\n  } else if (type === 'bd') {\n    dbMap.show();\n  }\n};\n\nrenderMap('google'); // 输出:开始渲染谷歌地图\nrenderMap( 'baidu' ); // 输出:开始渲染百度地图\n```\n可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成其他的地图接口，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。我们还是先把程序中相同的部分抽象出来，那就是显示某个地图:\n```js\nvar renderMap = function(map){\n  if (map.show instanceof Function){\n    map.show();\n  }\n};\n\nrenderMap( googleMap ); // 输出:开始渲染谷歌地图 \nrenderMap( bdMap ); // 输出:开始渲染百度地图\n```\n现在来找找这段代码中的多态性。当向两种地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。即两种地图有相同的 show 接口，而两种地图 show 接口的表现不一样。对象的多态性表明，“做什么”和“怎么去做”是可以分开的，即使以后增加了其他地图，renderMap 函数仍然不需要做任何改变。\n\n使用多态优化以下功能：\n```js\nif (value.name === 'clientStatus') {\n  this.$refs.clientStatus.getClientStatus()\n} else if (value.name === 'apprStep') {\n  this.$refs.apprStep.init()\n} else if (value.name === 'clientData') {\n  this.$refs.clientData.getClientList()\n} else if (value.name === 'tip') {\n  this.$refs.tip.init()\n} else if (value.name === 'mould') {\n  this.$refs.mould.getList()\n} else if (value.name === 'saleGroup') {\n  this.$refs.saleGroup.initSaleGroup()\n} else if (value.name === 'marketConfig') {\n  this.$refs.marketConfig.init()\n} else if (value.name === 'serviceContent') {\n  this.$refs.serviceContent.init()\n}\n```\n\n将所有ref实例的初始化接口设置为init接口：\n```js\nif (value.name === 'clientStatus') {\n  this.$refs.clientStatus.init()\n} else if (value.name === 'apprStep') {\n  this.$refs.apprStep.init()\n} else if (value.name === 'clientData') {\n  this.$refs.clientData.init()\n} else if (value.name === 'tip') {\n  this.$refs.tip.init()\n} else if (value.name === 'mould') {\n  this.$refs.mould.init()\n} else if (value.name === 'saleGroup') {\n  this.$refs.saleGroup.init()\n} else if (value.name === 'marketConfig') {\n  this.$refs.marketConfig.init()\n} else if (value.name === 'serviceContent') {\n  this.$refs.serviceContent.init()\n}\n```\n\n使用[]读取对象属性，获取ref实例。最后执行ref实例的初始化——init函数：\n```js\nconst ref = this.$refs[value.name] // 获取ref实例\nref.init()\n```\n\n## 策略模式消除if...else...\n\n策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。即定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。主要解决在有多种算法相似的情况下，使用 if...else... 所带来的复杂和难以维护的问题。\n\n如下功能：\n```js\n// 归档合同\nasync archiveContract (id) {\n  try {\n    await this.$store.dispatch('setContractArchive', { id: id })\n    this.$message.success('归档合同成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}，\n\n// 作废合同\nasync handleCancel (row) {\n  try {\n    await this.$store.dispatch('setContractCancel', row.id)\n    this.$message.success('作废合同成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}，\n\n// 删除合同\nasync deleteContract (crtId) {\n  try {\n    await this.$store.dispatch('deleteContract2', crtId)\n    this.$message.success('删除成功！')\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n使用if...else...语句简化代码：\n```js\nasync operateContract (id, type = 'archive') {\n  try {\n    if (type === 'archive') {\n      await this.$store.dispatch('setContractArchive', { id: id })\n      this.$message.success('归档合同成功！')\n    } else if (type === 'cancel') {\n      await this.$store.dispatch('setContractCancel', id)\n      this.$message.success('作废合同成功！')\n    } else if (type === 'del') {\n      await this.$store.dispatch('deleteContract2', id)\n      this.$message.success('删除成功！')\n    }\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，该函数称为回调函数。利用高阶函数的这一特性，JavaScript策略模式更简洁。下面将三种合同操作进行函数封装，用作参数传递到operateContract函数内部执行，实现策略模式：\n```js\n// 归档合同\nasync archive (id) {\n  await this.$store.dispatch('setContractArchive', { id: id })\n  return '归档合同成功！'\n}，\n\n// 废除合同\nasync cancel (id) {\n  await this.$store.dispatch('setContractCancel', id)\n  return '作废合同成功！'\n}，\n\n// 删除合同\nasync del (id) {\n  await this.$store.dispatch('deleteContract2', id)\n  return '删除成功！'\n}，\n\n/**\n * 操作合同\n * @param {function} fn - 函数\n */\nasync operateContract (fn) {\n  try {\n    const message = await fn()\n    this.$message.success(message)\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n同样的，也可以使用依赖注入，将函数注入到对象ContractOperation中：\n```js\nconst ContractOperation = {\n  archive: archive，\n  cancel: cancel，\n  del: del\n}\n\n/**\n * 操作合同\n * @param {number} id - 合同id\n * @param {string} [type='archive'] - 操作类型: archive（删除合同）、cancel（废除合同）、delete（删除合同），默认archive\n */\nasync operateContract (id, type = 'archive') {\n  try {\n    const message = await ContractOperation[type].call(this, id)\n    this.$message.success(message)\n    this.form.page = 1\n    this.getList()\n  } catch (e) {\n    console.log(e)\n  }\n}\n```\n\n## 总结\n\n综上所述，if...else...的优化方法如下：\n\n* 三元表达式替换if...else...\n* &&（与）、||（或）逻辑运算符替换if...else...\n* 依赖注入消除if...else...\n* 多态消除if...else...\n* 策略模式消除if...else...\n\n","slug":"2019-07-30-浅谈if...else...的优化方法","published":1,"updated":"2019-07-29T06:45:42.570Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fm004lacqxvhzelvmb","content":"<p>if…else…语句是我们平时写代码时经常用到的，而且使用起来也没啥问题。问题是当业务逻辑比较复杂时，一堆条件判断就看的让人头大了，而且功能迭代时，还有可能在上面进行增量修改，内容越来越长，嵌套越来越深，可读性就变得越来越差。</p>\n<a id=\"more\"></a>\n<p>在JavaScript逻辑运算中，0、’’、null、false、undefined、NaN都会判为false（假），其他都为true（真）:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Boolean</span>(<span class=\"string\">''</span>);           <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>);          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>);            <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);        <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三元表达式替换if…else…\"><a href=\"#三元表达式替换if…else…\" class=\"headerlink\" title=\"三元表达式替换if…else…\"></a>三元表达式替换if…else…</h2><p>直接用三元表达式替换简单的if…else…语句。</p>\n<p>如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tagElecs.showMode === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'clientIndustryAnalyzeOne'</span>, params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'clientIndustryAnalyzeTwo'</span>, params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'emphasisClientAnalyzeOne'</span>, params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'emphasisClientAnalyzeTwo'</span>, params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用三元表达式替换替换内部嵌套的if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dispatchURL = <span class=\"string\">''</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tagElecs.showMode === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  dispatchURL = type === <span class=\"number\">2</span> ? <span class=\"string\">'clientIndustryAnalyzeOne'</span> : <span class=\"string\">'clientIndustryAnalyzeTwo'</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  dispatchURL = type === <span class=\"number\">2</span> ? <span class=\"string\">'emphasisClientAnalyzeOne'</span> : <span class=\"string\">'emphasisClientAnalyzeTwo'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(dispatchURL, params)</span><br></pre></td></tr></table></figure></p>\n<p>当if…else…分支逻辑较复杂时，如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> detailsList () &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 演示模式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isDemo) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elecPredSchemeDetailes = demoData</span><br><span class=\"line\">    <span class=\"keyword\">let</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> year = time.getFullYear()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> month = time.getMonth() + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> day = time.getDate() + <span class=\"number\">1</span></span><br><span class=\"line\">    time = <span class=\"string\">`<span class=\"subst\">$&#123;year&#125;</span> - <span class=\"subst\">$&#123;month&#125;</span> - <span class=\"subst\">$&#123;day&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.runDay = time</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queryStr = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> axiosApi(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`/app/load/eems/elecpredschemedetail/dayAhead`</span>, <span class=\"attr\">type</span>: <span class=\"string\">'get'</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elecPredSchemeDetailes = data.elecPredSchemeDetailes</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.runDay = formatTime(data.runtime, <span class=\"string\">'yyyy-MM-dd'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = data.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装if…else…分支逻辑，再使用三元表达式替换：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 演示模式</span></span><br><span class=\"line\">onDemoMode () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elecPredSchemeDetailes = demoData</span><br><span class=\"line\">  <span class=\"keyword\">let</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> year = time.getFullYear()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> month = time.getMonth() + <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> day = time.getDate() + <span class=\"number\">1</span></span><br><span class=\"line\">  time = <span class=\"string\">`<span class=\"subst\">$&#123;year&#125;</span> - <span class=\"subst\">$&#123;month&#125;</span> - <span class=\"subst\">$&#123;day&#125;</span>`</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runDay = time</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常模式</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> onNormalMode () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.queryStr = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> axiosApi(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`/app/load/eems/elecpredschemedetail/dayAhead`</span>, <span class=\"attr\">type</span>: <span class=\"string\">'get'</span> &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elecPredSchemeDetailes = data.elecPredSchemeDetailes</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runDay = formatTime(data.runtime, <span class=\"string\">'yyyy-MM-dd'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count = data.count</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\">detailsList () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isDemo ? <span class=\"keyword\">this</span>.onDemoMode() : <span class=\"keyword\">this</span>.onNormalMode()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"amp-amp-（与）、-（或）逻辑运算符替换if…else…\"><a href=\"#amp-amp-（与）、-（或）逻辑运算符替换if…else…\" class=\"headerlink\" title=\"&amp;&amp;（与）、||（或）逻辑运算符替换if…else…\"></a>&amp;&amp;（与）、||（或）逻辑运算符替换if…else…</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;&amp; B</span><br></pre></td></tr></table></figure>\n<p>当 A 为 true（真）时，执行语句 B，返回语句 B 的结果；当 A 为 false（假）时，不执行语句 B，返回语句 A 的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A || B</span><br></pre></td></tr></table></figure>\n<p>当 A 为 false（假）时，执行语句 B，返回语句 B 的结果；当 A 为 true（真）时，不执行语句 B，返回语句 A 的结果。</p>\n<p>使用 &amp;&amp; 运算符替换if语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">    path: <span class=\"string\">'/settlementManage/retailSettlement/details'</span>,</span><br><span class=\"line\">    query: &#123; id, <span class=\"attr\">time</span>: <span class=\"keyword\">this</span>.time &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id &amp;&amp; <span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/settlementManage/retailSettlement/details'</span>,</span><br><span class=\"line\">  query: &#123; id, <span class=\"attr\">time</span>: <span class=\"keyword\">this</span>.time &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>使用 || 运算符替换if语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!activeQuan) &#123;</span><br><span class=\"line\">  activeQuan = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> quan =  activeQuan || <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"依赖注入消除if…else…\"><a href=\"#依赖注入消除if…else…\" class=\"headerlink\" title=\"依赖注入消除if…else…\"></a>依赖注入消除if…else…</h2><p>A依赖B，但A不控制B的创建和销毁，仅仅使用B，那么B的控制权交给A之外（的容器）处理，这叫控制反转（IOC），而A要依赖B，必然要使用B的接口，那么：</p>\n<ul>\n<li>通过A的接口，把B传入</li>\n<li>通过A的构造，把B传入</li>\n<li>通过设置A的属性，把B传入</li>\n</ul>\n<p>这个过程叫依赖注入（DI）。</p>\n<p>如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'正常'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'未核对'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'核对异常'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>数组元素可以通过索引访问，将依赖（或结果）注入数组可以消除if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">'正常'</span>, <span class=\"string\">'未核对'</span>, <span class=\"string\">'核对异常'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[val] || <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，对象属性可以通过键名访问，将依赖（或结果）注入对象也可以消除if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">    v_0: <span class=\"string\">'正常'</span>,</span><br><span class=\"line\">    v_1: <span class=\"string\">'未核对'</span>,</span><br><span class=\"line\">    v_2: <span class=\"string\">'核对异常'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o[<span class=\"string\">`v_<span class=\"subst\">$&#123;val&#125;</span>`</span>] || <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多态消除if…else…\"><a href=\"#多态消除if…else…\" class=\"headerlink\" title=\"多态消除if…else…\"></a>多态消除if…else…</h2><p>多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。简单点说：“一个接口，多种实现”，即同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p>\n<p>如下功能，为了让 renderMap 函数保持一定的弹性， 使用条件分支来让 renderMap 函数同时支持两种地图的接口:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> googleMap = &#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染谷歌地图'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bdMap = &#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染百度地图'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'google'</span>) &#123;</span><br><span class=\"line\">    googleMap.show();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'bd'</span>) &#123;</span><br><span class=\"line\">    dbMap.show();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">renderMap(<span class=\"string\">'google'</span>); <span class=\"comment\">// 输出:开始渲染谷歌地图</span></span><br><span class=\"line\">renderMap( <span class=\"string\">'baidu'</span> ); <span class=\"comment\">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成其他的地图接口，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。我们还是先把程序中相同的部分抽象出来，那就是显示某个地图:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">map</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (map.show <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>)&#123;</span><br><span class=\"line\">    map.show();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">renderMap( googleMap ); <span class=\"comment\">// 输出:开始渲染谷歌地图 </span></span><br><span class=\"line\">renderMap( bdMap ); <span class=\"comment\">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure></p>\n<p>现在来找找这段代码中的多态性。当向两种地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。即两种地图有相同的 show 接口，而两种地图 show 接口的表现不一样。对象的多态性表明，“做什么”和“怎么去做”是可以分开的，即使以后增加了其他地图，renderMap 函数仍然不需要做任何改变。</p>\n<p>使用多态优化以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientStatus'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientStatus.getClientStatus()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'apprStep'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.apprStep.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientData'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientData.getClientList()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'tip'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.tip.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'mould'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.mould.getList()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'saleGroup'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.saleGroup.initSaleGroup()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'marketConfig'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.marketConfig.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'serviceContent'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.serviceContent.init()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将所有ref实例的初始化接口设置为init接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientStatus'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientStatus.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'apprStep'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.apprStep.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientData'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientData.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'tip'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.tip.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'mould'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.mould.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'saleGroup'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.saleGroup.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'marketConfig'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.marketConfig.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'serviceContent'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.serviceContent.init()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用[]读取对象属性，获取ref实例。最后执行ref实例的初始化——init函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ref = <span class=\"keyword\">this</span>.$refs[value.name] <span class=\"comment\">// 获取ref实例</span></span><br><span class=\"line\">ref.init()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"策略模式消除if…else…\"><a href=\"#策略模式消除if…else…\" class=\"headerlink\" title=\"策略模式消除if…else…\"></a>策略模式消除if…else…</h2><p>策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。即定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。主要解决在有多种算法相似的情况下，使用 if…else… 所带来的复杂和难以维护的问题。</p>\n<p>如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归档合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> archiveContract (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'归档合同成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作废合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> handleCancel (row) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, row.id)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'作废合同成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> deleteContract (crtId) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, crtId)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'删除成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用if…else…语句简化代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> operateContract (id, type = <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type === <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'归档合同成功！'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'cancel'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, id)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'作废合同成功！'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'del'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, id)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'删除成功！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，该函数称为回调函数。利用高阶函数的这一特性，JavaScript策略模式更简洁。下面将三种合同操作进行函数封装，用作参数传递到operateContract函数内部执行，实现策略模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归档合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> archive (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'归档合同成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 废除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> cancel (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, id)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'作废合同成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> del (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, id)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'删除成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作合同</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; fn - 函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> operateContract (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"keyword\">await</span> fn()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(message)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，也可以使用依赖注入，将函数注入到对象ContractOperation中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ContractOperation = &#123;</span><br><span class=\"line\">  archive: archive，</span><br><span class=\"line\">  cancel: cancel，</span><br><span class=\"line\">  del: del</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作合同</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; id - 合同id</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; [type='archive'] - 操作类型: archive（删除合同）、cancel（废除合同）、delete（删除合同），默认archive</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> operateContract (id, type = <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"keyword\">await</span> ContractOperation[type].call(<span class=\"keyword\">this</span>, id)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(message)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上所述，if…else…的优化方法如下：</p>\n<ul>\n<li>三元表达式替换if…else…</li>\n<li>&amp;&amp;（与）、||（或）逻辑运算符替换if…else…</li>\n<li>依赖注入消除if…else…</li>\n<li>多态消除if…else…</li>\n<li>策略模式消除if…else…</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>if…else…语句是我们平时写代码时经常用到的，而且使用起来也没啥问题。问题是当业务逻辑比较复杂时，一堆条件判断就看的让人头大了，而且功能迭代时，还有可能在上面进行增量修改，内容越来越长，嵌套越来越深，可读性就变得越来越差。</p>","more":"<p>在JavaScript逻辑运算中，0、’’、null、false、undefined、NaN都会判为false（假），其他都为true（真）:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Boolean</span>(<span class=\"string\">''</span>);           <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>);          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>);            <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);        <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三元表达式替换if…else…\"><a href=\"#三元表达式替换if…else…\" class=\"headerlink\" title=\"三元表达式替换if…else…\"></a>三元表达式替换if…else…</h2><p>直接用三元表达式替换简单的if…else…语句。</p>\n<p>如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tagElecs.showMode === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'clientIndustryAnalyzeOne'</span>, params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'clientIndustryAnalyzeTwo'</span>, params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'emphasisClientAnalyzeOne'</span>, params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'emphasisClientAnalyzeTwo'</span>, params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用三元表达式替换替换内部嵌套的if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dispatchURL = <span class=\"string\">''</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tagElecs.showMode === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  dispatchURL = type === <span class=\"number\">2</span> ? <span class=\"string\">'clientIndustryAnalyzeOne'</span> : <span class=\"string\">'clientIndustryAnalyzeTwo'</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  dispatchURL = type === <span class=\"number\">2</span> ? <span class=\"string\">'emphasisClientAnalyzeOne'</span> : <span class=\"string\">'emphasisClientAnalyzeTwo'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(dispatchURL, params)</span><br></pre></td></tr></table></figure></p>\n<p>当if…else…分支逻辑较复杂时，如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> detailsList () &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 演示模式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isDemo) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elecPredSchemeDetailes = demoData</span><br><span class=\"line\">    <span class=\"keyword\">let</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> year = time.getFullYear()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> month = time.getMonth() + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> day = time.getDate() + <span class=\"number\">1</span></span><br><span class=\"line\">    time = <span class=\"string\">`<span class=\"subst\">$&#123;year&#125;</span> - <span class=\"subst\">$&#123;month&#125;</span> - <span class=\"subst\">$&#123;day&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.runDay = time</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queryStr = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> axiosApi(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`/app/load/eems/elecpredschemedetail/dayAhead`</span>, <span class=\"attr\">type</span>: <span class=\"string\">'get'</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elecPredSchemeDetailes = data.elecPredSchemeDetailes</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.runDay = formatTime(data.runtime, <span class=\"string\">'yyyy-MM-dd'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = data.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装if…else…分支逻辑，再使用三元表达式替换：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 演示模式</span></span><br><span class=\"line\">onDemoMode () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elecPredSchemeDetailes = demoData</span><br><span class=\"line\">  <span class=\"keyword\">let</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> year = time.getFullYear()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> month = time.getMonth() + <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> day = time.getDate() + <span class=\"number\">1</span></span><br><span class=\"line\">  time = <span class=\"string\">`<span class=\"subst\">$&#123;year&#125;</span> - <span class=\"subst\">$&#123;month&#125;</span> - <span class=\"subst\">$&#123;day&#125;</span>`</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runDay = time</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常模式</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> onNormalMode () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.queryStr = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> axiosApi(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`/app/load/eems/elecpredschemedetail/dayAhead`</span>, <span class=\"attr\">type</span>: <span class=\"string\">'get'</span> &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elecPredSchemeDetailes = data.elecPredSchemeDetailes</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runDay = formatTime(data.runtime, <span class=\"string\">'yyyy-MM-dd'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count = data.count</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\">detailsList () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isDemo ? <span class=\"keyword\">this</span>.onDemoMode() : <span class=\"keyword\">this</span>.onNormalMode()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"amp-amp-（与）、-（或）逻辑运算符替换if…else…\"><a href=\"#amp-amp-（与）、-（或）逻辑运算符替换if…else…\" class=\"headerlink\" title=\"&amp;&amp;（与）、||（或）逻辑运算符替换if…else…\"></a>&amp;&amp;（与）、||（或）逻辑运算符替换if…else…</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;&amp; B</span><br></pre></td></tr></table></figure>\n<p>当 A 为 true（真）时，执行语句 B，返回语句 B 的结果；当 A 为 false（假）时，不执行语句 B，返回语句 A 的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A || B</span><br></pre></td></tr></table></figure>\n<p>当 A 为 false（假）时，执行语句 B，返回语句 B 的结果；当 A 为 true（真）时，不执行语句 B，返回语句 A 的结果。</p>\n<p>使用 &amp;&amp; 运算符替换if语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">    path: <span class=\"string\">'/settlementManage/retailSettlement/details'</span>,</span><br><span class=\"line\">    query: &#123; id, <span class=\"attr\">time</span>: <span class=\"keyword\">this</span>.time &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id &amp;&amp; <span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/settlementManage/retailSettlement/details'</span>,</span><br><span class=\"line\">  query: &#123; id, <span class=\"attr\">time</span>: <span class=\"keyword\">this</span>.time &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>使用 || 运算符替换if语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!activeQuan) &#123;</span><br><span class=\"line\">  activeQuan = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> quan =  activeQuan || <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"依赖注入消除if…else…\"><a href=\"#依赖注入消除if…else…\" class=\"headerlink\" title=\"依赖注入消除if…else…\"></a>依赖注入消除if…else…</h2><p>A依赖B，但A不控制B的创建和销毁，仅仅使用B，那么B的控制权交给A之外（的容器）处理，这叫控制反转（IOC），而A要依赖B，必然要使用B的接口，那么：</p>\n<ul>\n<li>通过A的接口，把B传入</li>\n<li>通过A的构造，把B传入</li>\n<li>通过设置A的属性，把B传入</li>\n</ul>\n<p>这个过程叫依赖注入（DI）。</p>\n<p>如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'正常'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'未核对'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'核对异常'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>数组元素可以通过索引访问，将依赖（或结果）注入数组可以消除if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">'正常'</span>, <span class=\"string\">'未核对'</span>, <span class=\"string\">'核对异常'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[val] || <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，对象属性可以通过键名访问，将依赖（或结果）注入对象也可以消除if…else…语句：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkStatus</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">    v_0: <span class=\"string\">'正常'</span>,</span><br><span class=\"line\">    v_1: <span class=\"string\">'未核对'</span>,</span><br><span class=\"line\">    v_2: <span class=\"string\">'核对异常'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o[<span class=\"string\">`v_<span class=\"subst\">$&#123;val&#125;</span>`</span>] || <span class=\"string\">'其他'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多态消除if…else…\"><a href=\"#多态消除if…else…\" class=\"headerlink\" title=\"多态消除if…else…\"></a>多态消除if…else…</h2><p>多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。简单点说：“一个接口，多种实现”，即同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p>\n<p>如下功能，为了让 renderMap 函数保持一定的弹性， 使用条件分支来让 renderMap 函数同时支持两种地图的接口:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> googleMap = &#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染谷歌地图'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bdMap = &#123;</span><br><span class=\"line\">  show: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'开始渲染百度地图'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'google'</span>) &#123;</span><br><span class=\"line\">    googleMap.show();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'bd'</span>) &#123;</span><br><span class=\"line\">    dbMap.show();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">renderMap(<span class=\"string\">'google'</span>); <span class=\"comment\">// 输出:开始渲染谷歌地图</span></span><br><span class=\"line\">renderMap( <span class=\"string\">'baidu'</span> ); <span class=\"comment\">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成其他的地图接口，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。我们还是先把程序中相同的部分抽象出来，那就是显示某个地图:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> renderMap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">map</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (map.show <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>)&#123;</span><br><span class=\"line\">    map.show();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">renderMap( googleMap ); <span class=\"comment\">// 输出:开始渲染谷歌地图 </span></span><br><span class=\"line\">renderMap( bdMap ); <span class=\"comment\">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure></p>\n<p>现在来找找这段代码中的多态性。当向两种地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。即两种地图有相同的 show 接口，而两种地图 show 接口的表现不一样。对象的多态性表明，“做什么”和“怎么去做”是可以分开的，即使以后增加了其他地图，renderMap 函数仍然不需要做任何改变。</p>\n<p>使用多态优化以下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientStatus'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientStatus.getClientStatus()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'apprStep'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.apprStep.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientData'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientData.getClientList()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'tip'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.tip.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'mould'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.mould.getList()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'saleGroup'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.saleGroup.initSaleGroup()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'marketConfig'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.marketConfig.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'serviceContent'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.serviceContent.init()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将所有ref实例的初始化接口设置为init接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientStatus'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientStatus.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'apprStep'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.apprStep.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'clientData'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.clientData.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'tip'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.tip.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'mould'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.mould.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'saleGroup'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.saleGroup.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'marketConfig'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.marketConfig.init()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.name === <span class=\"string\">'serviceContent'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$refs.serviceContent.init()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用[]读取对象属性，获取ref实例。最后执行ref实例的初始化——init函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ref = <span class=\"keyword\">this</span>.$refs[value.name] <span class=\"comment\">// 获取ref实例</span></span><br><span class=\"line\">ref.init()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"策略模式消除if…else…\"><a href=\"#策略模式消除if…else…\" class=\"headerlink\" title=\"策略模式消除if…else…\"></a>策略模式消除if…else…</h2><p>策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。即定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。主要解决在有多种算法相似的情况下，使用 if…else… 所带来的复杂和难以维护的问题。</p>\n<p>如下功能：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归档合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> archiveContract (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'归档合同成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作废合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> handleCancel (row) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, row.id)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'作废合同成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> deleteContract (crtId) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, crtId)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'删除成功！'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用if…else…语句简化代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> operateContract (id, type = <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type === <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'归档合同成功！'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'cancel'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, id)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'作废合同成功！'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'del'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, id)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$message.success(<span class=\"string\">'删除成功！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在JavaScript中函数是一等对象，可以作为参数传递到函数内部执行，该函数称为回调函数。利用高阶函数的这一特性，JavaScript策略模式更简洁。下面将三种合同操作进行函数封装，用作参数传递到operateContract函数内部执行，实现策略模式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归档合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> archive (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractArchive'</span>, &#123; <span class=\"attr\">id</span>: id &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'归档合同成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 废除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> cancel (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'setContractCancel'</span>, id)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'作废合同成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除合同</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> del (id) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'deleteContract2'</span>, id)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'删除成功！'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作合同</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; fn - 函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> operateContract (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"keyword\">await</span> fn()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(message)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，也可以使用依赖注入，将函数注入到对象ContractOperation中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ContractOperation = &#123;</span><br><span class=\"line\">  archive: archive，</span><br><span class=\"line\">  cancel: cancel，</span><br><span class=\"line\">  del: del</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作合同</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; id - 合同id</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; [type='archive'] - 操作类型: archive（删除合同）、cancel（废除合同）、delete（删除合同），默认archive</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> operateContract (id, type = <span class=\"string\">'archive'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"keyword\">await</span> ContractOperation[type].call(<span class=\"keyword\">this</span>, id)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$message.success(message)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.form.page = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getList()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上所述，if…else…的优化方法如下：</p>\n<ul>\n<li>三元表达式替换if…else…</li>\n<li>&amp;&amp;（与）、||（或）逻辑运算符替换if…else…</li>\n<li>依赖注入消除if…else…</li>\n<li>多态消除if…else…</li>\n<li>策略模式消除if…else…</li>\n</ul>"},{"title":"使用Vue Styleguidist编写组件文档","date":"2019-08-29T16:00:00.000Z","toc":false,"comments":0,"_content":"\n在日常 Vue 项目开发中，我们难免需要写一些基础公共组件，在大型项目中，我们难免会遇到下面的痛点：\n* 组件 API，对于 Vue 组件，有 props、event、slot 等接口，在团队内需要一定的沟通成本\n* 对于 UI 组件，还需要提供预览，方便团队内快速选择合适的组件\n\n如果使用 Markdown 撰写，虽然能写 API 文档，但是无法提供组件预览，并且手动写文档的成本也很大好在有一个这样的库，可以提供自动化文档的生成，并提供组件预览，这个库叫做 Vue Styleguidist。\n\n<!--more-->\n\n## 安装\n\n首先，Vue Styleguidist 只能适用于 Webpack 打包的项目，在此基础上，我们需要安装 **vue-styleguidist** 这个包：\n```\nnpm install vue-styleguidist --save-dev\n```\n然后在 package.json 配置下面两行命令，分别用于开发预览和部署打包：\n```json\n{\n  \"scripts\": {\n    \"styleguide\": \"vue-styleguidist server\",\n    \"styleguide:build\": \"vue-styleguidist build\"\n  }\n}\n```\n> 如果是使用 @vue/cli 3 生成的项目，可以直接使用 **vue-cli-plugin-styleguidist** 这个插件进行更快捷的安装和配置\n\n## 组件源代码\n\n这里为了进行简单的演示，我们使用了 @vue/cli 3 生成项目，创建组件 **src/components/AppButton/AppButton.vue**。我们的组件源代码如下，下面的案例都会依照此源代码进行展开：\n```html\n<template>\n  <button\n    class=\"btn\"\n    :type=\"htmlType\"\n    :class=\"btnClass\"\n    :disabled=\"disabled\"\n    @click=\"handleClick\"\n  >\n    <slot />\n  </button>\n</template>\n\n<script>\nexport default {\n  name: 'AppButton',\n  props: {\n    theme: {\n      type: String,\n      required: true,\n    },\n    outline: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: '',\n    },\n    block: {\n      type: Boolean,\n      default: false,\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    htmlType: {\n      type: String,\n      default: 'button',\n    },\n  },\n  computed: {\n    btnClass() {\n      return {\n        [`btn-${this.theme}`]: !!this.theme && !this.outline,\n        [`btn-outline-${this.theme}`]: this.outline,\n        [`btn-${this.size}`]: !!this.size,\n        'btn-block': this.block,\n      };\n    },\n  },\n  methods: {\n    handleClick(e) {\n      this.$emit('click', e);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\">\n@import '~bootstrap/scss/bootstrap';\n</style>\n```\n\n## Props\n\nProps 是组件最基本的 API，用于为组件传递数据，实际上，在配置好 Vue Styleguidist 之后，如果有写 prop，就已经能生成一个如下这样的文档：\n\n![props 文档示例图](/images/QQ20190830143418.png)\n\n我们可以看到，此时已经带出了 Props 的名称、参数类型、默认值、必填性等等，我们仅仅需要为 prop 写上相应的注释进行描述，像 JSDoc 一样，就能生成一份完整的 Props 说明：\n```js\nexport default {\n  props: {\n    /**\n     * 按钮主题，有效值：\n     */\n    theme: {\n      type: String,\n      required: true,\n    },\n    /**\n     * 启用outline样式\n     */\n    outline: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 按钮大小，有效值：lg sm\n     */\n    size: {\n      type: String,\n      default: '',\n    },\n    /**\n     * 启用块状按钮\n     */\n    block: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 禁用状态\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 按钮类型，有效值：button submit reset\n     */\n    htmlType: {\n      type: String,\n      default: 'button',\n    },\n  },\n};\n```\n最终会得到一份完整的 Props 说明，如下图：\n\n![props 文档示例](/images/QQ20190830143736.png)\n\n## Events\n\n除了 Props，Event 事件也是 Vue 的一个重要的 API 之一，可以通过 v-on 为组件绑定事件，Vue 的事件使用 vm.$emit('event', ...params) 的方法进行定义，我们只需要在这个方法之前，加上必要的注释就可以了。如果事件名不是字符串，可以使用 @event 进行标注事件的参数使用 @type 进行标注：\n```js\nexport default {\n  methods: {\n    handleClick(e) {\n      /**\n       * 单击事件\n       * @type {Event}\n       */\n      this.$emit('click', e);\n    },\n  },\n};\n```\n文档生成如下：\n\n![events 文档示例](/images/QQ20190830144040.png)\n\n## Slots\n\nSlot 插槽是 Vue 的自定义元素之一，Slot 向一个组件传递内容，也是封装公共组件常见的 API 之一，与 Props 和 Events 不同的是，Slots 通常是定义在 template 部分，不能使用 JS 注释进行标注，需要使用 HTML 注释，并且在注释里使用 @slot 进行标注：\n```html\n<button\n  class=\"btn\"\n  :type=\"htmlType\"\n  :class=\"btnClass\"\n  :disabled=\"disabled\"\n  @click=\"handleClick\"\n>\n  <!-- @slot 按钮的内容 -->\n  <slot />\n</button>\n```\n文档如下：\n\n![slots 文档示例1](/images/QQ20190830144301.png)\n\n如果使用的是具名 Slot（具名插槽），则会自动生成插槽名称：\n```html\n<button\n  class=\"btn\"\n  :type=\"htmlType\"\n  :class=\"btnClass\"\n  :disabled=\"disabled\"\n  @click=\"handleClick\"\n>\n  <!-- @slot 按钮的图标 -->\n  <slot name=\"icon\" />\n  <!-- @slot 按钮的内容 -->\n  <slot />\n</button>\n```\n生成文档如下图：\n\n![slots 文档示例2](/images/QQ20190830144448.png)\n\n## Methods\n\n看到这里可能各位会有个疑问，Methods 和 Events 有什么区别？区别主要有以下两个：\n* 定义方式不同：Methods 只要在 methods 里定义函数即可，Events 则需要使用 vm.$emit('event', ...params) 进行定义\n* 调用方式不同：Methods 使用 vm.$refs.ref.method() 这样的方式进行调用，Events 使用 v-on 指令或者 vm.$on('event') 进行监听\n\n实际上，使用 Methods 方法封装组件 API 的情况是比较少的，但是依然不能排除这种情况。对于 Methods 方法，我们只需要像使用 JSDoc 一样为函数进行注释就可以了，最后再附上 @public 进行标识：\n```js\nexport default {\n  methods: {\n    /**\n     * 单击事件\n     * @param {Event} e\n     * @public\n     */\n    click(e) {\n      // some code\n    },\n  },\n};\n```\n生成文档如下：\n\n![methods 文档示例](/images/QQ20190830144717.png)\n\n## 编写样例\n\n通过上面的例子，我们将至少得到一个这样的文档：\n\n![完整文档示例](/images/QQ20190830144811.png)\n\n这个文档把该有的 API 都暴露出来了，但是它并不是完美无缺的：\n\n* 直接对比 Markdown 文档，并没有明显的优势\n* 缺乏组件 UI 样例\n\n在文章的开头，我们说过，UI 组件需要为团队提供样式预览，并且需要自动生成。很遗憾的是，Vue Styleguidist 并不能直接生成预览样式，这个需要手写样式代码。在 Vue Styleguidist，有两种编写组件样例的方式：\n* README方式\n* 组件方式\n\n### README方式\n\n在组件的同个目录下，新建一个文件 README.md，比如**src/components/AppButton/README.md**，然后直接调用组件代码：\n\n![组件样例 markdown 示例](/images/QQ20190830145048.png)\n\n这样我们就能快速简洁的生成一个预览+示例代码了：\n\n![组件样例文档示例1](/images/QQ20190830145211.png)\n\n我们也可以为组件传入 Props，预览组件的表现：\n\n![组将样例传 props 示例](/images/QQ20190830145325.png)\n\n生成文档如下：\n\n![组将样例传 props 文档示例](/images/QQ20190830145418.png)\n\n### 组件方式\n可以直接在组件下方增加一个组件 “<docs></docs>”，并在里面直接使用 Markdown 编写样例，这种方式适用于项目结构比较简单的项目，但是我认为会使组件的代码变得很冗长，在此不再赘述。\n\n## 配置\n\nVue Styleguidist 支持自定义配置，只需要在项目根目录下，创建 styleguide.config.js，就可以参照官方文档进行配置：\n```js\n// styleguide.config\nmodule.exports = {\n  title: 'Default Style Guide',          // 文档的标题\n  components: 'src/components/**/*.vue', // 组件的目录\n  defaultExample: false,                 // 是否使用默认样例\n  usageMode: 'expand',                   // 是否展开用法\n  exampleMode: 'expand',                 // 是否展开示例代码\n  styleguideDir: 'styleguide',           // 打包的目录\n  codeSplit: true,                       // 打包时是否进行分片\n  skipComponentsWithoutExample: true,    // 是否跳过没有样例的组件\n};\n```\n\n## 注意事项和总结\n\n注意事项：\n* JSDoc 的标签仍然有效\n* TypeScript、Flow 和 Class 组件同样可以使用，只是使用方法稍有不同\n* JSX 也可以使用\n\n总结，通过 Vue Styleguidist，我们将至少得到下面两项好处：\n* 完整的组件 API 和用法\n* 直观的组件预览\n\n另外我认为还能得到以下几项好处：\n* 完善的注释\n* 较小的 UI 调试成本\n* 减少团队内部沟通成本\n\nVue Styleguidist 实际上还拥有多种配置和用法，各位感兴趣可以去官网看看文档。\n\n## 附录\n\n[原文地址](https://juejin.im/post/5d526cb251882526a572b791)\n[Vue Styleguidist](https://github.com/vue-styleguidist/vue-styleguidist)\n[Vue Styleguidist官方文档](https://vue-styleguidist.github.io/docs/GettingStarted.html)\n\n\n","source":"_posts/2019-08-30-使用Vue Styleguidist编写组件文档.md","raw":"---\ntitle: 使用Vue Styleguidist编写组件文档\ndate: 2019-08-30\ntoc: false\ncomments: false\ntags:\n    - 文档生成工具\n    - 转载\n    - Vue组件文档自动生成工具\n    - 前端自动化\ncategories:\n    - 前端构建工具\n---\n\n在日常 Vue 项目开发中，我们难免需要写一些基础公共组件，在大型项目中，我们难免会遇到下面的痛点：\n* 组件 API，对于 Vue 组件，有 props、event、slot 等接口，在团队内需要一定的沟通成本\n* 对于 UI 组件，还需要提供预览，方便团队内快速选择合适的组件\n\n如果使用 Markdown 撰写，虽然能写 API 文档，但是无法提供组件预览，并且手动写文档的成本也很大好在有一个这样的库，可以提供自动化文档的生成，并提供组件预览，这个库叫做 Vue Styleguidist。\n\n<!--more-->\n\n## 安装\n\n首先，Vue Styleguidist 只能适用于 Webpack 打包的项目，在此基础上，我们需要安装 **vue-styleguidist** 这个包：\n```\nnpm install vue-styleguidist --save-dev\n```\n然后在 package.json 配置下面两行命令，分别用于开发预览和部署打包：\n```json\n{\n  \"scripts\": {\n    \"styleguide\": \"vue-styleguidist server\",\n    \"styleguide:build\": \"vue-styleguidist build\"\n  }\n}\n```\n> 如果是使用 @vue/cli 3 生成的项目，可以直接使用 **vue-cli-plugin-styleguidist** 这个插件进行更快捷的安装和配置\n\n## 组件源代码\n\n这里为了进行简单的演示，我们使用了 @vue/cli 3 生成项目，创建组件 **src/components/AppButton/AppButton.vue**。我们的组件源代码如下，下面的案例都会依照此源代码进行展开：\n```html\n<template>\n  <button\n    class=\"btn\"\n    :type=\"htmlType\"\n    :class=\"btnClass\"\n    :disabled=\"disabled\"\n    @click=\"handleClick\"\n  >\n    <slot />\n  </button>\n</template>\n\n<script>\nexport default {\n  name: 'AppButton',\n  props: {\n    theme: {\n      type: String,\n      required: true,\n    },\n    outline: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: '',\n    },\n    block: {\n      type: Boolean,\n      default: false,\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    htmlType: {\n      type: String,\n      default: 'button',\n    },\n  },\n  computed: {\n    btnClass() {\n      return {\n        [`btn-${this.theme}`]: !!this.theme && !this.outline,\n        [`btn-outline-${this.theme}`]: this.outline,\n        [`btn-${this.size}`]: !!this.size,\n        'btn-block': this.block,\n      };\n    },\n  },\n  methods: {\n    handleClick(e) {\n      this.$emit('click', e);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\">\n@import '~bootstrap/scss/bootstrap';\n</style>\n```\n\n## Props\n\nProps 是组件最基本的 API，用于为组件传递数据，实际上，在配置好 Vue Styleguidist 之后，如果有写 prop，就已经能生成一个如下这样的文档：\n\n![props 文档示例图](/images/QQ20190830143418.png)\n\n我们可以看到，此时已经带出了 Props 的名称、参数类型、默认值、必填性等等，我们仅仅需要为 prop 写上相应的注释进行描述，像 JSDoc 一样，就能生成一份完整的 Props 说明：\n```js\nexport default {\n  props: {\n    /**\n     * 按钮主题，有效值：\n     */\n    theme: {\n      type: String,\n      required: true,\n    },\n    /**\n     * 启用outline样式\n     */\n    outline: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 按钮大小，有效值：lg sm\n     */\n    size: {\n      type: String,\n      default: '',\n    },\n    /**\n     * 启用块状按钮\n     */\n    block: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 禁用状态\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * 按钮类型，有效值：button submit reset\n     */\n    htmlType: {\n      type: String,\n      default: 'button',\n    },\n  },\n};\n```\n最终会得到一份完整的 Props 说明，如下图：\n\n![props 文档示例](/images/QQ20190830143736.png)\n\n## Events\n\n除了 Props，Event 事件也是 Vue 的一个重要的 API 之一，可以通过 v-on 为组件绑定事件，Vue 的事件使用 vm.$emit('event', ...params) 的方法进行定义，我们只需要在这个方法之前，加上必要的注释就可以了。如果事件名不是字符串，可以使用 @event 进行标注事件的参数使用 @type 进行标注：\n```js\nexport default {\n  methods: {\n    handleClick(e) {\n      /**\n       * 单击事件\n       * @type {Event}\n       */\n      this.$emit('click', e);\n    },\n  },\n};\n```\n文档生成如下：\n\n![events 文档示例](/images/QQ20190830144040.png)\n\n## Slots\n\nSlot 插槽是 Vue 的自定义元素之一，Slot 向一个组件传递内容，也是封装公共组件常见的 API 之一，与 Props 和 Events 不同的是，Slots 通常是定义在 template 部分，不能使用 JS 注释进行标注，需要使用 HTML 注释，并且在注释里使用 @slot 进行标注：\n```html\n<button\n  class=\"btn\"\n  :type=\"htmlType\"\n  :class=\"btnClass\"\n  :disabled=\"disabled\"\n  @click=\"handleClick\"\n>\n  <!-- @slot 按钮的内容 -->\n  <slot />\n</button>\n```\n文档如下：\n\n![slots 文档示例1](/images/QQ20190830144301.png)\n\n如果使用的是具名 Slot（具名插槽），则会自动生成插槽名称：\n```html\n<button\n  class=\"btn\"\n  :type=\"htmlType\"\n  :class=\"btnClass\"\n  :disabled=\"disabled\"\n  @click=\"handleClick\"\n>\n  <!-- @slot 按钮的图标 -->\n  <slot name=\"icon\" />\n  <!-- @slot 按钮的内容 -->\n  <slot />\n</button>\n```\n生成文档如下图：\n\n![slots 文档示例2](/images/QQ20190830144448.png)\n\n## Methods\n\n看到这里可能各位会有个疑问，Methods 和 Events 有什么区别？区别主要有以下两个：\n* 定义方式不同：Methods 只要在 methods 里定义函数即可，Events 则需要使用 vm.$emit('event', ...params) 进行定义\n* 调用方式不同：Methods 使用 vm.$refs.ref.method() 这样的方式进行调用，Events 使用 v-on 指令或者 vm.$on('event') 进行监听\n\n实际上，使用 Methods 方法封装组件 API 的情况是比较少的，但是依然不能排除这种情况。对于 Methods 方法，我们只需要像使用 JSDoc 一样为函数进行注释就可以了，最后再附上 @public 进行标识：\n```js\nexport default {\n  methods: {\n    /**\n     * 单击事件\n     * @param {Event} e\n     * @public\n     */\n    click(e) {\n      // some code\n    },\n  },\n};\n```\n生成文档如下：\n\n![methods 文档示例](/images/QQ20190830144717.png)\n\n## 编写样例\n\n通过上面的例子，我们将至少得到一个这样的文档：\n\n![完整文档示例](/images/QQ20190830144811.png)\n\n这个文档把该有的 API 都暴露出来了，但是它并不是完美无缺的：\n\n* 直接对比 Markdown 文档，并没有明显的优势\n* 缺乏组件 UI 样例\n\n在文章的开头，我们说过，UI 组件需要为团队提供样式预览，并且需要自动生成。很遗憾的是，Vue Styleguidist 并不能直接生成预览样式，这个需要手写样式代码。在 Vue Styleguidist，有两种编写组件样例的方式：\n* README方式\n* 组件方式\n\n### README方式\n\n在组件的同个目录下，新建一个文件 README.md，比如**src/components/AppButton/README.md**，然后直接调用组件代码：\n\n![组件样例 markdown 示例](/images/QQ20190830145048.png)\n\n这样我们就能快速简洁的生成一个预览+示例代码了：\n\n![组件样例文档示例1](/images/QQ20190830145211.png)\n\n我们也可以为组件传入 Props，预览组件的表现：\n\n![组将样例传 props 示例](/images/QQ20190830145325.png)\n\n生成文档如下：\n\n![组将样例传 props 文档示例](/images/QQ20190830145418.png)\n\n### 组件方式\n可以直接在组件下方增加一个组件 “<docs></docs>”，并在里面直接使用 Markdown 编写样例，这种方式适用于项目结构比较简单的项目，但是我认为会使组件的代码变得很冗长，在此不再赘述。\n\n## 配置\n\nVue Styleguidist 支持自定义配置，只需要在项目根目录下，创建 styleguide.config.js，就可以参照官方文档进行配置：\n```js\n// styleguide.config\nmodule.exports = {\n  title: 'Default Style Guide',          // 文档的标题\n  components: 'src/components/**/*.vue', // 组件的目录\n  defaultExample: false,                 // 是否使用默认样例\n  usageMode: 'expand',                   // 是否展开用法\n  exampleMode: 'expand',                 // 是否展开示例代码\n  styleguideDir: 'styleguide',           // 打包的目录\n  codeSplit: true,                       // 打包时是否进行分片\n  skipComponentsWithoutExample: true,    // 是否跳过没有样例的组件\n};\n```\n\n## 注意事项和总结\n\n注意事项：\n* JSDoc 的标签仍然有效\n* TypeScript、Flow 和 Class 组件同样可以使用，只是使用方法稍有不同\n* JSX 也可以使用\n\n总结，通过 Vue Styleguidist，我们将至少得到下面两项好处：\n* 完整的组件 API 和用法\n* 直观的组件预览\n\n另外我认为还能得到以下几项好处：\n* 完善的注释\n* 较小的 UI 调试成本\n* 减少团队内部沟通成本\n\nVue Styleguidist 实际上还拥有多种配置和用法，各位感兴趣可以去官网看看文档。\n\n## 附录\n\n[原文地址](https://juejin.im/post/5d526cb251882526a572b791)\n[Vue Styleguidist](https://github.com/vue-styleguidist/vue-styleguidist)\n[Vue Styleguidist官方文档](https://vue-styleguidist.github.io/docs/GettingStarted.html)\n\n\n","slug":"2019-08-30-使用Vue Styleguidist编写组件文档","published":1,"updated":"2019-08-30T07:20:28.624Z","layout":"post","photos":[],"link":"","_id":"ck31ar4fn004oacqx750fhi3q","content":"<p>在日常 Vue 项目开发中，我们难免需要写一些基础公共组件，在大型项目中，我们难免会遇到下面的痛点：</p>\n<ul>\n<li>组件 API，对于 Vue 组件，有 props、event、slot 等接口，在团队内需要一定的沟通成本</li>\n<li>对于 UI 组件，还需要提供预览，方便团队内快速选择合适的组件</li>\n</ul>\n<p>如果使用 Markdown 撰写，虽然能写 API 文档，但是无法提供组件预览，并且手动写文档的成本也很大好在有一个这样的库，可以提供自动化文档的生成，并提供组件预览，这个库叫做 Vue Styleguidist。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先，Vue Styleguidist 只能适用于 Webpack 打包的项目，在此基础上，我们需要安装 <strong>vue-styleguidist</strong> 这个包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-styleguidist --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在 package.json 配置下面两行命令，分别用于开发预览和部署打包：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"styleguide\"</span>: <span class=\"string\">\"vue-styleguidist server\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"styleguide:build\"</span>: <span class=\"string\">\"vue-styleguidist build\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果是使用 @vue/cli 3 生成的项目，可以直接使用 <strong>vue-cli-plugin-styleguidist</strong> 这个插件进行更快捷的安装和配置</p>\n</blockquote>\n<h2 id=\"组件源代码\"><a href=\"#组件源代码\" class=\"headerlink\" title=\"组件源代码\"></a>组件源代码</h2><p>这里为了进行简单的演示，我们使用了 @vue/cli 3 生成项目，创建组件 <strong>src/components/AppButton/AppButton.vue</strong>。我们的组件源代码如下，下面的案例都会依照此源代码进行展开：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'AppButton'</span>,</span></span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    theme: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      required: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    outline: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    size: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"string\">''</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    block: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    disabled: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    htmlType: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"string\">'button'</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    btnClass() &#123;</span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.theme&#125;</span>`</span>]: !!<span class=\"keyword\">this</span>.theme &amp;&amp; !<span class=\"keyword\">this</span>.outline,</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-outline-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.theme&#125;</span>`</span>]: <span class=\"keyword\">this</span>.outline,</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.size&#125;</span>`</span>]: !!<span class=\"keyword\">this</span>.size,</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'btn-block'</span>: <span class=\"keyword\">this</span>.block,</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick(e) &#123;</span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'click'</span>, e);</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"scss\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">@<span class=\"keyword\">import</span> <span class=\"string\">'~bootstrap/scss/bootstrap'</span>;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><p>Props 是组件最基本的 API，用于为组件传递数据，实际上，在配置好 Vue Styleguidist 之后，如果有写 prop，就已经能生成一个如下这样的文档：</p>\n<p><img src=\"/images/QQ20190830143418.png\" alt=\"props 文档示例图\"></p>\n<p>我们可以看到，此时已经带出了 Props 的名称、参数类型、默认值、必填性等等，我们仅仅需要为 prop 写上相应的注释进行描述，像 JSDoc 一样，就能生成一份完整的 Props 说明：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮主题，有效值：</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    theme: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启用outline样式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    outline: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮大小，有效值：lg sm</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    size: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启用块状按钮</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    block: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 禁用状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    disabled: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮类型，有效值：button submit reset</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    htmlType: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'button'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>最终会得到一份完整的 Props 说明，如下图：</p>\n<p><img src=\"/images/QQ20190830143736.png\" alt=\"props 文档示例\"></p>\n<h2 id=\"Events\"><a href=\"#Events\" class=\"headerlink\" title=\"Events\"></a>Events</h2><p>除了 Props，Event 事件也是 Vue 的一个重要的 API 之一，可以通过 v-on 为组件绑定事件，Vue 的事件使用 vm.$emit(‘event’, …params) 的方法进行定义，我们只需要在这个方法之前，加上必要的注释就可以了。如果事件名不是字符串，可以使用 @event 进行标注事件的参数使用 @type 进行标注：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 单击事件</span></span><br><span class=\"line\"><span class=\"comment\">       * @type &#123;Event&#125;</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'click'</span>, e);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>文档生成如下：</p>\n<p><img src=\"/images/QQ20190830144040.png\" alt=\"events 文档示例\"></p>\n<h2 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h2><p>Slot 插槽是 Vue 的自定义元素之一，Slot 向一个组件传递内容，也是封装公共组件常见的 API 之一，与 Props 和 Events 不同的是，Slots 通常是定义在 template 部分，不能使用 JS 注释进行标注，需要使用 HTML 注释，并且在注释里使用 @slot 进行标注：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>文档如下：</p>\n<p><img src=\"/images/QQ20190830144301.png\" alt=\"slots 文档示例1\"></p>\n<p>如果使用的是具名 Slot（具名插槽），则会自动生成插槽名称：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的图标 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"icon\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>生成文档如下图：</p>\n<p><img src=\"/images/QQ20190830144448.png\" alt=\"slots 文档示例2\"></p>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><p>看到这里可能各位会有个疑问，Methods 和 Events 有什么区别？区别主要有以下两个：</p>\n<ul>\n<li>定义方式不同：Methods 只要在 methods 里定义函数即可，Events 则需要使用 vm.$emit(‘event’, …params) 进行定义</li>\n<li>调用方式不同：Methods 使用 vm.$refs.ref.method() 这样的方式进行调用，Events 使用 v-on 指令或者 vm.$on(‘event’) 进行监听</li>\n</ul>\n<p>实际上，使用 Methods 方法封装组件 API 的情况是比较少的，但是依然不能排除这种情况。对于 Methods 方法，我们只需要像使用 JSDoc 一样为函数进行注释就可以了，最后再附上 @public 进行标识：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单击事件</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;Event&#125; e</span></span><br><span class=\"line\"><span class=\"comment\">     * @public</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    click(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// some code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>生成文档如下：</p>\n<p><img src=\"/images/QQ20190830144717.png\" alt=\"methods 文档示例\"></p>\n<h2 id=\"编写样例\"><a href=\"#编写样例\" class=\"headerlink\" title=\"编写样例\"></a>编写样例</h2><p>通过上面的例子，我们将至少得到一个这样的文档：</p>\n<p><img src=\"/images/QQ20190830144811.png\" alt=\"完整文档示例\"></p>\n<p>这个文档把该有的 API 都暴露出来了，但是它并不是完美无缺的：</p>\n<ul>\n<li>直接对比 Markdown 文档，并没有明显的优势</li>\n<li>缺乏组件 UI 样例</li>\n</ul>\n<p>在文章的开头，我们说过，UI 组件需要为团队提供样式预览，并且需要自动生成。很遗憾的是，Vue Styleguidist 并不能直接生成预览样式，这个需要手写样式代码。在 Vue Styleguidist，有两种编写组件样例的方式：</p>\n<ul>\n<li>README方式</li>\n<li>组件方式</li>\n</ul>\n<h3 id=\"README方式\"><a href=\"#README方式\" class=\"headerlink\" title=\"README方式\"></a>README方式</h3><p>在组件的同个目录下，新建一个文件 README.md，比如<strong>src/components/AppButton/README.md</strong>，然后直接调用组件代码：</p>\n<p><img src=\"/images/QQ20190830145048.png\" alt=\"组件样例 markdown 示例\"></p>\n<p>这样我们就能快速简洁的生成一个预览+示例代码了：</p>\n<p><img src=\"/images/QQ20190830145211.png\" alt=\"组件样例文档示例1\"></p>\n<p>我们也可以为组件传入 Props，预览组件的表现：</p>\n<p><img src=\"/images/QQ20190830145325.png\" alt=\"组将样例传 props 示例\"></p>\n<p>生成文档如下：</p>\n<p><img src=\"/images/QQ20190830145418.png\" alt=\"组将样例传 props 文档示例\"></p>\n<h3 id=\"组件方式\"><a href=\"#组件方式\" class=\"headerlink\" title=\"组件方式\"></a>组件方式</h3><p>可以直接在组件下方增加一个组件 “<docs></docs>”，并在里面直接使用 Markdown 编写样例，这种方式适用于项目结构比较简单的项目，但是我认为会使组件的代码变得很冗长，在此不再赘述。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Vue Styleguidist 支持自定义配置，只需要在项目根目录下，创建 styleguide.config.js，就可以参照官方文档进行配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// styleguide.config</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'Default Style Guide'</span>,          <span class=\"comment\">// 文档的标题</span></span><br><span class=\"line\">  components: <span class=\"string\">'src/components/**/*.vue'</span>, <span class=\"comment\">// 组件的目录</span></span><br><span class=\"line\">  defaultExample: <span class=\"literal\">false</span>,                 <span class=\"comment\">// 是否使用默认样例</span></span><br><span class=\"line\">  usageMode: <span class=\"string\">'expand'</span>,                   <span class=\"comment\">// 是否展开用法</span></span><br><span class=\"line\">  exampleMode: <span class=\"string\">'expand'</span>,                 <span class=\"comment\">// 是否展开示例代码</span></span><br><span class=\"line\">  styleguideDir: <span class=\"string\">'styleguide'</span>,           <span class=\"comment\">// 打包的目录</span></span><br><span class=\"line\">  codeSplit: <span class=\"literal\">true</span>,                       <span class=\"comment\">// 打包时是否进行分片</span></span><br><span class=\"line\">  skipComponentsWithoutExample: <span class=\"literal\">true</span>,    <span class=\"comment\">// 是否跳过没有样例的组件</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"注意事项和总结\"><a href=\"#注意事项和总结\" class=\"headerlink\" title=\"注意事项和总结\"></a>注意事项和总结</h2><p>注意事项：</p>\n<ul>\n<li>JSDoc 的标签仍然有效</li>\n<li>TypeScript、Flow 和 Class 组件同样可以使用，只是使用方法稍有不同</li>\n<li>JSX 也可以使用</li>\n</ul>\n<p>总结，通过 Vue Styleguidist，我们将至少得到下面两项好处：</p>\n<ul>\n<li>完整的组件 API 和用法</li>\n<li>直观的组件预览</li>\n</ul>\n<p>另外我认为还能得到以下几项好处：</p>\n<ul>\n<li>完善的注释</li>\n<li>较小的 UI 调试成本</li>\n<li>减少团队内部沟通成本</li>\n</ul>\n<p>Vue Styleguidist 实际上还拥有多种配置和用法，各位感兴趣可以去官网看看文档。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"https://juejin.im/post/5d526cb251882526a572b791\" target=\"_blank\" rel=\"noopener\">原文地址</a><br><a href=\"https://github.com/vue-styleguidist/vue-styleguidist\" target=\"_blank\" rel=\"noopener\">Vue Styleguidist</a><br><a href=\"https://vue-styleguidist.github.io/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Vue Styleguidist官方文档</a></p>\n","site":{"data":{}},"excerpt":"<p>在日常 Vue 项目开发中，我们难免需要写一些基础公共组件，在大型项目中，我们难免会遇到下面的痛点：</p>\n<ul>\n<li>组件 API，对于 Vue 组件，有 props、event、slot 等接口，在团队内需要一定的沟通成本</li>\n<li>对于 UI 组件，还需要提供预览，方便团队内快速选择合适的组件</li>\n</ul>\n<p>如果使用 Markdown 撰写，虽然能写 API 文档，但是无法提供组件预览，并且手动写文档的成本也很大好在有一个这样的库，可以提供自动化文档的生成，并提供组件预览，这个库叫做 Vue Styleguidist。</p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先，Vue Styleguidist 只能适用于 Webpack 打包的项目，在此基础上，我们需要安装 <strong>vue-styleguidist</strong> 这个包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-styleguidist --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在 package.json 配置下面两行命令，分别用于开发预览和部署打包：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"styleguide\"</span>: <span class=\"string\">\"vue-styleguidist server\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"styleguide:build\"</span>: <span class=\"string\">\"vue-styleguidist build\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果是使用 @vue/cli 3 生成的项目，可以直接使用 <strong>vue-cli-plugin-styleguidist</strong> 这个插件进行更快捷的安装和配置</p>\n</blockquote>\n<h2 id=\"组件源代码\"><a href=\"#组件源代码\" class=\"headerlink\" title=\"组件源代码\"></a>组件源代码</h2><p>这里为了进行简单的演示，我们使用了 @vue/cli 3 生成项目，创建组件 <strong>src/components/AppButton/AppButton.vue</strong>。我们的组件源代码如下，下面的案例都会依照此源代码进行展开：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'AppButton'</span>,</span></span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    theme: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      required: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    outline: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    size: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"string\">''</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    block: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    disabled: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">Boolean</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    htmlType: &#123;</span><br><span class=\"line\"><span class=\"javascript\">      type: <span class=\"built_in\">String</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">default</span>: <span class=\"string\">'button'</span>,</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    btnClass() &#123;</span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.theme&#125;</span>`</span>]: !!<span class=\"keyword\">this</span>.theme &amp;&amp; !<span class=\"keyword\">this</span>.outline,</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-outline-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.theme&#125;</span>`</span>]: <span class=\"keyword\">this</span>.outline,</span></span><br><span class=\"line\"><span class=\"javascript\">        [<span class=\"string\">`btn-<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.size&#125;</span>`</span>]: !!<span class=\"keyword\">this</span>.size,</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'btn-block'</span>: <span class=\"keyword\">this</span>.block,</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick(e) &#123;</span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'click'</span>, e);</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"scss\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">@<span class=\"keyword\">import</span> <span class=\"string\">'~bootstrap/scss/bootstrap'</span>;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><p>Props 是组件最基本的 API，用于为组件传递数据，实际上，在配置好 Vue Styleguidist 之后，如果有写 prop，就已经能生成一个如下这样的文档：</p>\n<p><img src=\"/images/QQ20190830143418.png\" alt=\"props 文档示例图\"></p>\n<p>我们可以看到，此时已经带出了 Props 的名称、参数类型、默认值、必填性等等，我们仅仅需要为 prop 写上相应的注释进行描述，像 JSDoc 一样，就能生成一份完整的 Props 说明：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮主题，有效值：</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    theme: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启用outline样式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    outline: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮大小，有效值：lg sm</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    size: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启用块状按钮</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    block: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 禁用状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    disabled: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮类型，有效值：button submit reset</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    htmlType: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'button'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>最终会得到一份完整的 Props 说明，如下图：</p>\n<p><img src=\"/images/QQ20190830143736.png\" alt=\"props 文档示例\"></p>\n<h2 id=\"Events\"><a href=\"#Events\" class=\"headerlink\" title=\"Events\"></a>Events</h2><p>除了 Props，Event 事件也是 Vue 的一个重要的 API 之一，可以通过 v-on 为组件绑定事件，Vue 的事件使用 vm.$emit(‘event’, …params) 的方法进行定义，我们只需要在这个方法之前，加上必要的注释就可以了。如果事件名不是字符串，可以使用 @event 进行标注事件的参数使用 @type 进行标注：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 单击事件</span></span><br><span class=\"line\"><span class=\"comment\">       * @type &#123;Event&#125;</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'click'</span>, e);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>文档生成如下：</p>\n<p><img src=\"/images/QQ20190830144040.png\" alt=\"events 文档示例\"></p>\n<h2 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h2><p>Slot 插槽是 Vue 的自定义元素之一，Slot 向一个组件传递内容，也是封装公共组件常见的 API 之一，与 Props 和 Events 不同的是，Slots 通常是定义在 template 部分，不能使用 JS 注释进行标注，需要使用 HTML 注释，并且在注释里使用 @slot 进行标注：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>文档如下：</p>\n<p><img src=\"/images/QQ20190830144301.png\" alt=\"slots 文档示例1\"></p>\n<p>如果使用的是具名 Slot（具名插槽），则会自动生成插槽名称：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:type</span>=<span class=\"string\">\"htmlType\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:class</span>=<span class=\"string\">\"btnClass\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">:disabled</span>=<span class=\"string\">\"disabled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  @<span class=\"attr\">click</span>=<span class=\"string\">\"handleClick\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的图标 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"icon\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- @slot 按钮的内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>生成文档如下图：</p>\n<p><img src=\"/images/QQ20190830144448.png\" alt=\"slots 文档示例2\"></p>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><p>看到这里可能各位会有个疑问，Methods 和 Events 有什么区别？区别主要有以下两个：</p>\n<ul>\n<li>定义方式不同：Methods 只要在 methods 里定义函数即可，Events 则需要使用 vm.$emit(‘event’, …params) 进行定义</li>\n<li>调用方式不同：Methods 使用 vm.$refs.ref.method() 这样的方式进行调用，Events 使用 v-on 指令或者 vm.$on(‘event’) 进行监听</li>\n</ul>\n<p>实际上，使用 Methods 方法封装组件 API 的情况是比较少的，但是依然不能排除这种情况。对于 Methods 方法，我们只需要像使用 JSDoc 一样为函数进行注释就可以了，最后再附上 @public 进行标识：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单击事件</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;Event&#125; e</span></span><br><span class=\"line\"><span class=\"comment\">     * @public</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    click(e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// some code</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>生成文档如下：</p>\n<p><img src=\"/images/QQ20190830144717.png\" alt=\"methods 文档示例\"></p>\n<h2 id=\"编写样例\"><a href=\"#编写样例\" class=\"headerlink\" title=\"编写样例\"></a>编写样例</h2><p>通过上面的例子，我们将至少得到一个这样的文档：</p>\n<p><img src=\"/images/QQ20190830144811.png\" alt=\"完整文档示例\"></p>\n<p>这个文档把该有的 API 都暴露出来了，但是它并不是完美无缺的：</p>\n<ul>\n<li>直接对比 Markdown 文档，并没有明显的优势</li>\n<li>缺乏组件 UI 样例</li>\n</ul>\n<p>在文章的开头，我们说过，UI 组件需要为团队提供样式预览，并且需要自动生成。很遗憾的是，Vue Styleguidist 并不能直接生成预览样式，这个需要手写样式代码。在 Vue Styleguidist，有两种编写组件样例的方式：</p>\n<ul>\n<li>README方式</li>\n<li>组件方式</li>\n</ul>\n<h3 id=\"README方式\"><a href=\"#README方式\" class=\"headerlink\" title=\"README方式\"></a>README方式</h3><p>在组件的同个目录下，新建一个文件 README.md，比如<strong>src/components/AppButton/README.md</strong>，然后直接调用组件代码：</p>\n<p><img src=\"/images/QQ20190830145048.png\" alt=\"组件样例 markdown 示例\"></p>\n<p>这样我们就能快速简洁的生成一个预览+示例代码了：</p>\n<p><img src=\"/images/QQ20190830145211.png\" alt=\"组件样例文档示例1\"></p>\n<p>我们也可以为组件传入 Props，预览组件的表现：</p>\n<p><img src=\"/images/QQ20190830145325.png\" alt=\"组将样例传 props 示例\"></p>\n<p>生成文档如下：</p>\n<p><img src=\"/images/QQ20190830145418.png\" alt=\"组将样例传 props 文档示例\"></p>\n<h3 id=\"组件方式\"><a href=\"#组件方式\" class=\"headerlink\" title=\"组件方式\"></a>组件方式</h3><p>可以直接在组件下方增加一个组件 “<docs></docs>”，并在里面直接使用 Markdown 编写样例，这种方式适用于项目结构比较简单的项目，但是我认为会使组件的代码变得很冗长，在此不再赘述。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Vue Styleguidist 支持自定义配置，只需要在项目根目录下，创建 styleguide.config.js，就可以参照官方文档进行配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// styleguide.config</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'Default Style Guide'</span>,          <span class=\"comment\">// 文档的标题</span></span><br><span class=\"line\">  components: <span class=\"string\">'src/components/**/*.vue'</span>, <span class=\"comment\">// 组件的目录</span></span><br><span class=\"line\">  defaultExample: <span class=\"literal\">false</span>,                 <span class=\"comment\">// 是否使用默认样例</span></span><br><span class=\"line\">  usageMode: <span class=\"string\">'expand'</span>,                   <span class=\"comment\">// 是否展开用法</span></span><br><span class=\"line\">  exampleMode: <span class=\"string\">'expand'</span>,                 <span class=\"comment\">// 是否展开示例代码</span></span><br><span class=\"line\">  styleguideDir: <span class=\"string\">'styleguide'</span>,           <span class=\"comment\">// 打包的目录</span></span><br><span class=\"line\">  codeSplit: <span class=\"literal\">true</span>,                       <span class=\"comment\">// 打包时是否进行分片</span></span><br><span class=\"line\">  skipComponentsWithoutExample: <span class=\"literal\">true</span>,    <span class=\"comment\">// 是否跳过没有样例的组件</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"注意事项和总结\"><a href=\"#注意事项和总结\" class=\"headerlink\" title=\"注意事项和总结\"></a>注意事项和总结</h2><p>注意事项：</p>\n<ul>\n<li>JSDoc 的标签仍然有效</li>\n<li>TypeScript、Flow 和 Class 组件同样可以使用，只是使用方法稍有不同</li>\n<li>JSX 也可以使用</li>\n</ul>\n<p>总结，通过 Vue Styleguidist，我们将至少得到下面两项好处：</p>\n<ul>\n<li>完整的组件 API 和用法</li>\n<li>直观的组件预览</li>\n</ul>\n<p>另外我认为还能得到以下几项好处：</p>\n<ul>\n<li>完善的注释</li>\n<li>较小的 UI 调试成本</li>\n<li>减少团队内部沟通成本</li>\n</ul>\n<p>Vue Styleguidist 实际上还拥有多种配置和用法，各位感兴趣可以去官网看看文档。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"https://juejin.im/post/5d526cb251882526a572b791\" target=\"_blank\" rel=\"noopener\">原文地址</a><br><a href=\"https://github.com/vue-styleguidist/vue-styleguidist\" target=\"_blank\" rel=\"noopener\">Vue Styleguidist</a><br><a href=\"https://vue-styleguidist.github.io/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Vue Styleguidist官方文档</a></p>"},{"title":"编写更好的代码的5个技巧","date":"2019-10-11T16:00:00.000Z","toc":false,"comments":0,"_content":"\n错误的代码有效。 我们都知道这一点。 开发人员多年来一直在编写代码，而没有考虑过自己是否做对了。 这是可以理解的，不是吗？ 毕竟，我们已经必须应对与行业保持同步的压力以及我们工作的需求……\n<details>\n<summary>英语原文</summary>\n<p>Bad code works. We all know this. Developers have been writting code for years without giving a single thought to whether they'er doing it right or not. It's understandable, isn't it? After all, We already have to deal with the stress of keeping up with the industry and the demands or our job...</p>\n</details>\n<!--more-->\n\n答案是否定的。编写糟糕的代码是要付出代价的。您是否曾经遇到过这样的问题：几周之后，您无法理解自己的代码，不得不花费数小时甚至数天的时间来弄清楚到底发生了什么？\n<details>\n<summary>英语原文</summary>\nThe answer is no. Writting bad codes comes at a price. Have you ever faced the issue of not understanding your own code after a couple of weeks, and having to spend hours, or even days figuring out what was going on?\n</details>\n\n解决此（极端）常见问题的方法是使您的代码尽可能清晰明了。 我甚至会说，即使是非技术人员也应该理解您的代码。 现在该丢下我们的借口，提高代码质量了。\n<details>\n<summary>英语原文</summary>\nThe solution to this (extremely) common problem is to make your code as clear and informative as possible. I will go as far as to say that your code should be understood even by a non-technical person. It's time to drop our excuses, and improve the quality of your code.\n</details>\n\n编写干净的代码并不那么复杂。 本教程将通过实际示例向您展示5种改善代码的简单技术：\n1.摆脱switch语句\n2.使你的条件句具有描述性\n3.使用保护子句避免嵌套if语句\n4.避免代码重复\n5.函数应该只做一件事\n\n<details>\n<summary>英语原文</summary>\nWritting clean code isn't that complicated. This tutorial will show you 5 simple techniques to improve your code, with practical examples:\n1.Get rid of switch statements\n2.Make your conditionals descriptive\n3.Use guard clauses to avoid nested if statements\n4.Avoid code duplication\n5.functions should only do one thing\n</details>\n\n## 摆脱switch语句(Get rid of switch statements)\n\n我们通常使用switch语句来避免使用大的if else if语句。但是，switch语句非常冗长，很难维护，甚至更难调试。它们使我们的代码混乱不堪，而且在我看来，它们的语法很奇怪，令人不舒服。在添加更多的case时，我们必须手动添加每个case和break语句，这很容易出错。\n<details>\n<summary>英语原文</summary>\nWe normally use switch statements to avoid large if else if statements. However, switch statements are very verbose, hard to maintain and even harder to debug. They clutter up our code, and, in my humble opinion, have an odd, uncomfortable syntax. When adding more cases, we have to manually add each case and break statement, which is quite error-prone.\n</details>\n\n让我们看一个switch语句的例子:\n<details>\n<summary>英语原文</summary>\nLet's take a look at an example of a switch statement:\n</details>\n\n```js\nfunction getPokemon(type) {\n  let pokemon;\n  switch (type) {\n    case 'Water':\n      pokemon = 'Squirtle';\n      break;\n    case 'Fire':\n      pokemon = 'Charmander';\n      break;\n    case 'Plant':\n      pokemon = 'Bulbasur';\n      break;\n    case 'Electric':\n      pokemon = 'Pikachu';\n      break;\n    default:\n      pokemon = 'Mew';\n  }\n  return pokemon;\n}\n\nconsole.log(getPokemon('Fire')); // Result: Charmander\n```\n假设我们需要向switch语句添加更多的case。我们需要编写的代码数量是相当大的。我们可能会以复制粘贴代码结束，我们都知道结局如何。\n<details>\n<summary>英语原文</summary>\nImagine that we need to add more case to the switch statement. The amount of code that we would have to write is considerable. We would probably end up copy-pasting code, and we all know how that ends.\n</details>\n\n那么，如何避免使用switch语句？ 通过使用对象文字。 对象文字很简单，易于编写，读取和维护。 我们都习惯于在JavaScript中处理对象，并且语法比switch语句新鲜得多。 这是一个例子：\n<details>\n<summary>英语原文</summary>\nSo, how do we avoid switch statements? By using an object literal. Object literals are simple, easy to write, read and maintain. We are all used to handling objects in JavaScript, and the syntax is a lot fresher than that of the switch statement. Here is an example: \n</details>\n\n```js\nconst pokemon = {\n  Water: 'Squirtle',\n  Fire: 'Charmander',\n  Plant: 'Bulbasur',\n  Electric: 'Pikachu'\n};\n\nfunction getPokemon(type) {\n  return pokemon[type] || 'Mew';\n}\nconsole.log(getPokemon('Fire')); // Result: Charmander\n\n// If the type isn't found in the pokemon object, the function will return the default value 'Mew'\nconsole.log(getPokemon('unknown')); // Result: Mew\n```\n如您所见，我们可以使用||操作符添加一个默认值。如果在pokemon对象中没有找到指定的type类型，getPokemon函数将返回“Mew”作为默认值。\n>注意：你可能已经注意到，我们在函数外部声明了pokemon对象，而不是在函数内部。这样做是为了防止每次执行函数时都创建它。\n<details>\n<summary>英语原文</summary>\nAs you can see, we can add a default value by using the || operator. If the type isn't found in the pokemon object, the getPokemon function will return 'Mew' as a default value.\n\n<blockquote>Note: As you will probably have noticed, we declare the pokemon object outside the function, instead of inside. We do this to prevent it from being created each time we execute the function.</blockquote>\n</details>\n\n我们也可以使用Map来达到同样的效果。映射是键值对的集合，就像对象一样。不同之处在于Map允许任何类型的键，而对象只允许字符串作为键。此外，Map还有一系列有趣的属性和方法。你可以在[这里阅读](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)更多关于Map结构的信息。\n<details>\n<summary>英语原文</summary>\nWe can also use a map to achieve the same result. A map is a collection of key value pairs, just like an object. The difference is that map allows keys of any type, while objects onlu allow strings as keys. Also, map has an interesting series of properties and methods. You can read more about the map structure <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">here</a>.\n</details>\n\n以下是如何使用Map：\n<details>\n<summary>英语原文</summary>\nHere's how to use map:\n</details>\n\n```js\nconst pokemon = new Map([\n  ['Water', 'Squirtle'],\n  ['Fire', 'Charmander'],\n  ['Plant', 'Bulbasur'],\n  ['Electric', 'Pikachu']\n]);\n\nfunction getPokemon(type) {\n  return pokemon.get(type) || 'Mew';\n}\n\nconsole.log(getPokemon('Fire')); // Result: Charmander\nconsole.log(getPokemon('unknown')); // Result: Mew\n```\n正如您所看到的，在用对象文字或映射替换switch语句时，我们的代码看起来要干净得多，也简单得多。\n<details>\n<summary>英语原文</summary>\nAs you can see, our code looks a lot cleaner and straightforward when replacing switch statements with an object literal or map.\n</details>\n\n## 使你的条件句具有描述性(Make your conditionals descriptive)\n\n在编写代码时，条件语句是绝对必要的。 但是，它们很快就会失控，最终变得难以理解。这导致要么不得不写注释解释语句的作用，要么不得不花费宝贵的时间追溯我们自己的代码来理解发生了什么。这很糟糕。\n<details>\n<summary>英语原文</summary>\nConditional statements are an absolute necessity when writting code. However, they can quickly get out of hand, and end up being impossible to understand. This leads to either having to write comments explaining what the statement does, or having to spend valuable time tracing back our own code to understand what's going on. This is bad.\n</details>\n\n看一下以下语句：\n<details>\n<summary>英语原文</summary>\nTake a look at the following statement:\n</details>\n\n```js\nfunction checkGameStatus() {\n  if (\n    remaining === 0 ||\n    (remaining === 1 && remainingPlayers === 1) ||\n    remainingPlayers === 0\n  ){\n    quiteGame();\n  }\n}\n```\n如果只查看前一个函数中If语句中的代码，就很难理解发生了什么。我们的代码不清晰，不清晰的代码只会导致技术债务、bug和严重的问题。\n<details>\n<summary>英语原文</summary>\nIf we only look at the code inside the if statement in the previous function, it's difficult to understand what's going on. Our code isn't clear, and unclear code leads only to technical debt, bugs, and significant headaches.\n</details>\n\n我们如何改善我们的条件？把它提取成一个函数。方法如下:\n<details>\n<summary>英语原文</summary>\nHow can we improve our conditional? By extracting it into a function. Here's how:\n</details>\n\n```js\nfunction isGameLost() {\n  return (\n    remaining === 0 ||\n    (remaining === 1 && remainingPlayers === 1) ||\n    remainingPlayers === 0\n  );\n}\n\n// Our function is now much easier to understand:\nfunction checkGameStatus() {\n  if (isGameLost()) {\n    quitGame();\n  }\n}\n```\n通过将条件提取到具有描述性名称的函数isGameLost，我们的checkGameStatus函数现在可以一目了然了。 为什么？ 因为我们的代码具有参考价值，所以它告诉我们正在发生什么，这就是我们应该一直努力的目标。\n<details>\n<summary>英语原文</summary>\nBy extracting the conditional into a function with a descriptive name: isGameLost(), our checkGameStatus function is now understandable at a glance. Why? Because our code is informative, it tells us what is going on, which is what we should always strive for.\n</details>\n\n## 使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)\n\n嵌套if语句是我们在代码中可能遇到的最糟糕的事情之一。 我已经看到了嵌套的ifs深度为10层……相信我，当我告诉您能够完全掌握该代码中发生的事情绝对是一场噩梦。 这是一个嵌套的if语句的示例（虽然只有三层，但我不是怪物）：\n<details>\n<summary>英语原文</summary>\nNested if statements are one of the worst things we can encounter in code. I've seen nested ifs 10 levels deep... Belive me when I tell you that it was an absolute nightmare to be able to fully grasp what was going on in that code. Here's an example of a nested is statement(only three levels deep though, I'm not a monster):\n</details>\n\n```js\nfunction writeTweet() {\n  const tweet = writeSomething();\n\n  if (isLoggedIn()) {\n    if (tweet) {\n      if (isTweetDoubleChecked()) {\n        tweetIt();\n      } else {\n        throw new Error('Dont publish without double checking your tweet');\n      }\n    } else {\n      throw new Error(\"Your tweet is empty, can't publish it\");\n    }\n  } else {\n    throw new Error('You need to log in before tweeting');\n  }\n}\n```\n您可能需要花费几分钟，然后上下阅读才能遵循该功能的流程。 嵌套的if语句难以阅读和理解。 那么，如何摆脱讨厌的嵌套if语句呢？ 通过反转逻辑并使用我们所谓的保护子句。\n>在计算机编程中，保护是一个布尔表达式，如果程序要在有问题的分支中继续执行，则该表达式的值必须为true。——维基百科\n<details>\n<summary>英语原文</summary>\nYou probably have to take a couple of minutes, and read up and down to follow the flow of the function. Nested if statements are hard to both read and understand. So, how do we get rid of the nasty nested if statement? By reversing the logic and using what we call a guard clause.\n<blockquote>In computer programming, a guard is a boolean expression that must evaluate to true if the program execution is to continue in the branch in question.-Wikipedia</blockquote>\n</details>\n\n通过反转函数的逻辑，并在函数开始时放置导致提前退出的条件，它们将充当警卫，并且只允许在满足所有条件的情况下继续执行函数。这样，我们可以避免else语句。下面是如何重构前面的函数以使用保护子句：\n<details>\n<summary>英语原文</summary>\nBy reversing the logic of our function, and placing the conditions that cause an early exit in the beginning of the function, the will act as guards, and only allow our function to continue executing if all the conditions are met. This way, we can avoid else statements. Here's how to refactor our previous function to use guard clauses:\n</details>\n\n```js\nfunction writeTweet() {\n  const tweet = writeSomething();\n\n  if (!isLoggedIn()) {\n    throw new Error('You need to log in before tweeting');\n  }\n  if (!tweet) {\n    throw new Error(\"Your tweet is empty, can't publish it\");\n  }\n  if (!isTweetDoubleChecked()) {\n    throw new Error('Dont publish without double checking your tweet');\n  }\n\n  tweetIt();\n}\n```\n正如您所看到的，代码要干净得多，也更容易理解。我们可以通过简单地向下读来了解函数的功能，遵循函数的自然流程，不像以前，我们必须上下阅读。\n<details>\n<summary>英语原文</summary>\nAs you can see, the code is a lot cleaner and easier to understand. We can see What the function does simply by reading down, following the natural flow of the function, unlike before, Where we had to read up and down.\n</details>\n\n## 避免代码重复(Avoid code duplication)\n\n复制代码总是以失败告终。这会导致这样的情况:“我在这里修复了这个bug，但是忘记在那里做了”或者“我需要做一个改变/添加一个新特性，并且必须在五个不同的地方做它”。\n\n正如[DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself)(不要重复)原则所说:\n\n**在一个系统中，每一个知识或逻辑必须有一个单一的、明确的表示**\n\n因此，代码越少越好:它为我们节省了时间和精力，更容易维护，并减少了出现bug的机会。\n\n那么，我们如何消除重复代码呢？答案并不总是简单的，但是提取函数/变量的逻辑通常很好。让我们看看下面的代码，我在重构应用程序时遇到了这些代码:\n<details>\n<summary>英语原文</summary>\nDuplicating code always ends badly. It leads to situations such as:\"I fixed this bug here, but forgot to do it there\" or \"I need to make a change/add a new feature, and how to do it in five different places\".\n\nJust as the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\">DRY</a>(don't repeat yourself) principle states:\n\n<b>Every piece of knowledge or logic must have a single, unambiguous representation within a system.</b>\n\nTherefore, having less code is good: It saves us both time and effort, is easier to maintain, and reduces the chances of bugs appeariing.\n\nSo, how do we get rid of duplicated code? The answer is not always simple, but extracting logic to function/variables usually works just fine. Let's take a look at the following code, which I ran across when refactoring an application:\n</details>\n\n```js\nfunction getJavascriptNews() {\n  const allNews = getNewsFromWeb();\n  const news = [];\n\n  for (let i = allNews.length - 1; i >= 0; i--){\n    if (allNews[i].type === \"javascript\") {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n\nfunction getRustNews() {\n  const allNews = getNewsFromWeb();\n  const news = [];\n\n  for (let i = allNews.length - 1; i >= 0; i--){\n    if (allNews[i].type === \"rust\") {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n\nfunction getGolangNews() {\n  const news = [];\n  const allNews = getNewsFromWeb();\n\n  for (let i = allNews.length - 1; i >= 0; i--) {\n    if (allNews[i].type === 'golang') {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n```\n您可能已经注意到，for循环在两个函数中是完全相同的，除了一个小细节:我们需要的新闻类型，即JavaScript或Rust新闻。为了避免这种重复，我们可以将for循环提取到一个函数中，然后从getJavascriptNews、getRustNews和getGolangNews函数调用这个函数。方法如下:\n<details>\n<summary>英语原文</summary>\nYou'll probably have noticed that the for loop is exactly the same in both functions, except for one little detail: the type of news that we want, which is either JavaScript or Rust news. To avoid this duplication, We can extract the for loop into a function, Which we when call from the getJavascriptNews, getRustNews and getGolangNews functions. Here's how:\n</details>\n\n```js\nfunction getJavascriptNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'javascript');\n}\n\nfunction getRustNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'rust');\n}\n\nfunction getGolangNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'golang');\n}\n\nfunction getNewsContent(newsList, type) {\n  const news = [];\n  for (let i = newsList.length - 1; i >= 0; i--) {\n    if (newsList[i].type === type) {\n      news.push(newsList[i].content);\n    }\n  }\n  return news;\n}\n```\n在将for循环提取到getNewsContent函数后，我们的getJavascriptNews、getRustNews和getGolangNews函数变成了简单、清晰的一行程序。\n<details>\n<summary>英语原文</summary>\nAfter extracting the for loop into the getNewsContent function, our getJavaScriptNews, getRustNews, getGolangNews functions have turned into simple, clear one liners.\n</details>\n\n### 进一步重构(Further refactoring)\n\n但是，您是否意识到，除了传递给getNewsContent函数的类型字符串以外，这两个函数完全相同吗？ 这是我们重构代码时通常发生的事情。 通常，一个更改会导致另一个更改，依此类推，直到重构的代码最终变为原始代码大小的一半为止。 让您的代码告诉您它需要什么：\n>进一步重构我们的getJavascriptNews，getRustNews和getGolangNews函数去哪里了？ 我们用getNews函数代替了它们，该函数接收新闻的类型作为参数。 这样，无论我们添加多少种新闻，我们都始终使用相同的功能。 这称为抽象，它使我们能够重用函数，因此非常有用。 抽象是我在代码中最常使用的技术之一。\n<details>\n<summary>英语原文</summary>\nHowever, have you realized that, once again, both functions are exactly the same except for the type string that we pass into the getNewsContent function? This is something that usually happens when we refactor our code. More often than not, one change leads to another change, and so on, until our refactored code ends up being half the size of the original. Let your code tell you what it needs:\n<blockquote>\nFurther refactoring, where did our getJavaScriptNews, getRustNews and getGolangNews functions go? We substituted them for a getNews function, which receives the type of news as an argument. This way, no matter how many more types of news we add, we always use the same function. This is called abstraction, and allows us to reuse functions, thus being incredibly useful. Abstraction is one of the techniques I use most frequently in my code.\n</blockquote>\n</details>\n\n### 使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)\n\n我发誓这是最后一次重构。\n\nFor循环的可读性不高。 通过引入ES6阵列函数，我们可以避免95％的时间使用它们。 在我们的例子中，我们可以结合使用Array.filter和Array.map来替换原始循环：\n* 使用Array.filter，我们仅返回其类型等于作为参数传递的类型的元素。\n* 使用Array.map，我们仅返回item对象的content属性，而不是整个item。\n\n恭喜，经过三个简单的重构，我们最初的三个功能已减少为两个，它们更易于理解和维护。 另外，通过使用抽象，我们使getNews函数可重用。\n<details>\n<summary>英语原文</summary>\nThis is the last refactorinig, I swear.\n\nFor loops aren't precisely readable. With the introduction of ES6 Array functions, We can avoid using them 95% of the time. In our case, we can use Array.filter combined with Array.map to substitute the original loop:\n<ul>\n  <li>With Array.filter we return only the elements whose type equals the type passed as an argument.</li>\n  <li>With Array.map, we return only the content property of the item object, instead of the whole item.</li>\n</ul>\nCongratulations, after three simple refactorings, our initial three functions have been reduced to two, which are much easier to understand and maintain. Also, by using abstraction, we made the getNews function reusable.\n</details>\n\n## 函数应该只做一件事(function should only do one thing)\n\n函数应该只做一件事，而且只做一件事。做不止一件事的函数是万恶之源，也是我们在代码中遇到的最糟糕的事情之一(与嵌套的if一起)。它们很杂乱，使我们的代码难以理解。下面是一个来自实际应用程序的复杂函数示例：\n>注意：由于此示例不需要事件侦听器的处理程序，因此我选择将其删除。\n\n<details>\n<summary>英语原文</summary>\nfunctions should only do one thing, and one thing only. functions that do more than one thing are the root of all evil, and one of the worst things we can encounter in code (together with nested ifs). They are messy, and make our code hard to understand. Here's an example of a complex function from a real application:\n<blockquote>\nNote: Since the handlers for the event listeners were not needed for this example, I chose to remove them.\n</blockquote>\n</details>\n\n如您所见，它令人困惑，并且很难理解其中发生了什么。 如果出现任何错误，将很难找到并修复它们。 我们如何改善我们的startProgram功能？ 通过将通用逻辑提取到函数中。 方法如下：\n<details>\n<summary>英语原文</summary>\nAs you can see, it's confusing, and hard to understand what's going on in there. If any bugs come up, it will be quite difficult to find and fix them. How can we improve our startProgram function? By extracting common logic into functions. Here's how:\n</details>\n\n让我们看一下对startProgram函数所做的更改：\n\n首先，我们通过使用guard子句摆脱了if else语句。 然后，我们将启动数据库所需的逻辑提取到initDatabase函数中，并将事件侦听器添加到setListeners函数中。\n\n打印雇员列表的逻辑稍微复杂一些，因此我们创建了三个函数：printEmployeeList，formatEmployeeList和getEmployeeList。\n\ngetEmployeeList负责向employeeList.json发出GET请求，并以json格式返回响应。\n\n然后由printEmployeeList函数调用，该函数获取雇员列表，并将其传递给formatEmployeeList函数，该函数格式化并返回它。 然后，打印列表。\n\n如您所见，每个函数仅负责做一件事。\n\n我们仍然可以对该函数进行一些更改，老实说，应用程序要求将视图与控制器分离，但总的来说，我们的startProgram函数现在提供了更多的信息，理解它的功能绝对没有困难。如果几个月后我们必须回到这段代码，我们就不会有任何问题。\n\n<details>\n<summary>英语原文</summary>\nLet's go through the changes made to the startProgram function:\n\nFirst, we got rid of the if else statement by using a guard clause. Then, we extracted the logic needed to start the database into an initDatabase function and the logic to add event listeners to a setListeners function.\n\nThe logic for printing the employee list is slightly more complex, so we created three functions: printEmployeeList, formatEmployeeList, and getEmployeeList.\n\nThe getEmployeeList is responsible for making a GET request to employeeList.json, and returning the response in json format.\n\nIt is then called by the printEmployeeList function, which takes the list of employees, and passes it to the formatEmployeeList function, which formats and returns it. Then, the list is printed.\n\nAs you can see, every function is responsible for doing only one thing.\n\nWe could still make a few more changes to the function, and honestly, the application is begging for the separation of the view from the controller, but on the whole, out startProgram function is now more informative, and there is absolutely no difficulty in understanding what it does. We would have no problem at all if we had to come back to this code after a couple of months.\n</details>\n\n\n## 总结(Conclusion)\n\n程序员是唯一负责编写优质代码的人。 我们都应该养成从第一行开始编写良好代码的习惯。 编写干净的代码并不复杂，这将对您和您的同事都有所帮助。\n\n通过应用本教程中显示的5种简单技术，您的代码质量将大大提高，生产率也将得到提高。\n\n如有任何疑问，请随时提出。 感谢您的阅读。\n<details>\n<summary>英语原文</summary>\nProgrammers are the only ones responsible for writting good, quality code. We should all make it a habit to write good code from the very fitst line. Writting clean code isn't complicated, and doing so will help both you and your colleagues.\n\nBy applying the 5 simple techniques shown in this tutorial, your code quality should improve considerably, and so will your productivity.\n\nIf you have any questions, don't hesuitate to ask. Thank you for reading.\n</details>","source":"_posts/2019-10-12-编写更好的代码的5个技巧.md","raw":"---\ntitle: 编写更好的代码的5个技巧\ndate: 2019-10-12\ntoc: false\ncomments: false\ntags:\n    - 代码重构\n    - 转载\ncategories:\n    - 重构\n---\n\n错误的代码有效。 我们都知道这一点。 开发人员多年来一直在编写代码，而没有考虑过自己是否做对了。 这是可以理解的，不是吗？ 毕竟，我们已经必须应对与行业保持同步的压力以及我们工作的需求……\n<details>\n<summary>英语原文</summary>\n<p>Bad code works. We all know this. Developers have been writting code for years without giving a single thought to whether they'er doing it right or not. It's understandable, isn't it? After all, We already have to deal with the stress of keeping up with the industry and the demands or our job...</p>\n</details>\n<!--more-->\n\n答案是否定的。编写糟糕的代码是要付出代价的。您是否曾经遇到过这样的问题：几周之后，您无法理解自己的代码，不得不花费数小时甚至数天的时间来弄清楚到底发生了什么？\n<details>\n<summary>英语原文</summary>\nThe answer is no. Writting bad codes comes at a price. Have you ever faced the issue of not understanding your own code after a couple of weeks, and having to spend hours, or even days figuring out what was going on?\n</details>\n\n解决此（极端）常见问题的方法是使您的代码尽可能清晰明了。 我甚至会说，即使是非技术人员也应该理解您的代码。 现在该丢下我们的借口，提高代码质量了。\n<details>\n<summary>英语原文</summary>\nThe solution to this (extremely) common problem is to make your code as clear and informative as possible. I will go as far as to say that your code should be understood even by a non-technical person. It's time to drop our excuses, and improve the quality of your code.\n</details>\n\n编写干净的代码并不那么复杂。 本教程将通过实际示例向您展示5种改善代码的简单技术：\n1.摆脱switch语句\n2.使你的条件句具有描述性\n3.使用保护子句避免嵌套if语句\n4.避免代码重复\n5.函数应该只做一件事\n\n<details>\n<summary>英语原文</summary>\nWritting clean code isn't that complicated. This tutorial will show you 5 simple techniques to improve your code, with practical examples:\n1.Get rid of switch statements\n2.Make your conditionals descriptive\n3.Use guard clauses to avoid nested if statements\n4.Avoid code duplication\n5.functions should only do one thing\n</details>\n\n## 摆脱switch语句(Get rid of switch statements)\n\n我们通常使用switch语句来避免使用大的if else if语句。但是，switch语句非常冗长，很难维护，甚至更难调试。它们使我们的代码混乱不堪，而且在我看来，它们的语法很奇怪，令人不舒服。在添加更多的case时，我们必须手动添加每个case和break语句，这很容易出错。\n<details>\n<summary>英语原文</summary>\nWe normally use switch statements to avoid large if else if statements. However, switch statements are very verbose, hard to maintain and even harder to debug. They clutter up our code, and, in my humble opinion, have an odd, uncomfortable syntax. When adding more cases, we have to manually add each case and break statement, which is quite error-prone.\n</details>\n\n让我们看一个switch语句的例子:\n<details>\n<summary>英语原文</summary>\nLet's take a look at an example of a switch statement:\n</details>\n\n```js\nfunction getPokemon(type) {\n  let pokemon;\n  switch (type) {\n    case 'Water':\n      pokemon = 'Squirtle';\n      break;\n    case 'Fire':\n      pokemon = 'Charmander';\n      break;\n    case 'Plant':\n      pokemon = 'Bulbasur';\n      break;\n    case 'Electric':\n      pokemon = 'Pikachu';\n      break;\n    default:\n      pokemon = 'Mew';\n  }\n  return pokemon;\n}\n\nconsole.log(getPokemon('Fire')); // Result: Charmander\n```\n假设我们需要向switch语句添加更多的case。我们需要编写的代码数量是相当大的。我们可能会以复制粘贴代码结束，我们都知道结局如何。\n<details>\n<summary>英语原文</summary>\nImagine that we need to add more case to the switch statement. The amount of code that we would have to write is considerable. We would probably end up copy-pasting code, and we all know how that ends.\n</details>\n\n那么，如何避免使用switch语句？ 通过使用对象文字。 对象文字很简单，易于编写，读取和维护。 我们都习惯于在JavaScript中处理对象，并且语法比switch语句新鲜得多。 这是一个例子：\n<details>\n<summary>英语原文</summary>\nSo, how do we avoid switch statements? By using an object literal. Object literals are simple, easy to write, read and maintain. We are all used to handling objects in JavaScript, and the syntax is a lot fresher than that of the switch statement. Here is an example: \n</details>\n\n```js\nconst pokemon = {\n  Water: 'Squirtle',\n  Fire: 'Charmander',\n  Plant: 'Bulbasur',\n  Electric: 'Pikachu'\n};\n\nfunction getPokemon(type) {\n  return pokemon[type] || 'Mew';\n}\nconsole.log(getPokemon('Fire')); // Result: Charmander\n\n// If the type isn't found in the pokemon object, the function will return the default value 'Mew'\nconsole.log(getPokemon('unknown')); // Result: Mew\n```\n如您所见，我们可以使用||操作符添加一个默认值。如果在pokemon对象中没有找到指定的type类型，getPokemon函数将返回“Mew”作为默认值。\n>注意：你可能已经注意到，我们在函数外部声明了pokemon对象，而不是在函数内部。这样做是为了防止每次执行函数时都创建它。\n<details>\n<summary>英语原文</summary>\nAs you can see, we can add a default value by using the || operator. If the type isn't found in the pokemon object, the getPokemon function will return 'Mew' as a default value.\n\n<blockquote>Note: As you will probably have noticed, we declare the pokemon object outside the function, instead of inside. We do this to prevent it from being created each time we execute the function.</blockquote>\n</details>\n\n我们也可以使用Map来达到同样的效果。映射是键值对的集合，就像对象一样。不同之处在于Map允许任何类型的键，而对象只允许字符串作为键。此外，Map还有一系列有趣的属性和方法。你可以在[这里阅读](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)更多关于Map结构的信息。\n<details>\n<summary>英语原文</summary>\nWe can also use a map to achieve the same result. A map is a collection of key value pairs, just like an object. The difference is that map allows keys of any type, while objects onlu allow strings as keys. Also, map has an interesting series of properties and methods. You can read more about the map structure <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">here</a>.\n</details>\n\n以下是如何使用Map：\n<details>\n<summary>英语原文</summary>\nHere's how to use map:\n</details>\n\n```js\nconst pokemon = new Map([\n  ['Water', 'Squirtle'],\n  ['Fire', 'Charmander'],\n  ['Plant', 'Bulbasur'],\n  ['Electric', 'Pikachu']\n]);\n\nfunction getPokemon(type) {\n  return pokemon.get(type) || 'Mew';\n}\n\nconsole.log(getPokemon('Fire')); // Result: Charmander\nconsole.log(getPokemon('unknown')); // Result: Mew\n```\n正如您所看到的，在用对象文字或映射替换switch语句时，我们的代码看起来要干净得多，也简单得多。\n<details>\n<summary>英语原文</summary>\nAs you can see, our code looks a lot cleaner and straightforward when replacing switch statements with an object literal or map.\n</details>\n\n## 使你的条件句具有描述性(Make your conditionals descriptive)\n\n在编写代码时，条件语句是绝对必要的。 但是，它们很快就会失控，最终变得难以理解。这导致要么不得不写注释解释语句的作用，要么不得不花费宝贵的时间追溯我们自己的代码来理解发生了什么。这很糟糕。\n<details>\n<summary>英语原文</summary>\nConditional statements are an absolute necessity when writting code. However, they can quickly get out of hand, and end up being impossible to understand. This leads to either having to write comments explaining what the statement does, or having to spend valuable time tracing back our own code to understand what's going on. This is bad.\n</details>\n\n看一下以下语句：\n<details>\n<summary>英语原文</summary>\nTake a look at the following statement:\n</details>\n\n```js\nfunction checkGameStatus() {\n  if (\n    remaining === 0 ||\n    (remaining === 1 && remainingPlayers === 1) ||\n    remainingPlayers === 0\n  ){\n    quiteGame();\n  }\n}\n```\n如果只查看前一个函数中If语句中的代码，就很难理解发生了什么。我们的代码不清晰，不清晰的代码只会导致技术债务、bug和严重的问题。\n<details>\n<summary>英语原文</summary>\nIf we only look at the code inside the if statement in the previous function, it's difficult to understand what's going on. Our code isn't clear, and unclear code leads only to technical debt, bugs, and significant headaches.\n</details>\n\n我们如何改善我们的条件？把它提取成一个函数。方法如下:\n<details>\n<summary>英语原文</summary>\nHow can we improve our conditional? By extracting it into a function. Here's how:\n</details>\n\n```js\nfunction isGameLost() {\n  return (\n    remaining === 0 ||\n    (remaining === 1 && remainingPlayers === 1) ||\n    remainingPlayers === 0\n  );\n}\n\n// Our function is now much easier to understand:\nfunction checkGameStatus() {\n  if (isGameLost()) {\n    quitGame();\n  }\n}\n```\n通过将条件提取到具有描述性名称的函数isGameLost，我们的checkGameStatus函数现在可以一目了然了。 为什么？ 因为我们的代码具有参考价值，所以它告诉我们正在发生什么，这就是我们应该一直努力的目标。\n<details>\n<summary>英语原文</summary>\nBy extracting the conditional into a function with a descriptive name: isGameLost(), our checkGameStatus function is now understandable at a glance. Why? Because our code is informative, it tells us what is going on, which is what we should always strive for.\n</details>\n\n## 使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)\n\n嵌套if语句是我们在代码中可能遇到的最糟糕的事情之一。 我已经看到了嵌套的ifs深度为10层……相信我，当我告诉您能够完全掌握该代码中发生的事情绝对是一场噩梦。 这是一个嵌套的if语句的示例（虽然只有三层，但我不是怪物）：\n<details>\n<summary>英语原文</summary>\nNested if statements are one of the worst things we can encounter in code. I've seen nested ifs 10 levels deep... Belive me when I tell you that it was an absolute nightmare to be able to fully grasp what was going on in that code. Here's an example of a nested is statement(only three levels deep though, I'm not a monster):\n</details>\n\n```js\nfunction writeTweet() {\n  const tweet = writeSomething();\n\n  if (isLoggedIn()) {\n    if (tweet) {\n      if (isTweetDoubleChecked()) {\n        tweetIt();\n      } else {\n        throw new Error('Dont publish without double checking your tweet');\n      }\n    } else {\n      throw new Error(\"Your tweet is empty, can't publish it\");\n    }\n  } else {\n    throw new Error('You need to log in before tweeting');\n  }\n}\n```\n您可能需要花费几分钟，然后上下阅读才能遵循该功能的流程。 嵌套的if语句难以阅读和理解。 那么，如何摆脱讨厌的嵌套if语句呢？ 通过反转逻辑并使用我们所谓的保护子句。\n>在计算机编程中，保护是一个布尔表达式，如果程序要在有问题的分支中继续执行，则该表达式的值必须为true。——维基百科\n<details>\n<summary>英语原文</summary>\nYou probably have to take a couple of minutes, and read up and down to follow the flow of the function. Nested if statements are hard to both read and understand. So, how do we get rid of the nasty nested if statement? By reversing the logic and using what we call a guard clause.\n<blockquote>In computer programming, a guard is a boolean expression that must evaluate to true if the program execution is to continue in the branch in question.-Wikipedia</blockquote>\n</details>\n\n通过反转函数的逻辑，并在函数开始时放置导致提前退出的条件，它们将充当警卫，并且只允许在满足所有条件的情况下继续执行函数。这样，我们可以避免else语句。下面是如何重构前面的函数以使用保护子句：\n<details>\n<summary>英语原文</summary>\nBy reversing the logic of our function, and placing the conditions that cause an early exit in the beginning of the function, the will act as guards, and only allow our function to continue executing if all the conditions are met. This way, we can avoid else statements. Here's how to refactor our previous function to use guard clauses:\n</details>\n\n```js\nfunction writeTweet() {\n  const tweet = writeSomething();\n\n  if (!isLoggedIn()) {\n    throw new Error('You need to log in before tweeting');\n  }\n  if (!tweet) {\n    throw new Error(\"Your tweet is empty, can't publish it\");\n  }\n  if (!isTweetDoubleChecked()) {\n    throw new Error('Dont publish without double checking your tweet');\n  }\n\n  tweetIt();\n}\n```\n正如您所看到的，代码要干净得多，也更容易理解。我们可以通过简单地向下读来了解函数的功能，遵循函数的自然流程，不像以前，我们必须上下阅读。\n<details>\n<summary>英语原文</summary>\nAs you can see, the code is a lot cleaner and easier to understand. We can see What the function does simply by reading down, following the natural flow of the function, unlike before, Where we had to read up and down.\n</details>\n\n## 避免代码重复(Avoid code duplication)\n\n复制代码总是以失败告终。这会导致这样的情况:“我在这里修复了这个bug，但是忘记在那里做了”或者“我需要做一个改变/添加一个新特性，并且必须在五个不同的地方做它”。\n\n正如[DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself)(不要重复)原则所说:\n\n**在一个系统中，每一个知识或逻辑必须有一个单一的、明确的表示**\n\n因此，代码越少越好:它为我们节省了时间和精力，更容易维护，并减少了出现bug的机会。\n\n那么，我们如何消除重复代码呢？答案并不总是简单的，但是提取函数/变量的逻辑通常很好。让我们看看下面的代码，我在重构应用程序时遇到了这些代码:\n<details>\n<summary>英语原文</summary>\nDuplicating code always ends badly. It leads to situations such as:\"I fixed this bug here, but forgot to do it there\" or \"I need to make a change/add a new feature, and how to do it in five different places\".\n\nJust as the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\">DRY</a>(don't repeat yourself) principle states:\n\n<b>Every piece of knowledge or logic must have a single, unambiguous representation within a system.</b>\n\nTherefore, having less code is good: It saves us both time and effort, is easier to maintain, and reduces the chances of bugs appeariing.\n\nSo, how do we get rid of duplicated code? The answer is not always simple, but extracting logic to function/variables usually works just fine. Let's take a look at the following code, which I ran across when refactoring an application:\n</details>\n\n```js\nfunction getJavascriptNews() {\n  const allNews = getNewsFromWeb();\n  const news = [];\n\n  for (let i = allNews.length - 1; i >= 0; i--){\n    if (allNews[i].type === \"javascript\") {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n\nfunction getRustNews() {\n  const allNews = getNewsFromWeb();\n  const news = [];\n\n  for (let i = allNews.length - 1; i >= 0; i--){\n    if (allNews[i].type === \"rust\") {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n\nfunction getGolangNews() {\n  const news = [];\n  const allNews = getNewsFromWeb();\n\n  for (let i = allNews.length - 1; i >= 0; i--) {\n    if (allNews[i].type === 'golang') {\n      news.push(allNews[i]);\n    }\n  }\n\n  return news;\n}\n```\n您可能已经注意到，for循环在两个函数中是完全相同的，除了一个小细节:我们需要的新闻类型，即JavaScript或Rust新闻。为了避免这种重复，我们可以将for循环提取到一个函数中，然后从getJavascriptNews、getRustNews和getGolangNews函数调用这个函数。方法如下:\n<details>\n<summary>英语原文</summary>\nYou'll probably have noticed that the for loop is exactly the same in both functions, except for one little detail: the type of news that we want, which is either JavaScript or Rust news. To avoid this duplication, We can extract the for loop into a function, Which we when call from the getJavascriptNews, getRustNews and getGolangNews functions. Here's how:\n</details>\n\n```js\nfunction getJavascriptNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'javascript');\n}\n\nfunction getRustNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'rust');\n}\n\nfunction getGolangNews() {\n  const allNews = getNewsFromWeb();\n  return getNewsContent(allNews, 'golang');\n}\n\nfunction getNewsContent(newsList, type) {\n  const news = [];\n  for (let i = newsList.length - 1; i >= 0; i--) {\n    if (newsList[i].type === type) {\n      news.push(newsList[i].content);\n    }\n  }\n  return news;\n}\n```\n在将for循环提取到getNewsContent函数后，我们的getJavascriptNews、getRustNews和getGolangNews函数变成了简单、清晰的一行程序。\n<details>\n<summary>英语原文</summary>\nAfter extracting the for loop into the getNewsContent function, our getJavaScriptNews, getRustNews, getGolangNews functions have turned into simple, clear one liners.\n</details>\n\n### 进一步重构(Further refactoring)\n\n但是，您是否意识到，除了传递给getNewsContent函数的类型字符串以外，这两个函数完全相同吗？ 这是我们重构代码时通常发生的事情。 通常，一个更改会导致另一个更改，依此类推，直到重构的代码最终变为原始代码大小的一半为止。 让您的代码告诉您它需要什么：\n>进一步重构我们的getJavascriptNews，getRustNews和getGolangNews函数去哪里了？ 我们用getNews函数代替了它们，该函数接收新闻的类型作为参数。 这样，无论我们添加多少种新闻，我们都始终使用相同的功能。 这称为抽象，它使我们能够重用函数，因此非常有用。 抽象是我在代码中最常使用的技术之一。\n<details>\n<summary>英语原文</summary>\nHowever, have you realized that, once again, both functions are exactly the same except for the type string that we pass into the getNewsContent function? This is something that usually happens when we refactor our code. More often than not, one change leads to another change, and so on, until our refactored code ends up being half the size of the original. Let your code tell you what it needs:\n<blockquote>\nFurther refactoring, where did our getJavaScriptNews, getRustNews and getGolangNews functions go? We substituted them for a getNews function, which receives the type of news as an argument. This way, no matter how many more types of news we add, we always use the same function. This is called abstraction, and allows us to reuse functions, thus being incredibly useful. Abstraction is one of the techniques I use most frequently in my code.\n</blockquote>\n</details>\n\n### 使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)\n\n我发誓这是最后一次重构。\n\nFor循环的可读性不高。 通过引入ES6阵列函数，我们可以避免95％的时间使用它们。 在我们的例子中，我们可以结合使用Array.filter和Array.map来替换原始循环：\n* 使用Array.filter，我们仅返回其类型等于作为参数传递的类型的元素。\n* 使用Array.map，我们仅返回item对象的content属性，而不是整个item。\n\n恭喜，经过三个简单的重构，我们最初的三个功能已减少为两个，它们更易于理解和维护。 另外，通过使用抽象，我们使getNews函数可重用。\n<details>\n<summary>英语原文</summary>\nThis is the last refactorinig, I swear.\n\nFor loops aren't precisely readable. With the introduction of ES6 Array functions, We can avoid using them 95% of the time. In our case, we can use Array.filter combined with Array.map to substitute the original loop:\n<ul>\n  <li>With Array.filter we return only the elements whose type equals the type passed as an argument.</li>\n  <li>With Array.map, we return only the content property of the item object, instead of the whole item.</li>\n</ul>\nCongratulations, after three simple refactorings, our initial three functions have been reduced to two, which are much easier to understand and maintain. Also, by using abstraction, we made the getNews function reusable.\n</details>\n\n## 函数应该只做一件事(function should only do one thing)\n\n函数应该只做一件事，而且只做一件事。做不止一件事的函数是万恶之源，也是我们在代码中遇到的最糟糕的事情之一(与嵌套的if一起)。它们很杂乱，使我们的代码难以理解。下面是一个来自实际应用程序的复杂函数示例：\n>注意：由于此示例不需要事件侦听器的处理程序，因此我选择将其删除。\n\n<details>\n<summary>英语原文</summary>\nfunctions should only do one thing, and one thing only. functions that do more than one thing are the root of all evil, and one of the worst things we can encounter in code (together with nested ifs). They are messy, and make our code hard to understand. Here's an example of a complex function from a real application:\n<blockquote>\nNote: Since the handlers for the event listeners were not needed for this example, I chose to remove them.\n</blockquote>\n</details>\n\n如您所见，它令人困惑，并且很难理解其中发生了什么。 如果出现任何错误，将很难找到并修复它们。 我们如何改善我们的startProgram功能？ 通过将通用逻辑提取到函数中。 方法如下：\n<details>\n<summary>英语原文</summary>\nAs you can see, it's confusing, and hard to understand what's going on in there. If any bugs come up, it will be quite difficult to find and fix them. How can we improve our startProgram function? By extracting common logic into functions. Here's how:\n</details>\n\n让我们看一下对startProgram函数所做的更改：\n\n首先，我们通过使用guard子句摆脱了if else语句。 然后，我们将启动数据库所需的逻辑提取到initDatabase函数中，并将事件侦听器添加到setListeners函数中。\n\n打印雇员列表的逻辑稍微复杂一些，因此我们创建了三个函数：printEmployeeList，formatEmployeeList和getEmployeeList。\n\ngetEmployeeList负责向employeeList.json发出GET请求，并以json格式返回响应。\n\n然后由printEmployeeList函数调用，该函数获取雇员列表，并将其传递给formatEmployeeList函数，该函数格式化并返回它。 然后，打印列表。\n\n如您所见，每个函数仅负责做一件事。\n\n我们仍然可以对该函数进行一些更改，老实说，应用程序要求将视图与控制器分离，但总的来说，我们的startProgram函数现在提供了更多的信息，理解它的功能绝对没有困难。如果几个月后我们必须回到这段代码，我们就不会有任何问题。\n\n<details>\n<summary>英语原文</summary>\nLet's go through the changes made to the startProgram function:\n\nFirst, we got rid of the if else statement by using a guard clause. Then, we extracted the logic needed to start the database into an initDatabase function and the logic to add event listeners to a setListeners function.\n\nThe logic for printing the employee list is slightly more complex, so we created three functions: printEmployeeList, formatEmployeeList, and getEmployeeList.\n\nThe getEmployeeList is responsible for making a GET request to employeeList.json, and returning the response in json format.\n\nIt is then called by the printEmployeeList function, which takes the list of employees, and passes it to the formatEmployeeList function, which formats and returns it. Then, the list is printed.\n\nAs you can see, every function is responsible for doing only one thing.\n\nWe could still make a few more changes to the function, and honestly, the application is begging for the separation of the view from the controller, but on the whole, out startProgram function is now more informative, and there is absolutely no difficulty in understanding what it does. We would have no problem at all if we had to come back to this code after a couple of months.\n</details>\n\n\n## 总结(Conclusion)\n\n程序员是唯一负责编写优质代码的人。 我们都应该养成从第一行开始编写良好代码的习惯。 编写干净的代码并不复杂，这将对您和您的同事都有所帮助。\n\n通过应用本教程中显示的5种简单技术，您的代码质量将大大提高，生产率也将得到提高。\n\n如有任何疑问，请随时提出。 感谢您的阅读。\n<details>\n<summary>英语原文</summary>\nProgrammers are the only ones responsible for writting good, quality code. We should all make it a habit to write good code from the very fitst line. Writting clean code isn't complicated, and doing so will help both you and your colleagues.\n\nBy applying the 5 simple techniques shown in this tutorial, your code quality should improve considerably, and so will your productivity.\n\nIf you have any questions, don't hesuitate to ask. Thank you for reading.\n</details>","slug":"2019-10-12-编写更好的代码的5个技巧","published":1,"updated":"2019-10-23T03:27:47.094Z","layout":"post","photos":[],"link":"","_id":"ck31ar4hf005vacqxxq4srt1n","content":"<p>错误的代码有效。 我们都知道这一点。 开发人员多年来一直在编写代码，而没有考虑过自己是否做对了。 这是可以理解的，不是吗？ 毕竟，我们已经必须应对与行业保持同步的压力以及我们工作的需求……</p>\n<details><br><summary>英语原文</summary><br><p>Bad code works. We all know this. Developers have been writting code for years without giving a single thought to whether they’er doing it right or not. It’s understandable, isn’t it? After all, We already have to deal with the stress of keeping up with the industry and the demands or our job…</p><br></details><br><a id=\"more\"></a><br><br>答案是否定的。编写糟糕的代码是要付出代价的。您是否曾经遇到过这样的问题：几周之后，您无法理解自己的代码，不得不花费数小时甚至数天的时间来弄清楚到底发生了什么？<br><details><br><summary>英语原文</summary><br>The answer is no. Writting bad codes comes at a price. Have you ever faced the issue of not understanding your own code after a couple of weeks, and having to spend hours, or even days figuring out what was going on?<br></details>\n\n<p>解决此（极端）常见问题的方法是使您的代码尽可能清晰明了。 我甚至会说，即使是非技术人员也应该理解您的代码。 现在该丢下我们的借口，提高代码质量了。</p>\n<details><br><summary>英语原文</summary><br>The solution to this (extremely) common problem is to make your code as clear and informative as possible. I will go as far as to say that your code should be understood even by a non-technical person. It’s time to drop our excuses, and improve the quality of your code.<br></details>\n\n<p>编写干净的代码并不那么复杂。 本教程将通过实际示例向您展示5种改善代码的简单技术：<br>1.摆脱switch语句<br>2.使你的条件句具有描述性<br>3.使用保护子句避免嵌套if语句<br>4.避免代码重复<br>5.函数应该只做一件事</p>\n<details><br><summary>英语原文</summary><br>Writting clean code isn’t that complicated. This tutorial will show you 5 simple techniques to improve your code, with practical examples:<br>1.Get rid of switch statements<br>2.Make your conditionals descriptive<br>3.Use guard clauses to avoid nested if statements<br>4.Avoid code duplication<br>5.functions should only do one thing<br></details>\n\n<h2 id=\"摆脱switch语句-Get-rid-of-switch-statements\"><a href=\"#摆脱switch语句-Get-rid-of-switch-statements\" class=\"headerlink\" title=\"摆脱switch语句(Get rid of switch statements)\"></a>摆脱switch语句(Get rid of switch statements)</h2><p>我们通常使用switch语句来避免使用大的if else if语句。但是，switch语句非常冗长，很难维护，甚至更难调试。它们使我们的代码混乱不堪，而且在我看来，它们的语法很奇怪，令人不舒服。在添加更多的case时，我们必须手动添加每个case和break语句，这很容易出错。</p>\n<details><br><summary>英语原文</summary><br>We normally use switch statements to avoid large if else if statements. However, switch statements are very verbose, hard to maintain and even harder to debug. They clutter up our code, and, in my humble opinion, have an odd, uncomfortable syntax. When adding more cases, we have to manually add each case and break statement, which is quite error-prone.<br></details>\n\n<p>让我们看一个switch语句的例子:</p>\n<details><br><summary>英语原文</summary><br>Let’s take a look at an example of a switch statement:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pokemon;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Water'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Squirtle'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Fire'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Charmander'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Plant'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Bulbasur'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Electric'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Pikachu'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br></pre></td></tr></table></figure>\n<p>假设我们需要向switch语句添加更多的case。我们需要编写的代码数量是相当大的。我们可能会以复制粘贴代码结束，我们都知道结局如何。</p>\n<details><br><summary>英语原文</summary><br>Imagine that we need to add more case to the switch statement. The amount of code that we would have to write is considerable. We would probably end up copy-pasting code, and we all know how that ends.<br></details>\n\n<p>那么，如何避免使用switch语句？ 通过使用对象文字。 对象文字很简单，易于编写，读取和维护。 我们都习惯于在JavaScript中处理对象，并且语法比switch语句新鲜得多。 这是一个例子：</p>\n<details><br><summary>英语原文</summary><br>So, how do we avoid switch statements? By using an object literal. Object literals are simple, easy to write, read and maintain. We are all used to handling objects in JavaScript, and the syntax is a lot fresher than that of the switch statement. Here is an example:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pokemon = &#123;</span><br><span class=\"line\">  Water: <span class=\"string\">'Squirtle'</span>,</span><br><span class=\"line\">  Fire: <span class=\"string\">'Charmander'</span>,</span><br><span class=\"line\">  Plant: <span class=\"string\">'Bulbasur'</span>,</span><br><span class=\"line\">  Electric: <span class=\"string\">'Pikachu'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon[type] || <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the type isn't found in the pokemon object, the function will return the default value 'Mew'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'unknown'</span>)); <span class=\"comment\">// Result: Mew</span></span><br></pre></td></tr></table></figure>\n<p>如您所见，我们可以使用||操作符添加一个默认值。如果在pokemon对象中没有找到指定的type类型，getPokemon函数将返回“Mew”作为默认值。</p>\n<blockquote>\n<p>注意：你可能已经注意到，我们在函数外部声明了pokemon对象，而不是在函数内部。这样做是为了防止每次执行函数时都创建它。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>As you can see, we can add a default value by using the || operator. If the type isn’t found in the pokemon object, the getPokemon function will return ‘Mew’ as a default value.<br><br><blockquote>Note: As you will probably have noticed, we declare the pokemon object outside the function, instead of inside. We do this to prevent it from being created each time we execute the function.</blockquote><br></details>\n\n<p>我们也可以使用Map来达到同样的效果。映射是键值对的集合，就像对象一样。不同之处在于Map允许任何类型的键，而对象只允许字符串作为键。此外，Map还有一系列有趣的属性和方法。你可以在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">这里阅读</a>更多关于Map结构的信息。</p>\n<details><br><summary>英语原文</summary><br>We can also use a map to achieve the same result. A map is a collection of key value pairs, just like an object. The difference is that map allows keys of any type, while objects onlu allow strings as keys. Also, map has an interesting series of properties and methods. You can read more about the map structure <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">here</a>.<br></details>\n\n<p>以下是如何使用Map：</p>\n<details><br><summary>英语原文</summary><br>Here’s how to use map:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pokemon = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">'Water'</span>, <span class=\"string\">'Squirtle'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Fire'</span>, <span class=\"string\">'Charmander'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Plant'</span>, <span class=\"string\">'Bulbasur'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Electric'</span>, <span class=\"string\">'Pikachu'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon.get(type) || <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'unknown'</span>)); <span class=\"comment\">// Result: Mew</span></span><br></pre></td></tr></table></figure>\n<p>正如您所看到的，在用对象文字或映射替换switch语句时，我们的代码看起来要干净得多，也简单得多。</p>\n<details><br><summary>英语原文</summary><br>As you can see, our code looks a lot cleaner and straightforward when replacing switch statements with an object literal or map.<br></details>\n\n<h2 id=\"使你的条件句具有描述性-Make-your-conditionals-descriptive\"><a href=\"#使你的条件句具有描述性-Make-your-conditionals-descriptive\" class=\"headerlink\" title=\"使你的条件句具有描述性(Make your conditionals descriptive)\"></a>使你的条件句具有描述性(Make your conditionals descriptive)</h2><p>在编写代码时，条件语句是绝对必要的。 但是，它们很快就会失控，最终变得难以理解。这导致要么不得不写注释解释语句的作用，要么不得不花费宝贵的时间追溯我们自己的代码来理解发生了什么。这很糟糕。</p>\n<details><br><summary>英语原文</summary><br>Conditional statements are an absolute necessity when writting code. However, they can quickly get out of hand, and end up being impossible to understand. This leads to either having to write comments explaining what the statement does, or having to spend valuable time tracing back our own code to understand what’s going on. This is bad.<br></details>\n\n<p>看一下以下语句：</p>\n<details><br><summary>英语原文</summary><br>Take a look at the following statement:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkGameStatus</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    remaining === <span class=\"number\">0</span> ||</span><br><span class=\"line\">    (remaining === <span class=\"number\">1</span> &amp;&amp; remainingPlayers === <span class=\"number\">1</span>) ||</span><br><span class=\"line\">    remainingPlayers === <span class=\"number\">0</span></span><br><span class=\"line\">  )&#123;</span><br><span class=\"line\">    quiteGame();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只查看前一个函数中If语句中的代码，就很难理解发生了什么。我们的代码不清晰，不清晰的代码只会导致技术债务、bug和严重的问题。</p>\n<details><br><summary>英语原文</summary><br>If we only look at the code inside the if statement in the previous function, it’s difficult to understand what’s going on. Our code isn’t clear, and unclear code leads only to technical debt, bugs, and significant headaches.<br></details>\n\n<p>我们如何改善我们的条件？把它提取成一个函数。方法如下:</p>\n<details><br><summary>英语原文</summary><br>How can we improve our conditional? By extracting it into a function. Here’s how:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isGameLost</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    remaining === <span class=\"number\">0</span> ||</span><br><span class=\"line\">    (remaining === <span class=\"number\">1</span> &amp;&amp; remainingPlayers === <span class=\"number\">1</span>) ||</span><br><span class=\"line\">    remainingPlayers === <span class=\"number\">0</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Our function is now much easier to understand:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkGameStatus</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isGameLost()) &#123;</span><br><span class=\"line\">    quitGame();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过将条件提取到具有描述性名称的函数isGameLost，我们的checkGameStatus函数现在可以一目了然了。 为什么？ 因为我们的代码具有参考价值，所以它告诉我们正在发生什么，这就是我们应该一直努力的目标。</p>\n<details><br><summary>英语原文</summary><br>By extracting the conditional into a function with a descriptive name: isGameLost(), our checkGameStatus function is now understandable at a glance. Why? Because our code is informative, it tells us what is going on, which is what we should always strive for.<br></details>\n\n<h2 id=\"使用保护子句避免嵌套if语句-Use-guard-clauses-to-avoid-nested-if-statements\"><a href=\"#使用保护子句避免嵌套if语句-Use-guard-clauses-to-avoid-nested-if-statements\" class=\"headerlink\" title=\"使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)\"></a>使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)</h2><p>嵌套if语句是我们在代码中可能遇到的最糟糕的事情之一。 我已经看到了嵌套的ifs深度为10层……相信我，当我告诉您能够完全掌握该代码中发生的事情绝对是一场噩梦。 这是一个嵌套的if语句的示例（虽然只有三层，但我不是怪物）：</p>\n<details><br><summary>英语原文</summary><br>Nested if statements are one of the worst things we can encounter in code. I’ve seen nested ifs 10 levels deep… Belive me when I tell you that it was an absolute nightmare to be able to fully grasp what was going on in that code. Here’s an example of a nested is statement(only three levels deep though, I’m not a monster):<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTweet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tweet = writeSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tweet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isTweetDoubleChecked()) &#123;</span><br><span class=\"line\">        tweetIt();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Dont publish without double checking your tweet'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Your tweet is empty, can't publish it\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to log in before tweeting'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>您可能需要花费几分钟，然后上下阅读才能遵循该功能的流程。 嵌套的if语句难以阅读和理解。 那么，如何摆脱讨厌的嵌套if语句呢？ 通过反转逻辑并使用我们所谓的保护子句。</p>\n<blockquote>\n<p>在计算机编程中，保护是一个布尔表达式，如果程序要在有问题的分支中继续执行，则该表达式的值必须为true。——维基百科</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>You probably have to take a couple of minutes, and read up and down to follow the flow of the function. Nested if statements are hard to both read and understand. So, how do we get rid of the nasty nested if statement? By reversing the logic and using what we call a guard clause.<br><blockquote>In computer programming, a guard is a boolean expression that must evaluate to true if the program execution is to continue in the branch in question.-Wikipedia</blockquote><br></details>\n\n<p>通过反转函数的逻辑，并在函数开始时放置导致提前退出的条件，它们将充当警卫，并且只允许在满足所有条件的情况下继续执行函数。这样，我们可以避免else语句。下面是如何重构前面的函数以使用保护子句：</p>\n<details><br><summary>英语原文</summary><br>By reversing the logic of our function, and placing the conditions that cause an early exit in the beginning of the function, the will act as guards, and only allow our function to continue executing if all the conditions are met. This way, we can avoid else statements. Here’s how to refactor our previous function to use guard clauses:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTweet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tweet = writeSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isLoggedIn()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to log in before tweeting'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tweet) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Your tweet is empty, can't publish it\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isTweetDoubleChecked()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Dont publish without double checking your tweet'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  tweetIt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如您所看到的，代码要干净得多，也更容易理解。我们可以通过简单地向下读来了解函数的功能，遵循函数的自然流程，不像以前，我们必须上下阅读。</p>\n<details><br><summary>英语原文</summary><br>As you can see, the code is a lot cleaner and easier to understand. We can see What the function does simply by reading down, following the natural flow of the function, unlike before, Where we had to read up and down.<br></details>\n\n<h2 id=\"避免代码重复-Avoid-code-duplication\"><a href=\"#避免代码重复-Avoid-code-duplication\" class=\"headerlink\" title=\"避免代码重复(Avoid code duplication)\"></a>避免代码重复(Avoid code duplication)</h2><p>复制代码总是以失败告终。这会导致这样的情况:“我在这里修复了这个bug，但是忘记在那里做了”或者“我需要做一个改变/添加一个新特性，并且必须在五个不同的地方做它”。</p>\n<p>正如<a href=\"https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself\" target=\"_blank\" rel=\"noopener\">DRY</a>(不要重复)原则所说:</p>\n<p><strong>在一个系统中，每一个知识或逻辑必须有一个单一的、明确的表示</strong></p>\n<p>因此，代码越少越好:它为我们节省了时间和精力，更容易维护，并减少了出现bug的机会。</p>\n<p>那么，我们如何消除重复代码呢？答案并不总是简单的，但是提取函数/变量的逻辑通常很好。让我们看看下面的代码，我在重构应用程序时遇到了这些代码:</p>\n<details><br><summary>英语原文</summary><br>Duplicating code always ends badly. It leads to situations such as:”I fixed this bug here, but forgot to do it there” or “I need to make a change/add a new feature, and how to do it in five different places”.<br><br>Just as the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\" target=\"_blank\" rel=\"noopener\">DRY</a>(don’t repeat yourself) principle states:<br><br><b>Every piece of knowledge or logic must have a single, unambiguous representation within a system.</b><br><br>Therefore, having less code is good: It saves us both time and effort, is easier to maintain, and reduces the chances of bugs appeariing.<br><br>So, how do we get rid of duplicated code? The answer is not always simple, but extracting logic to function/variables usually works just fine. Let’s take a look at the following code, which I ran across when refactoring an application:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getJavascriptNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">\"javascript\"</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRustNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">\"rust\"</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGolangNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">'golang'</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>您可能已经注意到，for循环在两个函数中是完全相同的，除了一个小细节:我们需要的新闻类型，即JavaScript或Rust新闻。为了避免这种重复，我们可以将for循环提取到一个函数中，然后从getJavascriptNews、getRustNews和getGolangNews函数调用这个函数。方法如下:</p>\n<details><br><summary>英语原文</summary><br>You’ll probably have noticed that the for loop is exactly the same in both functions, except for one little detail: the type of news that we want, which is either JavaScript or Rust news. To avoid this duplication, We can extract the for loop into a function, Which we when call from the getJavascriptNews, getRustNews and getGolangNews functions. Here’s how:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getJavascriptNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'javascript'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRustNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'rust'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGolangNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'golang'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewsContent</span>(<span class=\"params\">newsList, type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = newsList.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsList[i].type === type) &#123;</span><br><span class=\"line\">      news.push(newsList[i].content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在将for循环提取到getNewsContent函数后，我们的getJavascriptNews、getRustNews和getGolangNews函数变成了简单、清晰的一行程序。</p>\n<details><br><summary>英语原文</summary><br>After extracting the for loop into the getNewsContent function, our getJavaScriptNews, getRustNews, getGolangNews functions have turned into simple, clear one liners.<br></details>\n\n<h3 id=\"进一步重构-Further-refactoring\"><a href=\"#进一步重构-Further-refactoring\" class=\"headerlink\" title=\"进一步重构(Further refactoring)\"></a>进一步重构(Further refactoring)</h3><p>但是，您是否意识到，除了传递给getNewsContent函数的类型字符串以外，这两个函数完全相同吗？ 这是我们重构代码时通常发生的事情。 通常，一个更改会导致另一个更改，依此类推，直到重构的代码最终变为原始代码大小的一半为止。 让您的代码告诉您它需要什么：</p>\n<blockquote>\n<p>进一步重构我们的getJavascriptNews，getRustNews和getGolangNews函数去哪里了？ 我们用getNews函数代替了它们，该函数接收新闻的类型作为参数。 这样，无论我们添加多少种新闻，我们都始终使用相同的功能。 这称为抽象，它使我们能够重用函数，因此非常有用。 抽象是我在代码中最常使用的技术之一。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>However, have you realized that, once again, both functions are exactly the same except for the type string that we pass into the getNewsContent function? This is something that usually happens when we refactor our code. More often than not, one change leads to another change, and so on, until our refactored code ends up being half the size of the original. Let your code tell you what it needs:<br><blockquote><br>Further refactoring, where did our getJavaScriptNews, getRustNews and getGolangNews functions go? We substituted them for a getNews function, which receives the type of news as an argument. This way, no matter how many more types of news we add, we always use the same function. This is called abstraction, and allows us to reuse functions, thus being incredibly useful. Abstraction is one of the techniques I use most frequently in my code.<br></blockquote><br></details>\n\n<h3 id=\"使用ES6特性使for循环更具可读性-Make-the-for-loop-more-readable-with-ES6-features\"><a href=\"#使用ES6特性使for循环更具可读性-Make-the-for-loop-more-readable-with-ES6-features\" class=\"headerlink\" title=\"使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)\"></a>使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)</h3><p>我发誓这是最后一次重构。</p>\n<p>For循环的可读性不高。 通过引入ES6阵列函数，我们可以避免95％的时间使用它们。 在我们的例子中，我们可以结合使用Array.filter和Array.map来替换原始循环：</p>\n<ul>\n<li>使用Array.filter，我们仅返回其类型等于作为参数传递的类型的元素。</li>\n<li>使用Array.map，我们仅返回item对象的content属性，而不是整个item。</li>\n</ul>\n<p>恭喜，经过三个简单的重构，我们最初的三个功能已减少为两个，它们更易于理解和维护。 另外，通过使用抽象，我们使getNews函数可重用。</p>\n<details><br><summary>英语原文</summary><br>This is the last refactorinig, I swear.<br><br>For loops aren’t precisely readable. With the introduction of ES6 Array functions, We can avoid using them 95% of the time. In our case, we can use Array.filter combined with Array.map to substitute the original loop:<br><ul><br>  <li>With Array.filter we return only the elements whose type equals the type passed as an argument.</li><br>  <li>With Array.map, we return only the content property of the item object, instead of the whole item.</li><br></ul><br>Congratulations, after three simple refactorings, our initial three functions have been reduced to two, which are much easier to understand and maintain. Also, by using abstraction, we made the getNews function reusable.<br></details>\n\n<h2 id=\"函数应该只做一件事-function-should-only-do-one-thing\"><a href=\"#函数应该只做一件事-function-should-only-do-one-thing\" class=\"headerlink\" title=\"函数应该只做一件事(function should only do one thing)\"></a>函数应该只做一件事(function should only do one thing)</h2><p>函数应该只做一件事，而且只做一件事。做不止一件事的函数是万恶之源，也是我们在代码中遇到的最糟糕的事情之一(与嵌套的if一起)。它们很杂乱，使我们的代码难以理解。下面是一个来自实际应用程序的复杂函数示例：</p>\n<blockquote>\n<p>注意：由于此示例不需要事件侦听器的处理程序，因此我选择将其删除。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>functions should only do one thing, and one thing only. functions that do more than one thing are the root of all evil, and one of the worst things we can encounter in code (together with nested ifs). They are messy, and make our code hard to understand. Here’s an example of a complex function from a real application:<br><blockquote><br>Note: Since the handlers for the event listeners were not needed for this example, I chose to remove them.<br></blockquote><br></details>\n\n<p>如您所见，它令人困惑，并且很难理解其中发生了什么。 如果出现任何错误，将很难找到并修复它们。 我们如何改善我们的startProgram功能？ 通过将通用逻辑提取到函数中。 方法如下：</p>\n<details><br><summary>英语原文</summary><br>As you can see, it’s confusing, and hard to understand what’s going on in there. If any bugs come up, it will be quite difficult to find and fix them. How can we improve our startProgram function? By extracting common logic into functions. Here’s how:<br></details>\n\n<p>让我们看一下对startProgram函数所做的更改：</p>\n<p>首先，我们通过使用guard子句摆脱了if else语句。 然后，我们将启动数据库所需的逻辑提取到initDatabase函数中，并将事件侦听器添加到setListeners函数中。</p>\n<p>打印雇员列表的逻辑稍微复杂一些，因此我们创建了三个函数：printEmployeeList，formatEmployeeList和getEmployeeList。</p>\n<p>getEmployeeList负责向employeeList.json发出GET请求，并以json格式返回响应。</p>\n<p>然后由printEmployeeList函数调用，该函数获取雇员列表，并将其传递给formatEmployeeList函数，该函数格式化并返回它。 然后，打印列表。</p>\n<p>如您所见，每个函数仅负责做一件事。</p>\n<p>我们仍然可以对该函数进行一些更改，老实说，应用程序要求将视图与控制器分离，但总的来说，我们的startProgram函数现在提供了更多的信息，理解它的功能绝对没有困难。如果几个月后我们必须回到这段代码，我们就不会有任何问题。</p>\n<details><br><summary>英语原文</summary><br>Let’s go through the changes made to the startProgram function:<br><br>First, we got rid of the if else statement by using a guard clause. Then, we extracted the logic needed to start the database into an initDatabase function and the logic to add event listeners to a setListeners function.<br><br>The logic for printing the employee list is slightly more complex, so we created three functions: printEmployeeList, formatEmployeeList, and getEmployeeList.<br><br>The getEmployeeList is responsible for making a GET request to employeeList.json, and returning the response in json format.<br><br>It is then called by the printEmployeeList function, which takes the list of employees, and passes it to the formatEmployeeList function, which formats and returns it. Then, the list is printed.<br><br>As you can see, every function is responsible for doing only one thing.<br><br>We could still make a few more changes to the function, and honestly, the application is begging for the separation of the view from the controller, but on the whole, out startProgram function is now more informative, and there is absolutely no difficulty in understanding what it does. We would have no problem at all if we had to come back to this code after a couple of months.<br></details>\n\n\n<h2 id=\"总结-Conclusion\"><a href=\"#总结-Conclusion\" class=\"headerlink\" title=\"总结(Conclusion)\"></a>总结(Conclusion)</h2><p>程序员是唯一负责编写优质代码的人。 我们都应该养成从第一行开始编写良好代码的习惯。 编写干净的代码并不复杂，这将对您和您的同事都有所帮助。</p>\n<p>通过应用本教程中显示的5种简单技术，您的代码质量将大大提高，生产率也将得到提高。</p>\n<p>如有任何疑问，请随时提出。 感谢您的阅读。</p>\n<details><br><summary>英语原文</summary><br>Programmers are the only ones responsible for writting good, quality code. We should all make it a habit to write good code from the very fitst line. Writting clean code isn’t complicated, and doing so will help both you and your colleagues.<br><br>By applying the 5 simple techniques shown in this tutorial, your code quality should improve considerably, and so will your productivity.<br><br>If you have any questions, don’t hesuitate to ask. Thank you for reading.<br></details>","site":{"data":{}},"excerpt":"<p>错误的代码有效。 我们都知道这一点。 开发人员多年来一直在编写代码，而没有考虑过自己是否做对了。 这是可以理解的，不是吗？ 毕竟，我们已经必须应对与行业保持同步的压力以及我们工作的需求……</p>\n<details><br><summary>英语原文</summary><br><p>Bad code works. We all know this. Developers have been writting code for years without giving a single thought to whether they’er doing it right or not. It’s understandable, isn’t it? After all, We already have to deal with the stress of keeping up with the industry and the demands or our job…</p><br></details><br>","more":"<br><br>答案是否定的。编写糟糕的代码是要付出代价的。您是否曾经遇到过这样的问题：几周之后，您无法理解自己的代码，不得不花费数小时甚至数天的时间来弄清楚到底发生了什么？<br><details><br><summary>英语原文</summary><br>The answer is no. Writting bad codes comes at a price. Have you ever faced the issue of not understanding your own code after a couple of weeks, and having to spend hours, or even days figuring out what was going on?<br></details>\n\n<p>解决此（极端）常见问题的方法是使您的代码尽可能清晰明了。 我甚至会说，即使是非技术人员也应该理解您的代码。 现在该丢下我们的借口，提高代码质量了。</p>\n<details><br><summary>英语原文</summary><br>The solution to this (extremely) common problem is to make your code as clear and informative as possible. I will go as far as to say that your code should be understood even by a non-technical person. It’s time to drop our excuses, and improve the quality of your code.<br></details>\n\n<p>编写干净的代码并不那么复杂。 本教程将通过实际示例向您展示5种改善代码的简单技术：<br>1.摆脱switch语句<br>2.使你的条件句具有描述性<br>3.使用保护子句避免嵌套if语句<br>4.避免代码重复<br>5.函数应该只做一件事</p>\n<details><br><summary>英语原文</summary><br>Writting clean code isn’t that complicated. This tutorial will show you 5 simple techniques to improve your code, with practical examples:<br>1.Get rid of switch statements<br>2.Make your conditionals descriptive<br>3.Use guard clauses to avoid nested if statements<br>4.Avoid code duplication<br>5.functions should only do one thing<br></details>\n\n<h2 id=\"摆脱switch语句-Get-rid-of-switch-statements\"><a href=\"#摆脱switch语句-Get-rid-of-switch-statements\" class=\"headerlink\" title=\"摆脱switch语句(Get rid of switch statements)\"></a>摆脱switch语句(Get rid of switch statements)</h2><p>我们通常使用switch语句来避免使用大的if else if语句。但是，switch语句非常冗长，很难维护，甚至更难调试。它们使我们的代码混乱不堪，而且在我看来，它们的语法很奇怪，令人不舒服。在添加更多的case时，我们必须手动添加每个case和break语句，这很容易出错。</p>\n<details><br><summary>英语原文</summary><br>We normally use switch statements to avoid large if else if statements. However, switch statements are very verbose, hard to maintain and even harder to debug. They clutter up our code, and, in my humble opinion, have an odd, uncomfortable syntax. When adding more cases, we have to manually add each case and break statement, which is quite error-prone.<br></details>\n\n<p>让我们看一个switch语句的例子:</p>\n<details><br><summary>英语原文</summary><br>Let’s take a look at an example of a switch statement:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pokemon;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Water'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Squirtle'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Fire'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Charmander'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Plant'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Bulbasur'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Electric'</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Pikachu'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      pokemon = <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br></pre></td></tr></table></figure>\n<p>假设我们需要向switch语句添加更多的case。我们需要编写的代码数量是相当大的。我们可能会以复制粘贴代码结束，我们都知道结局如何。</p>\n<details><br><summary>英语原文</summary><br>Imagine that we need to add more case to the switch statement. The amount of code that we would have to write is considerable. We would probably end up copy-pasting code, and we all know how that ends.<br></details>\n\n<p>那么，如何避免使用switch语句？ 通过使用对象文字。 对象文字很简单，易于编写，读取和维护。 我们都习惯于在JavaScript中处理对象，并且语法比switch语句新鲜得多。 这是一个例子：</p>\n<details><br><summary>英语原文</summary><br>So, how do we avoid switch statements? By using an object literal. Object literals are simple, easy to write, read and maintain. We are all used to handling objects in JavaScript, and the syntax is a lot fresher than that of the switch statement. Here is an example:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pokemon = &#123;</span><br><span class=\"line\">  Water: <span class=\"string\">'Squirtle'</span>,</span><br><span class=\"line\">  Fire: <span class=\"string\">'Charmander'</span>,</span><br><span class=\"line\">  Plant: <span class=\"string\">'Bulbasur'</span>,</span><br><span class=\"line\">  Electric: <span class=\"string\">'Pikachu'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon[type] || <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the type isn't found in the pokemon object, the function will return the default value 'Mew'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'unknown'</span>)); <span class=\"comment\">// Result: Mew</span></span><br></pre></td></tr></table></figure>\n<p>如您所见，我们可以使用||操作符添加一个默认值。如果在pokemon对象中没有找到指定的type类型，getPokemon函数将返回“Mew”作为默认值。</p>\n<blockquote>\n<p>注意：你可能已经注意到，我们在函数外部声明了pokemon对象，而不是在函数内部。这样做是为了防止每次执行函数时都创建它。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>As you can see, we can add a default value by using the || operator. If the type isn’t found in the pokemon object, the getPokemon function will return ‘Mew’ as a default value.<br><br><blockquote>Note: As you will probably have noticed, we declare the pokemon object outside the function, instead of inside. We do this to prevent it from being created each time we execute the function.</blockquote><br></details>\n\n<p>我们也可以使用Map来达到同样的效果。映射是键值对的集合，就像对象一样。不同之处在于Map允许任何类型的键，而对象只允许字符串作为键。此外，Map还有一系列有趣的属性和方法。你可以在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">这里阅读</a>更多关于Map结构的信息。</p>\n<details><br><summary>英语原文</summary><br>We can also use a map to achieve the same result. A map is a collection of key value pairs, just like an object. The difference is that map allows keys of any type, while objects onlu allow strings as keys. Also, map has an interesting series of properties and methods. You can read more about the map structure <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">here</a>.<br></details>\n\n<p>以下是如何使用Map：</p>\n<details><br><summary>英语原文</summary><br>Here’s how to use map:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pokemon = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">'Water'</span>, <span class=\"string\">'Squirtle'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Fire'</span>, <span class=\"string\">'Charmander'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Plant'</span>, <span class=\"string\">'Bulbasur'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'Electric'</span>, <span class=\"string\">'Pikachu'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPokemon</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pokemon.get(type) || <span class=\"string\">'Mew'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'Fire'</span>)); <span class=\"comment\">// Result: Charmander</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPokemon(<span class=\"string\">'unknown'</span>)); <span class=\"comment\">// Result: Mew</span></span><br></pre></td></tr></table></figure>\n<p>正如您所看到的，在用对象文字或映射替换switch语句时，我们的代码看起来要干净得多，也简单得多。</p>\n<details><br><summary>英语原文</summary><br>As you can see, our code looks a lot cleaner and straightforward when replacing switch statements with an object literal or map.<br></details>\n\n<h2 id=\"使你的条件句具有描述性-Make-your-conditionals-descriptive\"><a href=\"#使你的条件句具有描述性-Make-your-conditionals-descriptive\" class=\"headerlink\" title=\"使你的条件句具有描述性(Make your conditionals descriptive)\"></a>使你的条件句具有描述性(Make your conditionals descriptive)</h2><p>在编写代码时，条件语句是绝对必要的。 但是，它们很快就会失控，最终变得难以理解。这导致要么不得不写注释解释语句的作用，要么不得不花费宝贵的时间追溯我们自己的代码来理解发生了什么。这很糟糕。</p>\n<details><br><summary>英语原文</summary><br>Conditional statements are an absolute necessity when writting code. However, they can quickly get out of hand, and end up being impossible to understand. This leads to either having to write comments explaining what the statement does, or having to spend valuable time tracing back our own code to understand what’s going on. This is bad.<br></details>\n\n<p>看一下以下语句：</p>\n<details><br><summary>英语原文</summary><br>Take a look at the following statement:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkGameStatus</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    remaining === <span class=\"number\">0</span> ||</span><br><span class=\"line\">    (remaining === <span class=\"number\">1</span> &amp;&amp; remainingPlayers === <span class=\"number\">1</span>) ||</span><br><span class=\"line\">    remainingPlayers === <span class=\"number\">0</span></span><br><span class=\"line\">  )&#123;</span><br><span class=\"line\">    quiteGame();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只查看前一个函数中If语句中的代码，就很难理解发生了什么。我们的代码不清晰，不清晰的代码只会导致技术债务、bug和严重的问题。</p>\n<details><br><summary>英语原文</summary><br>If we only look at the code inside the if statement in the previous function, it’s difficult to understand what’s going on. Our code isn’t clear, and unclear code leads only to technical debt, bugs, and significant headaches.<br></details>\n\n<p>我们如何改善我们的条件？把它提取成一个函数。方法如下:</p>\n<details><br><summary>英语原文</summary><br>How can we improve our conditional? By extracting it into a function. Here’s how:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isGameLost</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    remaining === <span class=\"number\">0</span> ||</span><br><span class=\"line\">    (remaining === <span class=\"number\">1</span> &amp;&amp; remainingPlayers === <span class=\"number\">1</span>) ||</span><br><span class=\"line\">    remainingPlayers === <span class=\"number\">0</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Our function is now much easier to understand:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkGameStatus</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isGameLost()) &#123;</span><br><span class=\"line\">    quitGame();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过将条件提取到具有描述性名称的函数isGameLost，我们的checkGameStatus函数现在可以一目了然了。 为什么？ 因为我们的代码具有参考价值，所以它告诉我们正在发生什么，这就是我们应该一直努力的目标。</p>\n<details><br><summary>英语原文</summary><br>By extracting the conditional into a function with a descriptive name: isGameLost(), our checkGameStatus function is now understandable at a glance. Why? Because our code is informative, it tells us what is going on, which is what we should always strive for.<br></details>\n\n<h2 id=\"使用保护子句避免嵌套if语句-Use-guard-clauses-to-avoid-nested-if-statements\"><a href=\"#使用保护子句避免嵌套if语句-Use-guard-clauses-to-avoid-nested-if-statements\" class=\"headerlink\" title=\"使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)\"></a>使用保护子句避免嵌套if语句(Use guard clauses to avoid nested if statements)</h2><p>嵌套if语句是我们在代码中可能遇到的最糟糕的事情之一。 我已经看到了嵌套的ifs深度为10层……相信我，当我告诉您能够完全掌握该代码中发生的事情绝对是一场噩梦。 这是一个嵌套的if语句的示例（虽然只有三层，但我不是怪物）：</p>\n<details><br><summary>英语原文</summary><br>Nested if statements are one of the worst things we can encounter in code. I’ve seen nested ifs 10 levels deep… Belive me when I tell you that it was an absolute nightmare to be able to fully grasp what was going on in that code. Here’s an example of a nested is statement(only three levels deep though, I’m not a monster):<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTweet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tweet = writeSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tweet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isTweetDoubleChecked()) &#123;</span><br><span class=\"line\">        tweetIt();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Dont publish without double checking your tweet'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Your tweet is empty, can't publish it\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to log in before tweeting'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>您可能需要花费几分钟，然后上下阅读才能遵循该功能的流程。 嵌套的if语句难以阅读和理解。 那么，如何摆脱讨厌的嵌套if语句呢？ 通过反转逻辑并使用我们所谓的保护子句。</p>\n<blockquote>\n<p>在计算机编程中，保护是一个布尔表达式，如果程序要在有问题的分支中继续执行，则该表达式的值必须为true。——维基百科</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>You probably have to take a couple of minutes, and read up and down to follow the flow of the function. Nested if statements are hard to both read and understand. So, how do we get rid of the nasty nested if statement? By reversing the logic and using what we call a guard clause.<br><blockquote>In computer programming, a guard is a boolean expression that must evaluate to true if the program execution is to continue in the branch in question.-Wikipedia</blockquote><br></details>\n\n<p>通过反转函数的逻辑，并在函数开始时放置导致提前退出的条件，它们将充当警卫，并且只允许在满足所有条件的情况下继续执行函数。这样，我们可以避免else语句。下面是如何重构前面的函数以使用保护子句：</p>\n<details><br><summary>英语原文</summary><br>By reversing the logic of our function, and placing the conditions that cause an early exit in the beginning of the function, the will act as guards, and only allow our function to continue executing if all the conditions are met. This way, we can avoid else statements. Here’s how to refactor our previous function to use guard clauses:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTweet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tweet = writeSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isLoggedIn()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'You need to log in before tweeting'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tweet) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Your tweet is empty, can't publish it\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isTweetDoubleChecked()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Dont publish without double checking your tweet'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  tweetIt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如您所看到的，代码要干净得多，也更容易理解。我们可以通过简单地向下读来了解函数的功能，遵循函数的自然流程，不像以前，我们必须上下阅读。</p>\n<details><br><summary>英语原文</summary><br>As you can see, the code is a lot cleaner and easier to understand. We can see What the function does simply by reading down, following the natural flow of the function, unlike before, Where we had to read up and down.<br></details>\n\n<h2 id=\"避免代码重复-Avoid-code-duplication\"><a href=\"#避免代码重复-Avoid-code-duplication\" class=\"headerlink\" title=\"避免代码重复(Avoid code duplication)\"></a>避免代码重复(Avoid code duplication)</h2><p>复制代码总是以失败告终。这会导致这样的情况:“我在这里修复了这个bug，但是忘记在那里做了”或者“我需要做一个改变/添加一个新特性，并且必须在五个不同的地方做它”。</p>\n<p>正如<a href=\"https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself\" target=\"_blank\" rel=\"noopener\">DRY</a>(不要重复)原则所说:</p>\n<p><strong>在一个系统中，每一个知识或逻辑必须有一个单一的、明确的表示</strong></p>\n<p>因此，代码越少越好:它为我们节省了时间和精力，更容易维护，并减少了出现bug的机会。</p>\n<p>那么，我们如何消除重复代码呢？答案并不总是简单的，但是提取函数/变量的逻辑通常很好。让我们看看下面的代码，我在重构应用程序时遇到了这些代码:</p>\n<details><br><summary>英语原文</summary><br>Duplicating code always ends badly. It leads to situations such as:”I fixed this bug here, but forgot to do it there” or “I need to make a change/add a new feature, and how to do it in five different places”.<br><br>Just as the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\" target=\"_blank\" rel=\"noopener\">DRY</a>(don’t repeat yourself) principle states:<br><br><b>Every piece of knowledge or logic must have a single, unambiguous representation within a system.</b><br><br>Therefore, having less code is good: It saves us both time and effort, is easier to maintain, and reduces the chances of bugs appeariing.<br><br>So, how do we get rid of duplicated code? The answer is not always simple, but extracting logic to function/variables usually works just fine. Let’s take a look at the following code, which I ran across when refactoring an application:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getJavascriptNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">\"javascript\"</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRustNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">\"rust\"</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGolangNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = allNews.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allNews[i].type === <span class=\"string\">'golang'</span>) &#123;</span><br><span class=\"line\">      news.push(allNews[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>您可能已经注意到，for循环在两个函数中是完全相同的，除了一个小细节:我们需要的新闻类型，即JavaScript或Rust新闻。为了避免这种重复，我们可以将for循环提取到一个函数中，然后从getJavascriptNews、getRustNews和getGolangNews函数调用这个函数。方法如下:</p>\n<details><br><summary>英语原文</summary><br>You’ll probably have noticed that the for loop is exactly the same in both functions, except for one little detail: the type of news that we want, which is either JavaScript or Rust news. To avoid this duplication, We can extract the for loop into a function, Which we when call from the getJavascriptNews, getRustNews and getGolangNews functions. Here’s how:<br></details>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getJavascriptNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'javascript'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRustNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'rust'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGolangNews</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allNews = getNewsFromWeb();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getNewsContent(allNews, <span class=\"string\">'golang'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNewsContent</span>(<span class=\"params\">newsList, type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> news = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = newsList.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsList[i].type === type) &#123;</span><br><span class=\"line\">      news.push(newsList[i].content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> news;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在将for循环提取到getNewsContent函数后，我们的getJavascriptNews、getRustNews和getGolangNews函数变成了简单、清晰的一行程序。</p>\n<details><br><summary>英语原文</summary><br>After extracting the for loop into the getNewsContent function, our getJavaScriptNews, getRustNews, getGolangNews functions have turned into simple, clear one liners.<br></details>\n\n<h3 id=\"进一步重构-Further-refactoring\"><a href=\"#进一步重构-Further-refactoring\" class=\"headerlink\" title=\"进一步重构(Further refactoring)\"></a>进一步重构(Further refactoring)</h3><p>但是，您是否意识到，除了传递给getNewsContent函数的类型字符串以外，这两个函数完全相同吗？ 这是我们重构代码时通常发生的事情。 通常，一个更改会导致另一个更改，依此类推，直到重构的代码最终变为原始代码大小的一半为止。 让您的代码告诉您它需要什么：</p>\n<blockquote>\n<p>进一步重构我们的getJavascriptNews，getRustNews和getGolangNews函数去哪里了？ 我们用getNews函数代替了它们，该函数接收新闻的类型作为参数。 这样，无论我们添加多少种新闻，我们都始终使用相同的功能。 这称为抽象，它使我们能够重用函数，因此非常有用。 抽象是我在代码中最常使用的技术之一。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>However, have you realized that, once again, both functions are exactly the same except for the type string that we pass into the getNewsContent function? This is something that usually happens when we refactor our code. More often than not, one change leads to another change, and so on, until our refactored code ends up being half the size of the original. Let your code tell you what it needs:<br><blockquote><br>Further refactoring, where did our getJavaScriptNews, getRustNews and getGolangNews functions go? We substituted them for a getNews function, which receives the type of news as an argument. This way, no matter how many more types of news we add, we always use the same function. This is called abstraction, and allows us to reuse functions, thus being incredibly useful. Abstraction is one of the techniques I use most frequently in my code.<br></blockquote><br></details>\n\n<h3 id=\"使用ES6特性使for循环更具可读性-Make-the-for-loop-more-readable-with-ES6-features\"><a href=\"#使用ES6特性使for循环更具可读性-Make-the-for-loop-more-readable-with-ES6-features\" class=\"headerlink\" title=\"使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)\"></a>使用ES6特性使for循环更具可读性(Make the for loop more readable with ES6 features)</h3><p>我发誓这是最后一次重构。</p>\n<p>For循环的可读性不高。 通过引入ES6阵列函数，我们可以避免95％的时间使用它们。 在我们的例子中，我们可以结合使用Array.filter和Array.map来替换原始循环：</p>\n<ul>\n<li>使用Array.filter，我们仅返回其类型等于作为参数传递的类型的元素。</li>\n<li>使用Array.map，我们仅返回item对象的content属性，而不是整个item。</li>\n</ul>\n<p>恭喜，经过三个简单的重构，我们最初的三个功能已减少为两个，它们更易于理解和维护。 另外，通过使用抽象，我们使getNews函数可重用。</p>\n<details><br><summary>英语原文</summary><br>This is the last refactorinig, I swear.<br><br>For loops aren’t precisely readable. With the introduction of ES6 Array functions, We can avoid using them 95% of the time. In our case, we can use Array.filter combined with Array.map to substitute the original loop:<br><ul><br>  <li>With Array.filter we return only the elements whose type equals the type passed as an argument.</li><br>  <li>With Array.map, we return only the content property of the item object, instead of the whole item.</li><br></ul><br>Congratulations, after three simple refactorings, our initial three functions have been reduced to two, which are much easier to understand and maintain. Also, by using abstraction, we made the getNews function reusable.<br></details>\n\n<h2 id=\"函数应该只做一件事-function-should-only-do-one-thing\"><a href=\"#函数应该只做一件事-function-should-only-do-one-thing\" class=\"headerlink\" title=\"函数应该只做一件事(function should only do one thing)\"></a>函数应该只做一件事(function should only do one thing)</h2><p>函数应该只做一件事，而且只做一件事。做不止一件事的函数是万恶之源，也是我们在代码中遇到的最糟糕的事情之一(与嵌套的if一起)。它们很杂乱，使我们的代码难以理解。下面是一个来自实际应用程序的复杂函数示例：</p>\n<blockquote>\n<p>注意：由于此示例不需要事件侦听器的处理程序，因此我选择将其删除。</p>\n</blockquote>\n<details><br><summary>英语原文</summary><br>functions should only do one thing, and one thing only. functions that do more than one thing are the root of all evil, and one of the worst things we can encounter in code (together with nested ifs). They are messy, and make our code hard to understand. Here’s an example of a complex function from a real application:<br><blockquote><br>Note: Since the handlers for the event listeners were not needed for this example, I chose to remove them.<br></blockquote><br></details>\n\n<p>如您所见，它令人困惑，并且很难理解其中发生了什么。 如果出现任何错误，将很难找到并修复它们。 我们如何改善我们的startProgram功能？ 通过将通用逻辑提取到函数中。 方法如下：</p>\n<details><br><summary>英语原文</summary><br>As you can see, it’s confusing, and hard to understand what’s going on in there. If any bugs come up, it will be quite difficult to find and fix them. How can we improve our startProgram function? By extracting common logic into functions. Here’s how:<br></details>\n\n<p>让我们看一下对startProgram函数所做的更改：</p>\n<p>首先，我们通过使用guard子句摆脱了if else语句。 然后，我们将启动数据库所需的逻辑提取到initDatabase函数中，并将事件侦听器添加到setListeners函数中。</p>\n<p>打印雇员列表的逻辑稍微复杂一些，因此我们创建了三个函数：printEmployeeList，formatEmployeeList和getEmployeeList。</p>\n<p>getEmployeeList负责向employeeList.json发出GET请求，并以json格式返回响应。</p>\n<p>然后由printEmployeeList函数调用，该函数获取雇员列表，并将其传递给formatEmployeeList函数，该函数格式化并返回它。 然后，打印列表。</p>\n<p>如您所见，每个函数仅负责做一件事。</p>\n<p>我们仍然可以对该函数进行一些更改，老实说，应用程序要求将视图与控制器分离，但总的来说，我们的startProgram函数现在提供了更多的信息，理解它的功能绝对没有困难。如果几个月后我们必须回到这段代码，我们就不会有任何问题。</p>\n<details><br><summary>英语原文</summary><br>Let’s go through the changes made to the startProgram function:<br><br>First, we got rid of the if else statement by using a guard clause. Then, we extracted the logic needed to start the database into an initDatabase function and the logic to add event listeners to a setListeners function.<br><br>The logic for printing the employee list is slightly more complex, so we created three functions: printEmployeeList, formatEmployeeList, and getEmployeeList.<br><br>The getEmployeeList is responsible for making a GET request to employeeList.json, and returning the response in json format.<br><br>It is then called by the printEmployeeList function, which takes the list of employees, and passes it to the formatEmployeeList function, which formats and returns it. Then, the list is printed.<br><br>As you can see, every function is responsible for doing only one thing.<br><br>We could still make a few more changes to the function, and honestly, the application is begging for the separation of the view from the controller, but on the whole, out startProgram function is now more informative, and there is absolutely no difficulty in understanding what it does. We would have no problem at all if we had to come back to this code after a couple of months.<br></details>\n\n\n<h2 id=\"总结-Conclusion\"><a href=\"#总结-Conclusion\" class=\"headerlink\" title=\"总结(Conclusion)\"></a>总结(Conclusion)</h2><p>程序员是唯一负责编写优质代码的人。 我们都应该养成从第一行开始编写良好代码的习惯。 编写干净的代码并不复杂，这将对您和您的同事都有所帮助。</p>\n<p>通过应用本教程中显示的5种简单技术，您的代码质量将大大提高，生产率也将得到提高。</p>\n<p>如有任何疑问，请随时提出。 感谢您的阅读。</p>\n<details><br><summary>英语原文</summary><br>Programmers are the only ones responsible for writting good, quality code. We should all make it a habit to write good code from the very fitst line. Writting clean code isn’t complicated, and doing so will help both you and your colleagues.<br><br>By applying the 5 simple techniques shown in this tutorial, your code quality should improve considerably, and so will your productivity.<br><br>If you have any questions, don’t hesuitate to ask. Thank you for reading.<br></details>"},{"title":"Vue CLI 3配置svg-sprite-loader与svgo-loader","date":"2019-11-15T16:00:00.000Z","toc":false,"comments":0,"_content":"\n随着高清屏幕的普及，相比使用png等位图而言，使用SVG等矢量图形是一种全新的设计方式。更重要的是相比位图而言，SVG有着无可比拟的优势。其中，使用SVG中的[Symbol元素](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol)制作Icon图标变得越来越流行，这种技术被称为SVG Sprite。这里所说的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。\n\n而Vue CLI已经更新到了3.0版本，那么[Vue CLI 3.0](https://cli.vuejs.org/zh/guide/) 如何修改Webpack设置来配置[svg-sprite-loader](https://github.com/JetBrains/svg-sprite-loader)与[svgo-loader](https://github.com/rpominov/svgo-loader)实现SVG Sprite？\n\n<!--more-->\n\n## 配置svg-sprite-loader\n\n安装svg-sprite-loader：\n```\nnpm install --save-dev svg-sprite-loader\n```\n\nVue CLI 3.0 与 2.x版本不同，3.0版本内部的 webpack 配置是通过 webpack-chain 维护的，因此，你需要熟悉 [webpack-chain 的 API](https://github.com/neutrinojs/webpack-chain)。\n\nVue CLI对svg有一个默认的rule设置，这个设置通过file-loader加载svg文件。因此，需要在vue.config.js中先清除默认的svg配置：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n  }\n}\n```\n接着，在vue.config.js中配置svg-sprite-loader，将处理路径设置为你的svg图标路径（如：“./src/icons”），方法如下：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\",\n        include: [\"./src/icons\"]\n      })\n      .end()\n  }\n}\n```\n\n## 配置svgo-loader\n\n安装svgo和svgo-loader：\n```\nnpm install svgo svgo-loader --save-dev\n```\n在vue.config.js中加上svgo-loader的配置：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\",\n        include: [\"./src/icons\"]\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\nsvgo-loader加载器options的plugins配置项参考[svgo配置项列表](https://github.com/svg/svgo#what-it-can-do)。\n\n## 优化配置\n\n上面直接清除默认的svg配置可能会引起异常，应该排除“./src/icons”这个svg图标文件夹即可，方法如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 清除svg默认配置对./src/icons文件夹的处理\n    config.module\n      .rule(\"svg\")\n      .exclude\n      .add(resolve(\"./src/icons\"))\n      .end()\n  }\n}\n```\n接下来，对“./src/icons”添加一个新的rule，配置如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 添加新的rule处理./src/icons文件夹的svg文件\n    config.module\n      .rule(\"svg-sprite\")\n      .test(/\\.svg$/)\n      .include\n      .add(resolve(\"./src/icons\"))\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\"\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\n完整的配置如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 清除svg默认配置对./src/icons文件夹的处理\n    config.module\n      .rule(\"svg\")\n      .exclude\n      .add(resolve(\"./src/icons\"))\n      .end()\n    \n    // 添加新的rule处理./src/icons文件夹的svg文件\n    config.module\n      .rule(\"svg-sprite\")\n      .test(/\\.svg$/)\n      .include\n      .add(resolve(\"./src/icons\"))\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\"\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\n","source":"_posts/2019-11-16-Vue CLI 3配置svg-sprite-loader与svgo-loader.md","raw":"---\ntitle: Vue CLI 3配置svg-sprite-loader与svgo-loader\ndate: 2019-11-16\ntoc: false\ncomments: false\ntags:\n    - Vue CLI 3\n    - svg-sprite-loader\n    - svgo-loader\n    - svgo\n    - svg symbols\n    - web图标\ncategories:\n    - SVG\n---\n\n随着高清屏幕的普及，相比使用png等位图而言，使用SVG等矢量图形是一种全新的设计方式。更重要的是相比位图而言，SVG有着无可比拟的优势。其中，使用SVG中的[Symbol元素](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol)制作Icon图标变得越来越流行，这种技术被称为SVG Sprite。这里所说的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。\n\n而Vue CLI已经更新到了3.0版本，那么[Vue CLI 3.0](https://cli.vuejs.org/zh/guide/) 如何修改Webpack设置来配置[svg-sprite-loader](https://github.com/JetBrains/svg-sprite-loader)与[svgo-loader](https://github.com/rpominov/svgo-loader)实现SVG Sprite？\n\n<!--more-->\n\n## 配置svg-sprite-loader\n\n安装svg-sprite-loader：\n```\nnpm install --save-dev svg-sprite-loader\n```\n\nVue CLI 3.0 与 2.x版本不同，3.0版本内部的 webpack 配置是通过 webpack-chain 维护的，因此，你需要熟悉 [webpack-chain 的 API](https://github.com/neutrinojs/webpack-chain)。\n\nVue CLI对svg有一个默认的rule设置，这个设置通过file-loader加载svg文件。因此，需要在vue.config.js中先清除默认的svg配置：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n  }\n}\n```\n接着，在vue.config.js中配置svg-sprite-loader，将处理路径设置为你的svg图标路径（如：“./src/icons”），方法如下：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\",\n        include: [\"./src/icons\"]\n      })\n      .end()\n  }\n}\n```\n\n## 配置svgo-loader\n\n安装svgo和svgo-loader：\n```\nnpm install svgo svgo-loader --save-dev\n```\n在vue.config.js中加上svgo-loader的配置：\n```js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule(\"svg\")\n      .uses\n      .clear()\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\",\n        include: [\"./src/icons\"]\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\nsvgo-loader加载器options的plugins配置项参考[svgo配置项列表](https://github.com/svg/svgo#what-it-can-do)。\n\n## 优化配置\n\n上面直接清除默认的svg配置可能会引起异常，应该排除“./src/icons”这个svg图标文件夹即可，方法如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 清除svg默认配置对./src/icons文件夹的处理\n    config.module\n      .rule(\"svg\")\n      .exclude\n      .add(resolve(\"./src/icons\"))\n      .end()\n  }\n}\n```\n接下来，对“./src/icons”添加一个新的rule，配置如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 添加新的rule处理./src/icons文件夹的svg文件\n    config.module\n      .rule(\"svg-sprite\")\n      .test(/\\.svg$/)\n      .include\n      .add(resolve(\"./src/icons\"))\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\"\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\n完整的配置如下：\n```js\nconst { resolve } = require('path')\n\nmodule.exports = {\n  chainWebpack: config => {\n    // 清除svg默认配置对./src/icons文件夹的处理\n    config.module\n      .rule(\"svg\")\n      .exclude\n      .add(resolve(\"./src/icons\"))\n      .end()\n    \n    // 添加新的rule处理./src/icons文件夹的svg文件\n    config.module\n      .rule(\"svg-sprite\")\n      .test(/\\.svg$/)\n      .include\n      .add(resolve(\"./src/icons\"))\n      .end()\n      .use(\"svg-sprite-loader\")\n      .loader(\"svg-sprite-loader\")\n      .options({\n        symbolId: \"icon-[name]\"\n      })\n      .end()\n      .before(\"svg-sprite-loader\")\n      .use(\"svgo-loader\")\n      .loader(\"svgo-loader\")\n      .options({\n        plugins: [\n          {removeAttrs: {attrs: \"path:fill\"}}\n        ]\n      })\n      .end()\n  }\n}\n```\n","slug":"2019-11-16-Vue CLI 3配置svg-sprite-loader与svgo-loader","published":1,"updated":"2019-11-16T08:17:32.405Z","_id":"ck31arlkw0060acqx7ta961oe","layout":"post","photos":[],"link":"","content":"<p>随着高清屏幕的普及，相比使用png等位图而言，使用SVG等矢量图形是一种全新的设计方式。更重要的是相比位图而言，SVG有着无可比拟的优势。其中，使用SVG中的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol\" target=\"_blank\" rel=\"noopener\">Symbol元素</a>制作Icon图标变得越来越流行，这种技术被称为SVG Sprite。这里所说的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。</p>\n<p>而Vue CLI已经更新到了3.0版本，那么<a href=\"https://cli.vuejs.org/zh/guide/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3.0</a> 如何修改Webpack设置来配置<a href=\"https://github.com/JetBrains/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a>与<a href=\"https://github.com/rpominov/svgo-loader\" target=\"_blank\" rel=\"noopener\">svgo-loader</a>实现SVG Sprite？</p>\n<a id=\"more\"></a>\n<h2 id=\"配置svg-sprite-loader\"><a href=\"#配置svg-sprite-loader\" class=\"headerlink\" title=\"配置svg-sprite-loader\"></a>配置svg-sprite-loader</h2><p>安装svg-sprite-loader：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev svg-sprite-loader</span><br></pre></td></tr></table></figure></p>\n<p>Vue CLI 3.0 与 2.x版本不同，3.0版本内部的 webpack 配置是通过 webpack-chain 维护的，因此，你需要熟悉 <a href=\"https://github.com/neutrinojs/webpack-chain\" target=\"_blank\" rel=\"noopener\">webpack-chain 的 API</a>。</p>\n<p>Vue CLI对svg有一个默认的rule设置，这个设置通过file-loader加载svg文件。因此，需要在vue.config.js中先清除默认的svg配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着，在vue.config.js中配置svg-sprite-loader，将处理路径设置为你的svg图标路径（如：“./src/icons”），方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span>,</span><br><span class=\"line\">        include: [<span class=\"string\">\"./src/icons\"</span>]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置svgo-loader\"><a href=\"#配置svgo-loader\" class=\"headerlink\" title=\"配置svgo-loader\"></a>配置svgo-loader</h2><p>安装svgo和svgo-loader：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install svgo svgo-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>在vue.config.js中加上svgo-loader的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span>,</span><br><span class=\"line\">        include: [<span class=\"string\">\"./src/icons\"</span>]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>svgo-loader加载器options的plugins配置项参考<a href=\"https://github.com/svg/svgo#what-it-can-do\" target=\"_blank\" rel=\"noopener\">svgo配置项列表</a>。</p>\n<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><p>上面直接清除默认的svg配置可能会引起异常，应该排除“./src/icons”这个svg图标文件夹即可，方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除svg默认配置对./src/icons文件夹的处理</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .exclude</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，对“./src/icons”添加一个新的rule，配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的rule处理./src/icons文件夹的svg文件</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg-sprite\"</span>)</span><br><span class=\"line\">      .test(<span class=\"regexp\">/\\.svg$/</span>)</span><br><span class=\"line\">      .include</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完整的配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除svg默认配置对./src/icons文件夹的处理</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .exclude</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加新的rule处理./src/icons文件夹的svg文件</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg-sprite\"</span>)</span><br><span class=\"line\">      .test(<span class=\"regexp\">/\\.svg$/</span>)</span><br><span class=\"line\">      .include</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>随着高清屏幕的普及，相比使用png等位图而言，使用SVG等矢量图形是一种全新的设计方式。更重要的是相比位图而言，SVG有着无可比拟的优势。其中，使用SVG中的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol\" target=\"_blank\" rel=\"noopener\">Symbol元素</a>制作Icon图标变得越来越流行，这种技术被称为SVG Sprite。这里所说的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。</p>\n<p>而Vue CLI已经更新到了3.0版本，那么<a href=\"https://cli.vuejs.org/zh/guide/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3.0</a> 如何修改Webpack设置来配置<a href=\"https://github.com/JetBrains/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a>与<a href=\"https://github.com/rpominov/svgo-loader\" target=\"_blank\" rel=\"noopener\">svgo-loader</a>实现SVG Sprite？</p>","more":"<h2 id=\"配置svg-sprite-loader\"><a href=\"#配置svg-sprite-loader\" class=\"headerlink\" title=\"配置svg-sprite-loader\"></a>配置svg-sprite-loader</h2><p>安装svg-sprite-loader：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev svg-sprite-loader</span><br></pre></td></tr></table></figure></p>\n<p>Vue CLI 3.0 与 2.x版本不同，3.0版本内部的 webpack 配置是通过 webpack-chain 维护的，因此，你需要熟悉 <a href=\"https://github.com/neutrinojs/webpack-chain\" target=\"_blank\" rel=\"noopener\">webpack-chain 的 API</a>。</p>\n<p>Vue CLI对svg有一个默认的rule设置，这个设置通过file-loader加载svg文件。因此，需要在vue.config.js中先清除默认的svg配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着，在vue.config.js中配置svg-sprite-loader，将处理路径设置为你的svg图标路径（如：“./src/icons”），方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span>,</span><br><span class=\"line\">        include: [<span class=\"string\">\"./src/icons\"</span>]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置svgo-loader\"><a href=\"#配置svgo-loader\" class=\"headerlink\" title=\"配置svgo-loader\"></a>配置svgo-loader</h2><p>安装svgo和svgo-loader：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install svgo svgo-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>在vue.config.js中加上svgo-loader的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .uses</span><br><span class=\"line\">      .clear()</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span>,</span><br><span class=\"line\">        include: [<span class=\"string\">\"./src/icons\"</span>]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>svgo-loader加载器options的plugins配置项参考<a href=\"https://github.com/svg/svgo#what-it-can-do\" target=\"_blank\" rel=\"noopener\">svgo配置项列表</a>。</p>\n<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><p>上面直接清除默认的svg配置可能会引起异常，应该排除“./src/icons”这个svg图标文件夹即可，方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除svg默认配置对./src/icons文件夹的处理</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .exclude</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，对“./src/icons”添加一个新的rule，配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的rule处理./src/icons文件夹的svg文件</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg-sprite\"</span>)</span><br><span class=\"line\">      .test(<span class=\"regexp\">/\\.svg$/</span>)</span><br><span class=\"line\">      .include</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完整的配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  chainWebpack: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除svg默认配置对./src/icons文件夹的处理</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">      .exclude</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加新的rule处理./src/icons文件夹的svg文件</span></span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(<span class=\"string\">\"svg-sprite\"</span>)</span><br><span class=\"line\">      .test(<span class=\"regexp\">/\\.svg$/</span>)</span><br><span class=\"line\">      .include</span><br><span class=\"line\">      .add(resolve(<span class=\"string\">\"./src/icons\"</span>))</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .use(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        symbolId: <span class=\"string\">\"icon-[name]\"</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">      .before(<span class=\"string\">\"svg-sprite-loader\"</span>)</span><br><span class=\"line\">      .use(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .loader(<span class=\"string\">\"svgo-loader\"</span>)</span><br><span class=\"line\">      .options(&#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">          &#123;<span class=\"attr\">removeAttrs</span>: &#123;<span class=\"attr\">attrs</span>: <span class=\"string\">\"path:fill\"</span>&#125;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .end()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Vue前端项目性能优化建议","date":"2019-11-19T16:00:00.000Z","toc":false,"comments":0,"_content":"\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。得益于 Vue 的响应式系统和虚拟 DOM 系统，性能足够的优秀，因此，Vue 应用的开发者一般不需要做额外的优化工作。但在实践中仍然有可能遇到性能问题，下面介绍一些关于Vue前端项目性能优化的建议。\n\n<!--more-->\n\n## 开启路由懒加载\n\n当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n\n查看[Vue路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)\n\n## 按需加载第三方库\n\n现在，开发前端项目基本都避免不了要使用一些第三方库，随着项目进度，通常第三方库用的越来越多，严重影响页面性能。按需加载是针对某些第三方库体积比较大的情况下，优化webpack打包后的js体积，减少页面的加载时间。建议使用[Webpack Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)分析器，它使用交互式可缩放树图可视化Webpack输出文件的大小。\n\n常见第三方库按需按需引入方法如下：\n* [Lodash](https://github.com/lodash/lodash#installation)\n* [element-ui](https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru)\n* [iView](https://www.iviewui.com/docs/guide/start#AXYY)\n* [Muse-UI](https://muse-ui.org/#/an-xu-yin-ru)\n* [Vant](https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/quickstart#yin-ru-zu-jian)\n* [ECharts](https://www.echartsjs.com/zh/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts)\n\n## 使用 Vue Virtual Scroller 优化长列表\n\n当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，建议使用[vue-virtual-scoller](https://github.com/Akryum/vue-virtual-scroller)。它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。\n\n## 避免滥用 Watch\n\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。\n\n详情移步[计算属性 vs 侦听属性](https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7)\n\n## 模板预编译\n\n当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。\n\n预编译模板最简单的方式就是使用[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。\n\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 [vue-template-loader](https://github.com/ktsn/vue-template-loader)，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n\n## 提取组件的 CSS\n\n当使用单文件组件时，组件内的 CSS 会以 <style> 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段“无样式内容闪烁 (fouc)”。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。\n\n查阅这个构建工具各自的文档来了解更多：\n* [webpack + vue-loader](https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html) (vue-cli 的 webpack 模板已经预先配置好)\n* [Browserify + vueify](https://github.com/vuejs/vueify#css-extraction)\n* [Rollup + rollup-plugin-vue](https://rollup-plugin-vue.vuejs.org/#/en/2.3/?id=custom-handler)\n\n## 使用keep-alive缓存动态组件状态\n\n[keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。\n\n## 资源的合并与压缩\n\n资源的合并与压缩是web性能优化的基础手段。资源的合并与压缩主要涉及减少HTTP请求数量，减少请求资源的大小。当然，官方脚手架[@vue/cli](https://cli.vuejs.org/zh/)已经做这些配置。如果你是自己搭建Vue开发环境，那么你需要针对js、css、图片等资源进行合并与压缩处理。\n\n## 使用CDN加速\n\n打包时不打包 vue、vuex、vue-router、axios 等，减小打包文件。建议使用CDN加速服务，或换用国内的 [bootcdn](https://www.bootcdn.cn/) 直接引入到根目录的 index.html 中。例如：\n```html\n<script src=\"//cdn.bootcss.com/vue/2.2.5/vue.min.js\"></script>\n<script src=\"//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js\"></script>\n<script src=\"//cdn.bootcss.com/vuex/2.2.1/vuex.min.js\"></script>\n<script src=\"//cdn.bootcss.com/axios/0.15.3/axios.min.js\"></script>\n```\n在 webpack 里有个 externals，可以忽略不需要打包的库：\n```json\nexternals: {\n  'vue': 'Vue',\n  'vue-router': 'VueRouter',\n  'vuex': 'Vuex',\n  'axios': 'axios'\n}\n```","source":"_posts/2019-11-20-Vue前端项目性能优化建议.md","raw":"---\ntitle: Vue前端项目性能优化建议\ndate: 2019-11-20\ntoc: false\ncomments: false\ntags:\n    - 性能优化\ncategories:\n    - Vue\n---\n\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。得益于 Vue 的响应式系统和虚拟 DOM 系统，性能足够的优秀，因此，Vue 应用的开发者一般不需要做额外的优化工作。但在实践中仍然有可能遇到性能问题，下面介绍一些关于Vue前端项目性能优化的建议。\n\n<!--more-->\n\n## 开启路由懒加载\n\n当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n\n查看[Vue路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)\n\n## 按需加载第三方库\n\n现在，开发前端项目基本都避免不了要使用一些第三方库，随着项目进度，通常第三方库用的越来越多，严重影响页面性能。按需加载是针对某些第三方库体积比较大的情况下，优化webpack打包后的js体积，减少页面的加载时间。建议使用[Webpack Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)分析器，它使用交互式可缩放树图可视化Webpack输出文件的大小。\n\n常见第三方库按需按需引入方法如下：\n* [Lodash](https://github.com/lodash/lodash#installation)\n* [element-ui](https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru)\n* [iView](https://www.iviewui.com/docs/guide/start#AXYY)\n* [Muse-UI](https://muse-ui.org/#/an-xu-yin-ru)\n* [Vant](https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/quickstart#yin-ru-zu-jian)\n* [ECharts](https://www.echartsjs.com/zh/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts)\n\n## 使用 Vue Virtual Scroller 优化长列表\n\n当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，建议使用[vue-virtual-scoller](https://github.com/Akryum/vue-virtual-scroller)。它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。\n\n## 避免滥用 Watch\n\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。\n\n详情移步[计算属性 vs 侦听属性](https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7)\n\n## 模板预编译\n\n当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。\n\n预编译模板最简单的方式就是使用[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。\n\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 [vue-template-loader](https://github.com/ktsn/vue-template-loader)，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n\n## 提取组件的 CSS\n\n当使用单文件组件时，组件内的 CSS 会以 <style> 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段“无样式内容闪烁 (fouc)”。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。\n\n查阅这个构建工具各自的文档来了解更多：\n* [webpack + vue-loader](https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html) (vue-cli 的 webpack 模板已经预先配置好)\n* [Browserify + vueify](https://github.com/vuejs/vueify#css-extraction)\n* [Rollup + rollup-plugin-vue](https://rollup-plugin-vue.vuejs.org/#/en/2.3/?id=custom-handler)\n\n## 使用keep-alive缓存动态组件状态\n\n[keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。\n\n## 资源的合并与压缩\n\n资源的合并与压缩是web性能优化的基础手段。资源的合并与压缩主要涉及减少HTTP请求数量，减少请求资源的大小。当然，官方脚手架[@vue/cli](https://cli.vuejs.org/zh/)已经做这些配置。如果你是自己搭建Vue开发环境，那么你需要针对js、css、图片等资源进行合并与压缩处理。\n\n## 使用CDN加速\n\n打包时不打包 vue、vuex、vue-router、axios 等，减小打包文件。建议使用CDN加速服务，或换用国内的 [bootcdn](https://www.bootcdn.cn/) 直接引入到根目录的 index.html 中。例如：\n```html\n<script src=\"//cdn.bootcss.com/vue/2.2.5/vue.min.js\"></script>\n<script src=\"//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js\"></script>\n<script src=\"//cdn.bootcss.com/vuex/2.2.1/vuex.min.js\"></script>\n<script src=\"//cdn.bootcss.com/axios/0.15.3/axios.min.js\"></script>\n```\n在 webpack 里有个 externals，可以忽略不需要打包的库：\n```json\nexternals: {\n  'vue': 'Vue',\n  'vue-router': 'VueRouter',\n  'vuex': 'Vuex',\n  'axios': 'axios'\n}\n```","slug":"2019-11-20-Vue前端项目性能优化建议","published":1,"updated":"2019-11-20T07:36:12.973Z","layout":"post","photos":[],"link":"","_id":"ck36z4cwd0000vwqx3mfkmdrx","content":"<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。得益于 Vue 的响应式系统和虚拟 DOM 系统，性能足够的优秀，因此，Vue 应用的开发者一般不需要做额外的优化工作。但在实践中仍然有可能遇到性能问题，下面介绍一些关于Vue前端项目性能优化的建议。</p>\n<a id=\"more\"></a>\n<h2 id=\"开启路由懒加载\"><a href=\"#开启路由懒加载\" class=\"headerlink\" title=\"开启路由懒加载\"></a>开启路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>\n<p>查看<a href=\"https://router.vuejs.org/zh/guide/advanced/lazy-loading.html\" target=\"_blank\" rel=\"noopener\">Vue路由懒加载</a></p>\n<h2 id=\"按需加载第三方库\"><a href=\"#按需加载第三方库\" class=\"headerlink\" title=\"按需加载第三方库\"></a>按需加载第三方库</h2><p>现在，开发前端项目基本都避免不了要使用一些第三方库，随着项目进度，通常第三方库用的越来越多，严重影响页面性能。按需加载是针对某些第三方库体积比较大的情况下，优化webpack打包后的js体积，减少页面的加载时间。建议使用<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">Webpack Bundle Analyzer</a>分析器，它使用交互式可缩放树图可视化Webpack输出文件的大小。</p>\n<p>常见第三方库按需按需引入方法如下：</p>\n<ul>\n<li><a href=\"https://github.com/lodash/lodash#installation\" target=\"_blank\" rel=\"noopener\">Lodash</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru\" target=\"_blank\" rel=\"noopener\">element-ui</a></li>\n<li><a href=\"https://www.iviewui.com/docs/guide/start#AXYY\" target=\"_blank\" rel=\"noopener\">iView</a></li>\n<li><a href=\"https://muse-ui.org/#/an-xu-yin-ru\" target=\"_blank\" rel=\"noopener\">Muse-UI</a></li>\n<li><a href=\"https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/quickstart#yin-ru-zu-jian\" target=\"_blank\" rel=\"noopener\">Vant</a></li>\n<li><a href=\"https://www.echartsjs.com/zh/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts\" target=\"_blank\" rel=\"noopener\">ECharts</a></li>\n</ul>\n<h2 id=\"使用-Vue-Virtual-Scroller-优化长列表\"><a href=\"#使用-Vue-Virtual-Scroller-优化长列表\" class=\"headerlink\" title=\"使用 Vue Virtual Scroller 优化长列表\"></a>使用 Vue Virtual Scroller 优化长列表</h2><p>当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，建议使用<a href=\"https://github.com/Akryum/vue-virtual-scroller\" target=\"_blank\" rel=\"noopener\">vue-virtual-scoller</a>。它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。</p>\n<h2 id=\"避免滥用-Watch\"><a href=\"#避免滥用-Watch\" class=\"headerlink\" title=\"避免滥用 Watch\"></a>避免滥用 Watch</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p>\n<p>详情移步<a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">计算属性 vs 侦听属性</a></p>\n<h2 id=\"模板预编译\"><a href=\"#模板预编译\" class=\"headerlink\" title=\"模板预编译\"></a>模板预编译</h2><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>\n<p>预编译模板最简单的方式就是使用<a href=\"https://cn.vuejs.org/v2/guide/single-file-components.html\" target=\"_blank\" rel=\"noopener\">单文件组件</a>——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>\n<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 <a href=\"https://github.com/ktsn/vue-template-loader\" target=\"_blank\" rel=\"noopener\">vue-template-loader</a>，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>\n<h2 id=\"提取组件的-CSS\"><a href=\"#提取组件的-CSS\" class=\"headerlink\" title=\"提取组件的 CSS\"></a>提取组件的 CSS</h2><p>当使用单文件组件时，组件内的 CSS 会以 <style> 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段“无样式内容闪烁 (fouc)”。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>\n<p>查阅这个构建工具各自的文档来了解更多：</p>\n<ul>\n<li><a href=\"https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html\">webpack + vue-loader</a> (vue-cli 的 webpack 模板已经预先配置好)</li>\n<li><a href=\"https://github.com/vuejs/vueify#css-extraction\">Browserify + vueify</a></li>\n<li><a href=\"https://rollup-plugin-vue.vuejs.org/#/en/2.3/?id=custom-handler\">Rollup + rollup-plugin-vue</a></li>\n</ul>\n<h2 id=\"使用keep-alive缓存动态组件状态\"><a href=\"#使用keep-alive缓存动态组件状态\" class=\"headerlink\" title=\"使用keep-alive缓存动态组件状态\"></a>使用keep-alive缓存动态组件状态</h2><p><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive</a>是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。</p>\n<h2 id=\"资源的合并与压缩\"><a href=\"#资源的合并与压缩\" class=\"headerlink\" title=\"资源的合并与压缩\"></a>资源的合并与压缩</h2><p>资源的合并与压缩是web性能优化的基础手段。资源的合并与压缩主要涉及减少HTTP请求数量，减少请求资源的大小。当然，官方脚手架<a href=\"https://cli.vuejs.org/zh/\">@vue/cli</a>已经做这些配置。如果你是自己搭建Vue开发环境，那么你需要针对js、css、图片等资源进行合并与压缩处理。</p>\n<h2 id=\"使用CDN加速\"><a href=\"#使用CDN加速\" class=\"headerlink\" title=\"使用CDN加速\"></a>使用CDN加速</h2><p>打包时不打包 vue、vuex、vue-router、axios 等，减小打包文件。建议使用CDN加速服务，或换用国内的 <a href=\"https://www.bootcdn.cn/\">bootcdn</a> 直接引入到根目录的 index.html 中。例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vue/2.2.5/vue.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vuex/2.2.1/vuex.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/axios/0.15.3/axios.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在 webpack 里有个 externals，可以忽略不需要打包的库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">  'vue': 'Vue',</span><br><span class=\"line\">  'vue-router': 'VueRouter',</span><br><span class=\"line\">  'vuex': 'Vuex',</span><br><span class=\"line\">  'axios': 'axios'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</style></p>","site":{"data":{}},"excerpt":"<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。得益于 Vue 的响应式系统和虚拟 DOM 系统，性能足够的优秀，因此，Vue 应用的开发者一般不需要做额外的优化工作。但在实践中仍然有可能遇到性能问题，下面介绍一些关于Vue前端项目性能优化的建议。</p>","more":"<h2 id=\"开启路由懒加载\"><a href=\"#开启路由懒加载\" class=\"headerlink\" title=\"开启路由懒加载\"></a>开启路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>\n<p>查看<a href=\"https://router.vuejs.org/zh/guide/advanced/lazy-loading.html\" target=\"_blank\" rel=\"noopener\">Vue路由懒加载</a></p>\n<h2 id=\"按需加载第三方库\"><a href=\"#按需加载第三方库\" class=\"headerlink\" title=\"按需加载第三方库\"></a>按需加载第三方库</h2><p>现在，开发前端项目基本都避免不了要使用一些第三方库，随着项目进度，通常第三方库用的越来越多，严重影响页面性能。按需加载是针对某些第三方库体积比较大的情况下，优化webpack打包后的js体积，减少页面的加载时间。建议使用<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">Webpack Bundle Analyzer</a>分析器，它使用交互式可缩放树图可视化Webpack输出文件的大小。</p>\n<p>常见第三方库按需按需引入方法如下：</p>\n<ul>\n<li><a href=\"https://github.com/lodash/lodash#installation\" target=\"_blank\" rel=\"noopener\">Lodash</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru\" target=\"_blank\" rel=\"noopener\">element-ui</a></li>\n<li><a href=\"https://www.iviewui.com/docs/guide/start#AXYY\" target=\"_blank\" rel=\"noopener\">iView</a></li>\n<li><a href=\"https://muse-ui.org/#/an-xu-yin-ru\" target=\"_blank\" rel=\"noopener\">Muse-UI</a></li>\n<li><a href=\"https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/quickstart#yin-ru-zu-jian\" target=\"_blank\" rel=\"noopener\">Vant</a></li>\n<li><a href=\"https://www.echartsjs.com/zh/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts\" target=\"_blank\" rel=\"noopener\">ECharts</a></li>\n</ul>\n<h2 id=\"使用-Vue-Virtual-Scroller-优化长列表\"><a href=\"#使用-Vue-Virtual-Scroller-优化长列表\" class=\"headerlink\" title=\"使用 Vue Virtual Scroller 优化长列表\"></a>使用 Vue Virtual Scroller 优化长列表</h2><p>当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，建议使用<a href=\"https://github.com/Akryum/vue-virtual-scroller\" target=\"_blank\" rel=\"noopener\">vue-virtual-scoller</a>。它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。</p>\n<h2 id=\"避免滥用-Watch\"><a href=\"#避免滥用-Watch\" class=\"headerlink\" title=\"避免滥用 Watch\"></a>避免滥用 Watch</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p>\n<p>详情移步<a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">计算属性 vs 侦听属性</a></p>\n<h2 id=\"模板预编译\"><a href=\"#模板预编译\" class=\"headerlink\" title=\"模板预编译\"></a>模板预编译</h2><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>\n<p>预编译模板最简单的方式就是使用<a href=\"https://cn.vuejs.org/v2/guide/single-file-components.html\" target=\"_blank\" rel=\"noopener\">单文件组件</a>——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>\n<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 <a href=\"https://github.com/ktsn/vue-template-loader\" target=\"_blank\" rel=\"noopener\">vue-template-loader</a>，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>\n<h2 id=\"提取组件的-CSS\"><a href=\"#提取组件的-CSS\" class=\"headerlink\" title=\"提取组件的 CSS\"></a>提取组件的 CSS</h2><p>当使用单文件组件时，组件内的 CSS 会以 <style> 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段“无样式内容闪烁 (fouc)”。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>\n<p>查阅这个构建工具各自的文档来了解更多：</p>\n<ul>\n<li><a href=\"https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html\">webpack + vue-loader</a> (vue-cli 的 webpack 模板已经预先配置好)</li>\n<li><a href=\"https://github.com/vuejs/vueify#css-extraction\">Browserify + vueify</a></li>\n<li><a href=\"https://rollup-plugin-vue.vuejs.org/#/en/2.3/?id=custom-handler\">Rollup + rollup-plugin-vue</a></li>\n</ul>\n<h2 id=\"使用keep-alive缓存动态组件状态\"><a href=\"#使用keep-alive缓存动态组件状态\" class=\"headerlink\" title=\"使用keep-alive缓存动态组件状态\"></a>使用keep-alive缓存动态组件状态</h2><p><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive</a>是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。</p>\n<h2 id=\"资源的合并与压缩\"><a href=\"#资源的合并与压缩\" class=\"headerlink\" title=\"资源的合并与压缩\"></a>资源的合并与压缩</h2><p>资源的合并与压缩是web性能优化的基础手段。资源的合并与压缩主要涉及减少HTTP请求数量，减少请求资源的大小。当然，官方脚手架<a href=\"https://cli.vuejs.org/zh/\">@vue/cli</a>已经做这些配置。如果你是自己搭建Vue开发环境，那么你需要针对js、css、图片等资源进行合并与压缩处理。</p>\n<h2 id=\"使用CDN加速\"><a href=\"#使用CDN加速\" class=\"headerlink\" title=\"使用CDN加速\"></a>使用CDN加速</h2><p>打包时不打包 vue、vuex、vue-router、axios 等，减小打包文件。建议使用CDN加速服务，或换用国内的 <a href=\"https://www.bootcdn.cn/\">bootcdn</a> 直接引入到根目录的 index.html 中。例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vue/2.2.5/vue.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vue-router/2.3.0/vue-router.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/vuex/2.2.1/vuex.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//cdn.bootcss.com/axios/0.15.3/axios.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在 webpack 里有个 externals，可以忽略不需要打包的库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">  'vue': 'Vue',</span><br><span class=\"line\">  'vue-router': 'VueRouter',</span><br><span class=\"line\">  'vuex': 'Vuex',</span><br><span class=\"line\">  'axios': 'axios'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</style></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck31ar48q0001acqxwixdma7z","category_id":"ck31ar48u0003acqxp323vlse","_id":"ck31ar48x0006acqxv7q4gxmk"},{"post_id":"ck31ar49o0007acqxywmhlhzf","category_id":"ck31ar48u0003acqxp323vlse","_id":"ck31ar49v000facqxhfibi1nh"},{"post_id":"ck31ar49s000bacqxcrhimcp9","category_id":"ck31ar48u0003acqxp323vlse","_id":"ck31ar49y000jacqxhn1wf5qp"},{"post_id":"ck31ar49v000hacqxfatnlntr","category_id":"ck31ar48u0003acqxp323vlse","_id":"ck31ar4a3000qacqxb47o0b69"},{"post_id":"ck31ar49r0009acqxtlr0g6ep","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4a4000uacqxrezd3bj1"},{"post_id":"ck31ar49x000iacqxvwgjytn5","category_id":"ck31ar48u0003acqxp323vlse","_id":"ck31ar4a6000yacqxz36r7p4d"},{"post_id":"ck31ar49z000nacqxzrskexr9","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4a70011acqxi0er0lnr"},{"post_id":"ck31ar49u000eacqxkcyo7gw6","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4a90014acqxroapkl2w"},{"post_id":"ck31ar4a4000tacqx4q5ybpud","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4aa0017acqxoozpfev8"},{"post_id":"ck31ar4a5000xacqxnekzjq2u","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4ab001aacqxij9sit46"},{"post_id":"ck31ar4a2000pacqxlyf3g7rj","category_id":"ck31ar4a5000vacqx06vmts97","_id":"ck31ar4ad001dacqxydoifcup"},{"post_id":"ck31ar4a6000zacqxj6dyfa8o","category_id":"ck31ar4a90015acqxcp8o526p","_id":"ck31ar4ap001hacqxrcrqtbhj"},{"post_id":"ck31ar4aj001facqx75dkq7y4","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4at001nacqxg53xx5yh"},{"post_id":"ck31ar4a80013acqxv75s3h09","category_id":"ck31ar4ac001cacqxre4t07v3","_id":"ck31ar4av001racqxy7iwaw7p"},{"post_id":"ck31ar4ao001gacqxmd54q97a","category_id":"ck31ar4a90015acqxcp8o526p","_id":"ck31ar4ax001vacqxww4l6eyq"},{"post_id":"ck31ar4a90016acqxiz52stc9","category_id":"ck31ar4ap001iacqx5k5j34tl","_id":"ck31ar4ay001yacqxbh7lvbh6"},{"post_id":"ck31ar4as001macqxyraeontm","category_id":"ck31ar4ap001iacqx5k5j34tl","_id":"ck31ar4b00021acqxyhqhofsj"},{"post_id":"ck31ar4au001qacqx8sgqthwr","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4b00023acqx1mtdbth0"},{"post_id":"ck31ar4ab0019acqxmrrozg8h","category_id":"ck31ar4ap001iacqx5k5j34tl","_id":"ck31ar4b10025acqx6q3od7fy"},{"post_id":"ck31ar4aw001uacqxs0303z5n","category_id":"ck31ar4a90015acqxcp8o526p","_id":"ck31ar4b10027acqxfbmsir22"},{"post_id":"ck31ar4ac001bacqx5ipzphpr","category_id":"ck31ar4ax001wacqxsb06s43o","_id":"ck31ar4b2002bacqxio2xf3c6"},{"post_id":"ck31ar4aq001kacqx3ffvg7ym","category_id":"ck31ar4b00022acqxj9txptsu","_id":"ck31ar4b3002dacqxv60kywvf"},{"post_id":"ck31ar4ay001xacqxl8m4gid7","category_id":"ck31ar4b10028acqxrcbktah4","_id":"ck31ar4b4002hacqx4iijva5a"},{"post_id":"ck31ar4az0020acqxqqy578ss","category_id":"ck31ar4b10028acqxrcbktah4","_id":"ck31ar4b5002kacqx1zh85z8c"},{"post_id":"ck31ar4fc004bacqxo69dlb9x","category_id":"ck31ar49t000cacqxrmaadmwa","_id":"ck31ar4fj004hacqxg87k8ujm"},{"post_id":"ck31ar4fg004eacqx94tg62h8","category_id":"ck31ar4a90015acqxcp8o526p","_id":"ck31ar4fn004macqxj5oz9tli"},{"post_id":"ck31ar4fe004cacqxsoepahur","category_id":"ck31ar4fh004facqxz0eczlko","_id":"ck31ar4fo004qacqxukj9106j"},{"post_id":"ck31ar4fn004oacqx750fhi3q","category_id":"ck31ar4ap001iacqx5k5j34tl","_id":"ck31ar4fp004tacqxfvpe9g2m"},{"post_id":"ck31ar4fi004gacqx4m4zk5g8","category_id":"ck31ar4fn004nacqxvbb650oz","_id":"ck31ar4fq004wacqxlsval7cg"},{"post_id":"ck31ar4fk004iacqxebybnms9","category_id":"ck31ar4fp004racqxoe68fryy","_id":"ck31ar4fq0050acqxpz7t2fd3"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","category_id":"ck31ar4fp004vacqxam4hv4pj","_id":"ck31ar4fq0053acqxgei7rcg2"},{"post_id":"ck31ar4hf005vacqxxq4srt1n","category_id":"ck31ar4fp004vacqxam4hv4pj","_id":"ck31ar4hh005xacqx92we2jqd"},{"post_id":"ck31arlkw0060acqx7ta961oe","category_id":"ck31ar4ac001cacqxre4t07v3","_id":"ck31arll20062acqxovbwtnwu"},{"post_id":"ck36z4cwd0000vwqx3mfkmdrx","category_id":"ck31ar4a5000vacqx06vmts97","_id":"ck36z4cwm0002vwqxi14i6nnr"}],"PostTag":[{"post_id":"ck31ar48q0001acqxwixdma7z","tag_id":"ck31ar48v0004acqxogci8m7l","_id":"ck31ar48x0005acqxmpq74aku"},{"post_id":"ck31ar49o0007acqxywmhlhzf","tag_id":"ck31ar48v0004acqxogci8m7l","_id":"ck31ar49s000aacqxkrxsssdl"},{"post_id":"ck31ar49s000bacqxcrhimcp9","tag_id":"ck31ar48v0004acqxogci8m7l","_id":"ck31ar49v000gacqx4cczznzc"},{"post_id":"ck31ar49v000hacqxfatnlntr","tag_id":"ck31ar48v0004acqxogci8m7l","_id":"ck31ar49z000macqx3xjz8ztj"},{"post_id":"ck31ar49r0009acqxtlr0g6ep","tag_id":"ck31ar49t000dacqxr0f8dk06","_id":"ck31ar4a2000oacqxyrxv5949"},{"post_id":"ck31ar49x000iacqxvwgjytn5","tag_id":"ck31ar48v0004acqxogci8m7l","_id":"ck31ar4a4000sacqxippvmbyd"},{"post_id":"ck31ar49u000eacqxkcyo7gw6","tag_id":"ck31ar49y000lacqxayu6tdvl","_id":"ck31ar4a5000wacqxwtmcrcb5"},{"post_id":"ck31ar49z000nacqxzrskexr9","tag_id":"ck31ar4a3000racqxk16lwgy2","_id":"ck31ar4a80012acqxt4t0mtfo"},{"post_id":"ck31ar4a2000pacqxlyf3g7rj","tag_id":"ck31ar4a70010acqxm84uqyb7","_id":"ck31ar4ar001lacqxospww6rf"},{"post_id":"ck31ar4a2000pacqxlyf3g7rj","tag_id":"ck31ar4aa0018acqxjkht6smm","_id":"ck31ar4at001pacqxful37g7w"},{"post_id":"ck31ar4a2000pacqxlyf3g7rj","tag_id":"ck31ar4ad001eacqx1e4gu0kd","_id":"ck31ar4av001tacqxx82gp18m"},{"post_id":"ck31ar4a4000tacqx4q5ybpud","tag_id":"ck31ar4aq001jacqxjp1fsm20","_id":"ck31ar4b10026acqxnut72u1t"},{"post_id":"ck31ar4a4000tacqx4q5ybpud","tag_id":"ck31ar4av001sacqxt55gaw5j","_id":"ck31ar4b20029acqxvdrhw8k5"},{"post_id":"ck31ar4a4000tacqx4q5ybpud","tag_id":"ck31ar4az001zacqxknqe5f8b","_id":"ck31ar4b2002cacqxtrdyrtxk"},{"post_id":"ck31ar4a5000xacqxnekzjq2u","tag_id":"ck31ar4b10024acqxmuw7v1ny","_id":"ck31ar4b3002facqxcccxhe2w"},{"post_id":"ck31ar4a6000zacqxj6dyfa8o","tag_id":"ck31ar4b2002aacqxh4ls8qs3","_id":"ck31ar4b5002jacqxzpyskgih"},{"post_id":"ck31ar4a6000zacqxj6dyfa8o","tag_id":"ck31ar4b4002gacqxklas20k3","_id":"ck31ar4b5002lacqxv6yr3iq0"},{"post_id":"ck31ar4a80013acqxv75s3h09","tag_id":"ck31ar4b4002iacqxma2dl9qs","_id":"ck31ar4b7002qacqxknuudkyg"},{"post_id":"ck31ar4a80013acqxv75s3h09","tag_id":"ck31ar4b5002macqxr4f4be4x","_id":"ck31ar4b7002racqxnf2m6kdy"},{"post_id":"ck31ar4a80013acqxv75s3h09","tag_id":"ck31ar4b6002nacqx9e21ui4z","_id":"ck31ar4b8002tacqxui8bxlm5"},{"post_id":"ck31ar4a80013acqxv75s3h09","tag_id":"ck31ar4b6002oacqxes8ikdjq","_id":"ck31ar4b8002uacqxlctio0v1"},{"post_id":"ck31ar4a90016acqxiz52stc9","tag_id":"ck31ar4b7002pacqx9z5buy14","_id":"ck31ar4b9002yacqxuxegbgtw"},{"post_id":"ck31ar4a90016acqxiz52stc9","tag_id":"ck31ar4b7002sacqx9je01b57","_id":"ck31ar4ba002zacqxja0avv9l"},{"post_id":"ck31ar4a90016acqxiz52stc9","tag_id":"ck31ar4b8002vacqxtpo5glxa","_id":"ck31ar4ba0031acqxuwgk4tye"},{"post_id":"ck31ar4a90016acqxiz52stc9","tag_id":"ck31ar4b8002wacqxhfwxzpis","_id":"ck31ar4ba0032acqx7e97zuj0"},{"post_id":"ck31ar4ab0019acqxmrrozg8h","tag_id":"ck31ar4b6002oacqxes8ikdjq","_id":"ck31ar4bc0036acqx9x3q6qh5"},{"post_id":"ck31ar4ab0019acqxmrrozg8h","tag_id":"ck31ar4ba0030acqxpf252cjh","_id":"ck31ar4bd0037acqx1ikyuajb"},{"post_id":"ck31ar4ab0019acqxmrrozg8h","tag_id":"ck31ar4bb0033acqxz7wup9uh","_id":"ck31ar4bd0039acqxvz00us21"},{"post_id":"ck31ar4ab0019acqxmrrozg8h","tag_id":"ck31ar4b8002wacqxhfwxzpis","_id":"ck31ar4bd003aacqxthjnons5"},{"post_id":"ck31ar4ac001bacqx5ipzphpr","tag_id":"ck31ar4bc0035acqxmu9p2m9k","_id":"ck31ar4bf003dacqxluhqxbrt"},{"post_id":"ck31ar4ac001bacqx5ipzphpr","tag_id":"ck31ar4bd0038acqx830pkvdn","_id":"ck31ar4bf003eacqxemj01su3"},{"post_id":"ck31ar4ac001bacqx5ipzphpr","tag_id":"ck31ar4be003bacqxleou1hxh","_id":"ck31ar4bf003gacqxud2sggp3"},{"post_id":"ck31ar4aj001facqx75dkq7y4","tag_id":"ck31ar4be003cacqxi702h87e","_id":"ck31ar4bg003iacqxro3jmeuc"},{"post_id":"ck31ar4aj001facqx75dkq7y4","tag_id":"ck31ar4bf003facqxb2r5bulh","_id":"ck31ar4bh003jacqx77sqgi5g"},{"post_id":"ck31ar4aq001kacqx3ffvg7ym","tag_id":"ck31ar4bg003hacqxqacmvnpr","_id":"ck31ar4bh003lacqxiz6m9hdm"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bh003kacqxqd24nx9e","_id":"ck31ar4bo003uacqxe849rcxc"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4b6002oacqxes8ikdjq","_id":"ck31ar4bo003vacqx9dq17qjg"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bj003nacqxwbgpps1k","_id":"ck31ar4bp003xacqxmui91dlp"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bj003oacqx2p8rs5w7","_id":"ck31ar4bp003yacqx5m9kjqxh"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4b6002nacqx9e21ui4z","_id":"ck31ar4bq0040acqx1tow3e1v"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bk003qacqx9ltnqv81","_id":"ck31ar4bq0041acqxcw82lc1a"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bl003racqx2ybnvi8p","_id":"ck31ar4bq0043acqxg6d9fghs"},{"post_id":"ck31ar4as001macqxyraeontm","tag_id":"ck31ar4bm003sacqxui8scehh","_id":"ck31ar4br0044acqxi762kupu"},{"post_id":"ck31ar4au001qacqx8sgqthwr","tag_id":"ck31ar4bn003tacqx47wemp7x","_id":"ck31ar4br0045acqxrtmz33fx"},{"post_id":"ck31ar4au001qacqx8sgqthwr","tag_id":"ck31ar4bo003wacqx14bdxlpw","_id":"ck31ar4bs0047acqxm11e5f02"},{"post_id":"ck31ar4aw001uacqxs0303z5n","tag_id":"ck31ar4bp003zacqx2h2z5s6i","_id":"ck31ar4bs0048acqxxhx9kdxi"},{"post_id":"ck31ar4ay001xacqxl8m4gid7","tag_id":"ck31ar4bq0042acqxcjcm980e","_id":"ck31ar4bs0049acqxzvfxq3qb"},{"post_id":"ck31ar4az0020acqxqqy578ss","tag_id":"ck31ar4br0046acqxs73x8k3j","_id":"ck31ar4bs004aacqx37styxhc"},{"post_id":"ck31ar4fc004bacqxo69dlb9x","tag_id":"ck31ar4ff004dacqx62mvbunj","_id":"ck31ar4fm004kacqxytchj2xk"},{"post_id":"ck31ar4fe004cacqxsoepahur","tag_id":"ck31ar4fl004jacqxic4funfa","_id":"ck31ar4fp004uacqx9q97kbk9"},{"post_id":"ck31ar4fe004cacqxsoepahur","tag_id":"ck31ar4b7002sacqx9je01b57","_id":"ck31ar4fq004xacqxz1vsilwc"},{"post_id":"ck31ar4fe004cacqxsoepahur","tag_id":"ck31ar4fo004pacqxxzp8qncu","_id":"ck31ar4fq004zacqxy4mb98lx"},{"post_id":"ck31ar4fg004eacqx94tg62h8","tag_id":"ck31ar4fp004sacqxms94m3mk","_id":"ck31ar4fq0051acqxbb0hxz7q"},{"post_id":"ck31ar4fi004gacqx4m4zk5g8","tag_id":"ck31ar4fq004yacqxq59i7ay8","_id":"ck31ar4fr0056acqxu16n73q9"},{"post_id":"ck31ar4fi004gacqx4m4zk5g8","tag_id":"ck31ar4fq0052acqxy6zmc3to","_id":"ck31ar4fr0057acqxi57z1ggf"},{"post_id":"ck31ar4fi004gacqx4m4zk5g8","tag_id":"ck31ar4fq0054acqx3nyoiui6","_id":"ck31ar4fr0059acqx3vn82hsm"},{"post_id":"ck31ar4fk004iacqxebybnms9","tag_id":"ck31ar4fr0055acqxyb3hejfm","_id":"ck31ar4fs005cacqxdnqj2bcg"},{"post_id":"ck31ar4fk004iacqxebybnms9","tag_id":"ck31ar4fr0058acqx33fkszyq","_id":"ck31ar4fs005dacqxkwd1gunr"},{"post_id":"ck31ar4fk004iacqxebybnms9","tag_id":"ck31ar4fr005aacqxlnwp6qc3","_id":"ck31ar4fs005facqxm84oxz36"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","tag_id":"ck31ar4fr005bacqx4bej82bq","_id":"ck31ar4ft005kacqxfhpkuuo4"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","tag_id":"ck31ar4fs005eacqx488oo1az","_id":"ck31ar4ft005lacqx8sl6lyuy"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","tag_id":"ck31ar4fs005gacqxmbc4hszr","_id":"ck31ar4ft005nacqxdy0zrj2y"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","tag_id":"ck31ar4fs005hacqx7i006pcc","_id":"ck31ar4ft005oacqx40oabtfu"},{"post_id":"ck31ar4fm004lacqxvhzelvmb","tag_id":"ck31ar4fs005iacqxrpurjgrz","_id":"ck31ar4ft005qacqxrccnzmj2"},{"post_id":"ck31ar4fn004oacqx750fhi3q","tag_id":"ck31ar4fs005jacqxdxr19ar2","_id":"ck31ar4ft005racqx86fzw7pw"},{"post_id":"ck31ar4fn004oacqx750fhi3q","tag_id":"ck31ar4ft005macqx92ytvlmi","_id":"ck31ar4ft005sacqxu6t2i6ut"},{"post_id":"ck31ar4fn004oacqx750fhi3q","tag_id":"ck31ar4ft005pacqxtkeq439h","_id":"ck31ar4ft005tacqxl2i63mif"},{"post_id":"ck31ar4fn004oacqx750fhi3q","tag_id":"ck31ar4bm003sacqxui8scehh","_id":"ck31ar4fu005uacqx7leq7xlr"},{"post_id":"ck31ar4hf005vacqxxq4srt1n","tag_id":"ck31ar4hh005wacqxq31px2et","_id":"ck31ar4hh005yacqxffv7auiv"},{"post_id":"ck31ar4hf005vacqxxq4srt1n","tag_id":"ck31ar4ft005macqx92ytvlmi","_id":"ck31ar4hi005zacqxirbg6jov"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31arll10061acqxik6mp4nu","_id":"ck31arll40067acqxnhpk33qo"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31arll20063acqxthemmm0e","_id":"ck31arll40068acqxl8tfdeyt"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31arll30064acqxytienov2","_id":"ck31arll40069acqxza2ry8sc"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31arll30065acqxjenvx4qa","_id":"ck31arll4006aacqxg4j848a1"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31arll30066acqxur4lcomf","_id":"ck31arll4006bacqx5swnjamc"},{"post_id":"ck31arlkw0060acqx7ta961oe","tag_id":"ck31ar4b4002iacqxma2dl9qs","_id":"ck31arll4006cacqx8f15uyn3"},{"post_id":"ck36z4cwd0000vwqx3mfkmdrx","tag_id":"ck36z4cwh0001vwqxmreyru4b","_id":"ck36z4cwm0003vwqxjuhi3jr7"}],"Tag":[{"name":"JavaScript设计模式","_id":"ck31ar48v0004acqxogci8m7l"},{"name":"继承","_id":"ck31ar49t000dacqxr0f8dk06"},{"name":"this的工作原理","_id":"ck31ar49y000lacqxayu6tdvl"},{"name":"JavaScript","_id":"ck31ar4a3000racqxk16lwgy2"},{"name":"vue组件样式","_id":"ck31ar4a70010acqxm84uqyb7"},{"name":"scoped样式","_id":"ck31ar4aa0018acqxjkht6smm"},{"name":"PostCss","_id":"ck31ar4ad001eacqx1e4gu0kd"},{"name":"变量提升","_id":"ck31ar4aq001jacqxjp1fsm20"},{"name":"块作用域","_id":"ck31ar4av001sacqxt55gaw5j"},{"name":"作用域","_id":"ck31ar4az001zacqxknqe5f8b"},{"name":"JavaScript技巧","_id":"ck31ar4b10024acqxmuw7v1ny"},{"name":"设置placeholder样式","_id":"ck31ar4b2002aacqxh4ls8qs3"},{"name":"设置input样式","_id":"ck31ar4b4002gacqxklas20k3"},{"name":"web图标","_id":"ck31ar4b4002iacqxma2dl9qs"},{"name":"symbols","_id":"ck31ar4b5002macqxr4f4be4x"},{"name":"webpack","_id":"ck31ar4b6002nacqx9e21ui4z"},{"name":"gulp","_id":"ck31ar4b6002oacqxes8ikdjq"},{"name":"Webpack","_id":"ck31ar4b7002pacqx9z5buy14"},{"name":"Babel","_id":"ck31ar4b7002sacqx9je01b57"},{"name":"ES6","_id":"ck31ar4b8002vacqxtpo5glxa"},{"name":"搭建ES6开发环境","_id":"ck31ar4b8002wacqxhfwxzpis"},{"name":"gulp-better-rollup","_id":"ck31ar4ba0030acqxpf252cjh"},{"name":"rollup","_id":"ck31ar4bb0033acqxz7wup9uh"},{"name":"dialog元素","_id":"ck31ar4bc0035acqxmu9p2m9k"},{"name":"html5","_id":"ck31ar4bd0038acqx830pkvdn"},{"name":"dialog-polyfill","_id":"ck31ar4be003bacqxleou1hxh"},{"name":"管道语法","_id":"ck31ar4be003cacqxi702h87e"},{"name":"管道函数","_id":"ck31ar4bf003facqxb2r5bulh"},{"name":"JSX语法","_id":"ck31ar4bg003hacqxqacmvnpr"},{"name":"浏览器缓存","_id":"ck31ar4bh003kacqxqd24nx9e"},{"name":"gulp-rev","_id":"ck31ar4bj003nacqxwbgpps1k"},{"name":"gulp-rev-collector","_id":"ck31ar4bj003oacqx2p8rs5w7"},{"name":"clean-webpack-plugin","_id":"ck31ar4bk003qacqx9ltnqv81"},{"name":"html-webpack-plugin","_id":"ck31ar4bl003racqx2ybnvi8p"},{"name":"前端自动化","_id":"ck31ar4bm003sacqxui8scehh"},{"name":"高阶函数","_id":"ck31ar4bn003tacqx47wemp7x"},{"name":"闭包","_id":"ck31ar4bo003wacqx14bdxlpw"},{"name":"CSS计数器","_id":"ck31ar4bp003zacqx2h2z5s6i"},{"name":"栈","_id":"ck31ar4bq0042acqxcjcm980e"},{"name":"队列","_id":"ck31ar4br0046acqxs73x8k3j"},{"name":"new运算符","_id":"ck31ar4ff004dacqx62mvbunj"},{"name":"Jest","_id":"ck31ar4fl004jacqxic4funfa"},{"name":"ESLint","_id":"ck31ar4fo004pacqxxzp8qncu"},{"name":"CSS变量","_id":"ck31ar4fp004sacqxms94m3mk"},{"name":"递归算法","_id":"ck31ar4fq004yacqxq59i7ay8"},{"name":"递归函数","_id":"ck31ar4fq0052acqxy6zmc3to"},{"name":"尾递归优化","_id":"ck31ar4fq0054acqx3nyoiui6"},{"name":"自定义元素","_id":"ck31ar4fr0055acqxyb3hejfm"},{"name":"Web组件","_id":"ck31ar4fr0058acqx33fkszyq"},{"name":"Web组件生命周期","_id":"ck31ar4fr005aacqxlnwp6qc3"},{"name":"三元表达式","_id":"ck31ar4fr005bacqx4bej82bq"},{"name":"依赖注入","_id":"ck31ar4fs005eacqx488oo1az"},{"name":"多态","_id":"ck31ar4fs005gacqxmbc4hszr"},{"name":"逻辑运算符","_id":"ck31ar4fs005hacqx7i006pcc"},{"name":"策略模式","_id":"ck31ar4fs005iacqxrpurjgrz"},{"name":"文档生成工具","_id":"ck31ar4fs005jacqxdxr19ar2"},{"name":"转载","_id":"ck31ar4ft005macqx92ytvlmi"},{"name":"Vue组件文档自动生成工具","_id":"ck31ar4ft005pacqxtkeq439h"},{"name":"代码重构","_id":"ck31ar4hh005wacqxq31px2et"},{"name":"Vue CLI 3","_id":"ck31arll10061acqxik6mp4nu"},{"name":"svg-sprite-loader","_id":"ck31arll20063acqxthemmm0e"},{"name":"svgo-loader","_id":"ck31arll30064acqxytienov2"},{"name":"svgo","_id":"ck31arll30065acqxjenvx4qa"},{"name":"svg symbols","_id":"ck31arll30066acqxur4lcomf"},{"name":"性能优化","_id":"ck36z4cwh0001vwqxmreyru4b"}]}}